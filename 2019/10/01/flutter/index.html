<!DOCTYPE HTML>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  
  <title>flutter | prief | about share and go on</title>

  
  <meta name="author" content="prief">
  

  
  <meta name="description" content="flutter开发起步核心
底层渲染逻辑skia
利用自己的渲染引擎skia，不依赖OS的组件
保证了高度一致性


上层开发语言dart
Dart同时支持JIT/AOT
开发期调试效率高，发布期执行性能好特性


跨平台
高保真(自己的渲染引擎skia完成了渲染的闭环，不用js扩展调用原生)
高性">
  

  
  
  <meta name="keywords" content>
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <meta property="og:title" content="flutter">

  <meta property="og:site_name" content="prief">

  
  <meta property="og:image" content="/favicon.ico">
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="prief" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
</head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">prief</a>
    </h1>
    <p class="site-description">about share and go on</p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">Home</a></li>
      
        <li><a href="/tags">Tags</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    <article>

  
    
    <h3 class="article-title"><span>flutter</span></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2019/10/01/flutter/" rel="bookmark">
        <time class="entry-date published" datetime="2019-10-01T08:24:22.000Z">
          2019-10-01
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="flutter开发起步"><a href="#flutter开发起步" class="headerlink" title="flutter开发起步"></a>flutter开发起步</h1><h2 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h2><ul>
<li>底层渲染逻辑skia<ul>
<li>利用自己的渲染引擎skia，不依赖OS的组件</li>
<li>保证了高度一致性</li>
</ul>
</li>
<li>上层开发语言dart<ul>
<li>Dart同时支持JIT/AOT</li>
<li>开发期调试效率高，发布期执行性能好<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2></li>
</ul>
</li>
<li>跨平台</li>
<li>高保真(自己的渲染引擎skia完成了渲染的闭环，不用js扩展调用原生)</li>
<li>高性能</li>
</ul>
<h2 id="分层架构"><a href="#分层架构" class="headerlink" title="分层架构"></a>分层架构</h2><ul>
<li>embedder<ul>
<li>操作系统适配层</li>
<li>实现了渲染设置，线程设置，平台插件适配等</li>
</ul>
</li>
<li>engine<ul>
<li>skia和text提供了调用底层渲染和排版的能力</li>
<li>dart提供了运行时调用dart和渲染引擎的能力</li>
</ul>
</li>
<li>framework<ul>
<li>dart实现的UI SDK包含动画、图形绘制、手势识别等</li>
</ul>
</li>
</ul>
<h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><ul>
<li>Widget以树的形式组织成控件树</li>
<li>flutter通过每个控件创建不同类型的渲染对象组成渲染对象树</li>
<li>渲染对象树通过4个阶段完成展示<ul>
<li>布局 采用深度优先机制遍历渲染对象树，决定对象的位置和尺寸(支持布局边界和父约束)</li>
<li>绘制 按位置和尺寸绘制到不同的图层，采用深度优先机制遍历(支持重绘边界)</li>
<li>合成 将所有图层根据位置，尺寸，层级，大小，透明度等规则计算出最终显示效果简化渲染树</li>
<li>渲染 几何图层数据交给skia引擎加工成二维图像数据最终给GPU进行渲染<img src="/2019/10/01/flutter/flutter.jpg" title="flutter技术点">

</li>
</ul>
</li>
</ul>
<h2 id="跨平台方案"><a href="#跨平台方案" class="headerlink" title="跨平台方案"></a>跨平台方案</h2><ul>
<li><p>三个时代</p>
<ul>
<li>web容器时代(cordova,ionic,微信小程序都使用webview+jsBridge)</li>
<li>泛web容器时代(reactNative,weex,快应用都把渲染交给原生)</li>
<li>自绘引擎时代(flutter,客户端只提供一块画布即可)<img src="/2019/10/01/flutter/hybrid.png" title="技术选型对比">
</li>
</ul>
</li>
<li><p>图像显示基本原理</p>
<ul>
<li>CPU负责图像数据的计算</li>
<li>GPU负责图像数据的渲染，渲染后放入帧缓冲区，视频控制器根据垂直同步信号VSync以60t/s刷新</li>
<li>显示器负责图像显示</li>
</ul>
</li>
<li><p>skia</p>
<ul>
<li>c++开发的高性能2D图像绘制引擎</li>
</ul>
</li>
</ul>
<h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><ul>
<li>android<ul>
<li>AS</li>
<li>AVD(Nexus6P)</li>
</ul>
</li>
<li>ios<ul>
<li>Xcode</li>
<li>open -a Simulator</li>
</ul>
</li>
<li>flutter<ul>
<li>export PUB_HOSTED_URL=<a href="https://pub.flutter-io.cn" target="_blank" rel="noopener">https://pub.flutter-io.cn</a></li>
<li>export FLUTTER_STORAGE_BASE_URL=<a href="https://storage.flutter-io.cn" target="_blank" rel="noopener">https://storage.flutter-io.cn</a></li>
<li>export FLUTTER_HOME=/Users/dh/dev/flutter</li>
<li>export PATH=$PATH:$FLUTTER_HOME/bin</li>
<li>flutter emulators [–launch apple_ios_simulator]</li>
<li>flutter doctor</li>
</ul>
</li>
<li>doctor问题解决方案<ul>
<li>ios<ul>
<li>gem sources –add <a href="https://gems.ruby-china.com/" target="_blank" rel="noopener">https://gems.ruby-china.com/</a> –remove <a href="https://rubygems.org/" target="_blank" rel="noopener">https://rubygems.org/</a></li>
<li>gem sources -l</li>
<li>gem update –system</li>
<li>sudo gem install cocoapods</li>
<li>pod setup</li>
<li>brew update</li>
<li>brew install –HEAD usbmuxd #usb通信抽象为tcp通信，与设备进行多路socket守护进程</li>
<li>brew link usbmuxd</li>
<li>brew install –HEAD libimobiledevice # 与设备进行通信的跨平台协议库</li>
<li>brew install ideviceinstaller # 在ios设备上管理app的工具</li>
<li>signing</li>
</ul>
</li>
<li>android<ul>
<li>flutter doctor –android-licenses</li>
<li>flutter plugin</li>
</ul>
</li>
<li>vscode<ul>
<li>flutter extension</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="工程结构"><a href="#工程结构" class="headerlink" title="工程结构"></a>工程结构</h2><ul>
<li>android 安卓子工程</li>
<li>build 构建产物</li>
<li>ios ios子工程</li>
<li>lib/main.dart flutter工程入口文件</li>
<li>test 测试目录</li>
<li>flutter_app_demo.iml 工程配置文件</li>
<li>pubspec.lock 记录当前项目实际依赖信息的文件</li>
<li>pubspec.yaml 管理第三方库和资源的配置文件</li>
</ul>
<h1 id="Dart基础"><a href="#Dart基础" class="headerlink" title="Dart基础"></a>Dart基础</h1><h2 id="特性-1"><a href="#特性-1" class="headerlink" title="特性"></a>特性</h2><ul>
<li>同时支持JIT/AOT编译模式<ul>
<li>JIT just in time即时编译，适合开发环境</li>
<li>AOT ahead of time运行前编译，适合生产环境</li>
</ul>
</li>
<li>内存分配和垃圾回收机制<ul>
<li>内存线性增长，创建对象时只在堆上移动指针</li>
<li>并发是通过Isolate实现，使dart实现了无锁的内存分配</li>
<li>避免了抢占式调度和共享内存</li>
<li>垃圾回收采用多生代算法，只操作少量的活跃对象，忽略死亡对象</li>
</ul>
</li>
<li>单线程模型<ul>
<li>dar中没有线程，只有Isolate隔离区，isolate不共享内存</li>
<li>通过事件循环在事件队列上传递消息</li>
</ul>
</li>
<li>无需单独的声明式布局语言</li>
</ul>
<h2 id="语言基础"><a href="#语言基础" class="headerlink" title="语言基础"></a>语言基础</h2><ul>
<li>dart概述<ul>
<li>是类型安全的语言，不会隐式转换类型</li>
<li>所有的类型都是对象类型，都继承自顶层的Object</li>
</ul>
</li>
<li>main()作为程序的入口 </li>
<li>变量与类型<ul>
<li>var声明变量表示变量类型自动推断</li>
<li>未初始化的变量的值都是null</li>
</ul>
</li>
<li>基本类型<ul>
<li>String<ul>
<li>UTF-16的字符串组成</li>
<li>支持单引号、双引号</li>
<li>支持${expression}或$var</li>
<li>三个单引号或双引号来表示多行字符串</li>
</ul>
</li>
<li>num<ul>
<li>64位int，代表整数类型</li>
<li>64位double，代表浮点类型</li>
</ul>
</li>
<li>bool<ul>
<li>true</li>
<li>false</li>
</ul>
</li>
<li>List<ul>
<li>类型约束List<int>/ list = <int>[]</int></int></li>
<li>类型判断 list is List<int></int></li>
</ul>
</li>
<li>Map<ul>
<li>类型约束Map&lt;String,String&gt;/ map = &lt;String,String&gt;{}</li>
<li>类型判断 map is Map&lt;String,String&gt;</li>
</ul>
</li>
</ul>
</li>
<li>常量<ul>
<li>const 表示在编译期间即能确定的值</li>
<li>final 表示在运行时确定的值，一旦确定后就不可改变</li>
</ul>
</li>
<li>函数<ul>
<li>类型Function</li>
<li>支持箭头函数</li>
<li>函数的重载即提供同名但参数不同的函数，dart认为会导致混乱所以不支持</li>
<li>但dart支持更高效的可选命名参数{}和可选参数[],也支持参数默认值</li>
</ul>
</li>
<li>类<ul>
<li>实例变量/方法</li>
<li>类变量/方法 static关键字</li>
<li>变量/方法名称前面加上_即可作为private使用，否则就是public，_是库访问级别</li>
<li>构造函数语法糖就是类中调用同类名相同的方法即命名构造函数</li>
<li>实例化时可以省略new关键字</li>
<li>dart支持初始化列表，即支持多个构造函数，构造函数可以重定向:到另一个构造函数</li>
</ul>
</li>
<li>复用<ul>
<li>继承父类 extends</li>
<li>接口实现 implements</li>
<li>混入 with 解决dart缺少对多重继承的支持问题还能避免多重继承导致的菱形歧义</li>
</ul>
</li>
<li>运算符(用于简化处理变量实例缺失即null的情况)<ul>
<li>?. p?.printInfo()表示p为null时跳过，不为null时再调用，避免抛错</li>
<li>??= a??=value 如果a为null则赋值value，否则跳过</li>
<li>?? a ?? b 如果a不为null则返回a，否则返回b</li>
<li>dart提供了类似C++的运算符覆写机制，使用户可以自定义运算符，使用operator关键字和运算符一起使用来表示类成员运算符函数</li>
</ul>
</li>
</ul>
<h1 id="flutter基础"><a href="#flutter基础" class="headerlink" title="flutter基础"></a>flutter基础</h1><h2 id="widget"><a href="#widget" class="headerlink" title="widget"></a>widget</h2><ul>
<li>描述<ul>
<li>是flutter功能的抽象描述</li>
<li>是视图的配置信息</li>
<li>是数据的映射</li>
<li>一切皆widget(view/viewController/Activity/Application/Layout等)</li>
<li>由父到子、自顶向下方式构建，父widget控制子widget的样式</li>
<li>widget是不可变的，更新则意味着销毁和重建</li>
</ul>
</li>
<li>分类<ul>
<li>statelessWidget Model在build后不变，父widget通过初始化参数完全控制UI</li>
<li>statefulWidget build后还要关心和响应数据变化来进行重绘，setState就会触发</li>
</ul>
</li>
<li>渲染过程<ul>
<li>widget树 对视图的一种结构化描述数据，widget是不可变的需要很多的重建</li>
<li>element树 是widget的一个实例化对象，element.renderObject承载了视图构建的上下文数据，element是可变的，把真正需要修改的部分同步到renderObject中</li>
<li>renderObject树 主要负责视图渲染的对象<ul>
<li>布局 在renderObject中完成，采用深度优先机制遍历，确定位置和尺寸</li>
<li>绘制 在renderObject中完成，采用深度优先机制遍历，确定图层</li>
<li>合成 交给skia引擎</li>
<li>渲染 交给skia引擎，在VSync信号同步时直接从渲染树合成Bitmap，交给GPU</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><ul>
<li>app的生命周期<ul>
<li>WidgetsBindingObserver类实现钩子，此类中有很多函数</li>
<li>didChangeAppLifecycleState<ul>
<li>resumed 可见的，可以响应用户交互</li>
<li>inactive 非活动状态，不能响应用户交互(上下两个状态切换时的中间状态)</li>
<li>paused 不可见并不能响应用户交互但后台继续活动</li>
</ul>
</li>
<li>addPostFrameCallback<ul>
<li>单次frame绘制回调，只会回调1次</li>
</ul>
</li>
<li>addPersistentFrameCallback<ul>
<li>实时frame绘制回调，每次frame绘制完成后都回调</li>
<li>适合做FPS监测</li>
</ul>
</li>
</ul>
</li>
<li>视图的生命周期，通过state体现<ul>
<li>创建<ul>
<li>构造方法，调用createState创建state，构造方法决定了最初呈现效果在state生命周期只会被调用1次</li>
<li>initState，在state生命周期只会被调用1次</li>
<li>didChangeDependencies</li>
<li>build，构建视图返回一个widget</li>
</ul>
</li>
<li>更新<ul>
<li>setState</li>
<li>didChangeDependencies</li>
<li>didUpdateWidget</li>
</ul>
</li>
<li>销毁<ul>
<li>deactivate</li>
<li>dispose<img src="/2019/10/01/flutter/lifecycle1.png" title="生命周期1">
<img src="/2019/10/01/flutter/lifecycle2.png" title="生命周期2">

</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="常用widget"><a href="#常用widget" class="headerlink" title="常用widget"></a>常用widget</h2><ul>
<li>Text<ul>
<li>Text</li>
<li>Text.rich</li>
</ul>
</li>
<li>TextSpan</li>
<li>Image<ul>
<li>Image.asset(“images/logo.png”)加载本地资源图片</li>
<li>Image.file(new File(“/path/to/file”))本地图片</li>
<li>Image.network(“<a href="http://xxx/xx.xx&quot;)加载网络图片" target="_blank" rel="noopener">http://xxx/xx.xx&quot;)加载网络图片</a></li>
</ul>
</li>
<li>FadeInImage 提供了图片占位，加载动画效果</li>
<li>CachedNetworkImage 还可以把图片缓存到fs中，更强大</li>
<li>FloatingActionButton 圆形按钮</li>
<li>FlatButton 扁平化的按钮，默认背景透明，有交互效果</li>
<li>RaisedButton 凸起的按钮，默认带有灰色背景，有交互效果</li>
<li>ListView<ul>
<li>ListView 适用于少量子元素，需要提前创建子widget，性能较差</li>
<li>ListView.builder 适用于子widget比较多的情况懒加载widget</li>
<li>ListView.separated 可设置分割线样式</li>
</ul>
</li>
<li>CustomScrollView<ul>
<li>处理多个需要自定义滚动效果的widget</li>
<li>彼此独立的可滚动的widget统称为sliver</li>
</ul>
</li>
<li>ScrollController 滚动信息的监听</li>
<li>ScrollNotification 获取滚动事件的通知，将ListView纳入子widget</li>
<li>布局类widget<ul>
<li>单子widget<ul>
<li>Container</li>
<li>Padding</li>
<li>Center</li>
</ul>
</li>
<li>多子widget<ul>
<li>Row</li>
<li>Column</li>
<li>Expanded 处理容器的剩余空间</li>
</ul>
</li>
<li>层叠widget<ul>
<li>Stack 提供了层叠布局的容器</li>
<li>Positioned 提供了设置子widget位置的能力</li>
</ul>
</li>
</ul>
</li>
<li>自定义widget<ul>
<li>组合</li>
<li>自绘<ul>
<li>CustomPaint是用以承接自绘控件的容器，并不负责真正的绘制</li>
<li>绘制使用画布Canvas和画笔Paint及绘制逻辑CustomPainter控制</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="主题定制"><a href="#主题定制" class="headerlink" title="主题定制"></a>主题定制</h2><ul>
<li>主题一般包括颜色、图片、字体、字号等资源和配置</li>
<li>实现<ul>
<li>ios中通常将配置信息预写到plist中通过单例来控制</li>
<li>android中通常将配置信息写到style属性值的xml中，通过activity的setTheme切换</li>
<li>前端通过切换css即可实现</li>
</ul>
</li>
<li>flutter使用ThemeData统一管理<ul>
<li>app全局范围 MaterialApp.theme</li>
<li>widget局部范围 Theme.data<ul>
<li>不想继承任何全局配置可直接新建一个ThemeData实例</li>
<li>想继承可使用Theme.of(context).copyWith()</li>
</ul>
</li>
<li>Theme.of(context)向上查找widget树，返回最近的Theme</li>
<li>defaultTargetPlatform 可判断当前运行的平台</li>
</ul>
</li>
</ul>
<h2 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h2><ul>
<li>原生<ul>
<li>ios使用Images.xcassets管理图片，其他资源直接拖进项目即可</li>
<li>android使用drawable+分辨率命名的文件夹管理图片，res/layout放布局，res/values放资源描述文件，assets放原始文件</li>
</ul>
</li>
<li>flutter<ul>
<li>assets可管理任意类型的资源</li>
<li>pubspec.yaml中配置指向对应目录即可<ul>
<li>可以单独指向某个文件</li>
<li>也可以指向一个目录，目录制定并不会递归，所以需显示递归指定子目录</li>
</ul>
</li>
<li>资源引用<ul>
<li>Image.asset()引用图片<ul>
<li>遵循基于像素密度的管理方式1.0x、2.0x、3.0x</li>
<li>flutter根据设备分辨率加载比例最接近的图片资源实现自动降级</li>
<li>资源目录应该将1.0x、2.0x、3.0x图片资源分开管理</li>
<li>assets/bg.jpg</li>
<li>assets/2.0x/bg.jpg</li>
<li>assets/3.0x/bg.jpg</li>
<li>pubspec.yaml中仅声明1.0x资源即可 flutter.assets: assets/bg.jpg</li>
</ul>
</li>
<li>rootBundle.loadString()加载字符串文件资源</li>
<li>rootBundle.load()加载二进制文件资源</li>
<li>fonts:[{family: name,fonts:[{asset:assets/fonts/name.ttf},{asset:assets/fonts/name-Italic.ttf,style:italic},{asset:assets/fonts/name-Bold.ttf,weight:700}]}]</li>
</ul>
</li>
</ul>
</li>
<li>flutter框架前的原生配置<ul>
<li>更换app图标<ul>
<li>ios ios/Runner/Assets.xcassets/AppIcon.appiconset</li>
<li>android android/app/src/main/res/mipmap</li>
</ul>
</li>
<li>更换app启动图<ul>
<li>ios ios/Runner/Assets.xcassets/LaunchImage.imageset</li>
<li>android android/app/src/main/res/drawable/launch_background.xml</li>
</ul>
</li>
</ul>
</li>
<li>第三方组件库<ul>
<li>pubspec.yaml<ul>
<li>类似于ios中的Podfile/android中的build.gradle/前端的package.json</li>
<li>pub<ul>
<li>dart的包管理工具，类似于ios中的cocoaPods/android中的maven/前端npm</li>
<li>dart的包实际上就是一个包含了pubspec.yaml的目录</li>
</ul>
</li>
</ul>
</li>
<li>推荐包使用区间进行版本的管理，dart/flutter的sdk运行环境使用固定版本号</li>
<li>包依赖可以直接获取pub资源，也可以使用本地路径或git地址</li>
<li>所有依赖确定并下载完毕后会生成.packages文件记录包映射信息，此文件需要忽略</li>
<li>最后pub会生成pubspec.lock文件记录包的来源和版本号，此文件需要git</li>
</ul>
</li>
</ul>
<h2 id="用户交互事件"><a href="#用户交互事件" class="headerlink" title="用户交互事件"></a>用户交互事件</h2><ul>
<li>原始的指针事件(PointerEvent)<ul>
<li>原生常见的触摸事件</li>
<li>事件会从最内层冒泡到根节点，无法取消冒泡或停止分发，只能hitTestBehavior</li>
<li>ListenerWidget可以监听子widget的原始指针事件</li>
</ul>
</li>
<li>手势识别(GestureDetector)<ul>
<li>多个原始指针事件的组合操作，是指针事件的语义化封装</li>
<li>GestureDetector可以处理各种高级触摸行为，可监听多个手势但最终只有一个生效</li>
<li>不同手势通过flutter内部的arena进行PK，最终决定是什么手势</li>
<li>父组件也需要处理子组件手势时需要RawGestureDetector和GestureFactory自定义</li>
</ul>
</li>
</ul>
<h2 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h2><ul>
<li>组件通信标准方式是通过属性传值</li>
<li>跨组件通信三种方案<ul>
<li>InheritedWidget</li>
<li>Notification</li>
<li>EventBus</li>
</ul>
</li>
<li>InheritedWidget<ul>
<li>从上到下传递</li>
<li>Theme是典型案例，父子建立观察者关系，上层属性修改后，子也会更新，默认只读</li>
</ul>
</li>
<li>Notification<ul>
<li>从下到上传递</li>
<li>NotificationListener进行监听</li>
</ul>
</li>
<li>EventBus<ul>
<li>上面两种依赖父子widget关系树</li>
<li>eventBus遵循了发布/订阅模式</li>
<li>全局作用，但容器引起冲突，组件移除要清理事件</li>
</ul>
</li>
</ul>
<h2 id="路由与导航"><a href="#路由与导航" class="headerlink" title="路由与导航"></a>路由与导航</h2><ul>
<li>Route <ul>
<li>是页面的抽象，主要负责接收参数，创建页面，响应navigator的打开和关闭</li>
</ul>
</li>
<li>Navigator<ul>
<li>维护一个路由栈管理Route，可打开/关闭/替换</li>
</ul>
</li>
<li>路由管理<ul>
<li>基本路由<ul>
<li>无需提前注册，页面切换时需要自己构造页面实例</li>
<li>Navigator.push(context,MaterialPageRouter(builder:()=&gt;{}))</li>
</ul>
</li>
<li>命名路由<ul>
<li>需要提前注册，页面切换时根据注册的标示符打开</li>
<li>Navigator.pushNamed(context,”name”)</li>
</ul>
</li>
</ul>
</li>
<li>其他<ul>
<li>默认路由 UnknownRoute</li>
<li>路由页面打开参数 RouteSettings</li>
<li>路由页面返回参数</li>
</ul>
</li>
</ul>
<h1 id="flutter进阶"><a href="#flutter进阶" class="headerlink" title="flutter进阶"></a>flutter进阶</h1><h1 id="综合应用"><a href="#综合应用" class="headerlink" title="综合应用"></a>综合应用</h1>
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>


    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2019 prief
    
  </p>
</footer>
    
  </div>
</div>
</body>
</html>