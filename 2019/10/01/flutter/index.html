<!DOCTYPE HTML>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  
  <title>flutter | prief | about share and go on</title>

  
  <meta name="author" content="prief">
  

  
  <meta name="description" content="flutter开发起步核心
底层渲染逻辑skia
利用自己的渲染引擎skia，不依赖OS的组件
保证了高度一致性


上层开发语言dart
Dart同时支持JIT/AOT
开发期调试效率高，发布期执行性能好特性


跨平台
高保真(自己的渲染引擎skia完成了渲染的闭环，不用js扩展调用原生)
高性">
  

  
  
  <meta name="keywords" content>
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <meta property="og:title" content="flutter">

  <meta property="og:site_name" content="prief">

  
  <meta property="og:image" content="/favicon.ico">
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="prief" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
</head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">prief</a>
    </h1>
    <p class="site-description">about share and go on</p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">Home</a></li>
      
        <li><a href="/tags">Tags</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    <article>

  
    
    <h3 class="article-title"><span>flutter</span></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2019/10/01/flutter/" rel="bookmark">
        <time class="entry-date published" datetime="2019-10-01T08:24:22.000Z">
          2019-10-01
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="flutter开发起步"><a href="#flutter开发起步" class="headerlink" title="flutter开发起步"></a>flutter开发起步</h1><h2 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h2><ul>
<li>底层渲染逻辑skia<ul>
<li>利用自己的渲染引擎skia，不依赖OS的组件</li>
<li>保证了高度一致性</li>
</ul>
</li>
<li>上层开发语言dart<ul>
<li>Dart同时支持JIT/AOT</li>
<li>开发期调试效率高，发布期执行性能好<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2></li>
</ul>
</li>
<li>跨平台</li>
<li>高保真(自己的渲染引擎skia完成了渲染的闭环，不用js扩展调用原生)</li>
<li>高性能</li>
</ul>
<h2 id="分层架构"><a href="#分层架构" class="headerlink" title="分层架构"></a>分层架构</h2><ul>
<li>embedder<ul>
<li>操作系统适配层</li>
<li>实现了渲染设置，线程设置，平台插件适配等</li>
</ul>
</li>
<li>engine<ul>
<li>skia和text提供了调用底层渲染和排版的能力</li>
<li>dart提供了运行时调用dart和渲染引擎的能力</li>
</ul>
</li>
<li>framework<ul>
<li>dart实现的UI SDK包含动画、图形绘制、手势识别等<img src="/2019/10/01/flutter/flutterArch.png" title="flutter">

</li>
</ul>
</li>
</ul>
<h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><ul>
<li>Widget以树的形式组织成控件树</li>
<li>flutter通过每个控件创建不同类型的渲染对象组成渲染对象树</li>
<li>渲染对象树通过4个阶段完成展示<ul>
<li>布局 采用深度优先机制遍历渲染对象树，决定对象的位置和尺寸(支持布局边界和父约束)</li>
<li>绘制 按位置和尺寸绘制到不同的图层，采用深度优先机制遍历(支持重绘边界)</li>
<li>合成 将所有图层根据位置，尺寸，层级，大小，透明度等规则计算出最终显示效果简化渲染树</li>
<li>渲染 几何图层数据交给skia引擎加工成二维图像数据最终给GPU进行渲染<img src="/2019/10/01/flutter/flutter.jpg" title="flutter技术点">

</li>
</ul>
</li>
</ul>
<h2 id="跨平台方案"><a href="#跨平台方案" class="headerlink" title="跨平台方案"></a>跨平台方案</h2><ul>
<li><p>三个时代</p>
<ul>
<li>web容器时代(cordova,ionic,微信小程序都使用webview+jsBridge)</li>
<li>泛web容器时代(reactNative,weex,快应用都把渲染交给原生)</li>
<li>自绘引擎时代(flutter,客户端只提供一块画布即可)<img src="/2019/10/01/flutter/hybrid.png" title="技术选型对比">
</li>
</ul>
</li>
<li><p>图像显示基本原理</p>
<ul>
<li>CPU负责图像数据的计算</li>
<li>GPU负责图像数据的渲染，渲染后放入帧缓冲区，视频控制器根据垂直同步信号VSync以60t/s刷新给显示器</li>
<li>显示器负责图像显示</li>
</ul>
</li>
<li><p>skia</p>
<ul>
<li>c++开发的高性能2D图像绘制引擎</li>
</ul>
</li>
</ul>
<h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><ul>
<li>android<ul>
<li>AS</li>
<li>AVD(Nexus6P)</li>
</ul>
</li>
<li>ios<ul>
<li>Xcode</li>
<li>open -a Simulator</li>
</ul>
</li>
<li>flutter<ul>
<li>export PUB_HOSTED_URL=<a href="https://pub.flutter-io.cn" target="_blank" rel="noopener">https://pub.flutter-io.cn</a></li>
<li>export FLUTTER_STORAGE_BASE_URL=<a href="https://storage.flutter-io.cn" target="_blank" rel="noopener">https://storage.flutter-io.cn</a></li>
<li>export FLUTTER_HOME=/Users/dh/dev/flutter</li>
<li>export PATH=$PATH:$FLUTTER_HOME/bin</li>
<li>flutter emulators [–launch apple_ios_simulator]</li>
<li>flutter doctor</li>
</ul>
</li>
<li>doctor问题解决方案<ul>
<li>ios<ul>
<li>gem sources –add <a href="https://gems.ruby-china.com/" target="_blank" rel="noopener">https://gems.ruby-china.com/</a> –remove <a href="https://rubygems.org/" target="_blank" rel="noopener">https://rubygems.org/</a></li>
<li>gem sources -l</li>
<li>gem update –system</li>
<li>sudo gem install cocoapods</li>
<li>pod setup</li>
<li>brew update</li>
<li>brew install –HEAD usbmuxd #usb通信抽象为tcp通信，与设备进行多路socket守护进程</li>
<li>brew link usbmuxd</li>
<li>brew install –HEAD libimobiledevice # 与设备进行通信的跨平台协议库</li>
<li>brew install ideviceinstaller # 在ios设备上管理app的工具</li>
<li>signing</li>
</ul>
</li>
<li>android<ul>
<li>flutter doctor –android-licenses</li>
<li>flutter plugin</li>
</ul>
</li>
<li>vscode<ul>
<li>flutter extension</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="工程结构"><a href="#工程结构" class="headerlink" title="工程结构"></a>工程结构</h2><ul>
<li>android 安卓子工程</li>
<li>build 构建产物</li>
<li>ios ios子工程</li>
<li>lib/main.dart flutter工程入口文件</li>
<li>test 测试目录</li>
<li>flutter_app_demo.iml 工程配置文件</li>
<li>pubspec.lock 记录当前项目实际依赖信息的文件</li>
<li>pubspec.yaml 管理第三方库和资源的配置文件</li>
</ul>
<h1 id="Dart基础"><a href="#Dart基础" class="headerlink" title="Dart基础"></a>Dart基础</h1><h2 id="特性-1"><a href="#特性-1" class="headerlink" title="特性"></a>特性</h2><ul>
<li>同时支持JIT/AOT编译模式<ul>
<li>JIT just in time即时编译，适合开发环境</li>
<li>AOT ahead of time运行前编译，适合生产环境</li>
</ul>
</li>
<li>内存分配和垃圾回收机制<ul>
<li>内存线性增长，创建对象时只在堆上移动指针</li>
<li>并发是通过Isolate实现，使dart实现了无锁的内存分配</li>
<li>避免了抢占式调度和共享内存</li>
<li>垃圾回收采用多生代算法，只操作少量的活跃对象，忽略死亡对象</li>
</ul>
</li>
<li>单线程模型<ul>
<li>dart中没有线程，只有Isolate隔离区，isolate不共享内存</li>
<li>通过事件循环在事件队列上传递消息</li>
</ul>
</li>
<li>无需单独的声明式布局语言</li>
</ul>
<h2 id="语言基础"><a href="#语言基础" class="headerlink" title="语言基础"></a>语言基础</h2><ul>
<li>dart概述<ul>
<li>是类型安全的语言，不会隐式转换类型</li>
<li>所有的类型都是对象类型，都继承自顶层的Object</li>
</ul>
</li>
<li>main()作为程序的入口 </li>
<li>变量与类型<ul>
<li>var声明变量表示变量类型自动推断</li>
<li>未初始化的变量的值都是null</li>
</ul>
</li>
<li>基本类型<ul>
<li>String<ul>
<li>UTF-16的字符串组成</li>
<li>支持单引号、双引号</li>
<li>支持${expression}或$var</li>
<li>三个单引号或双引号来表示多行字符串</li>
</ul>
</li>
<li>num<ul>
<li>64位int，代表整数类型</li>
<li>64位double，代表浮点类型</li>
</ul>
</li>
<li>bool<ul>
<li>true</li>
<li>false</li>
</ul>
</li>
<li>List<ul>
<li>类型约束List<int>/ list = <int>[]</int></int></li>
<li>类型判断 list is List<int></int></li>
</ul>
</li>
<li>Map<ul>
<li>类型约束Map&lt;String,String&gt;/ map = &lt;String,String&gt;{}</li>
<li>类型判断 map is Map&lt;String,String&gt;</li>
</ul>
</li>
</ul>
</li>
<li>常量<ul>
<li>const 表示在编译期间即能确定的值</li>
<li>final 表示在运行时确定的值，一旦确定后就不可改变</li>
</ul>
</li>
<li>函数<ul>
<li>类型Function</li>
<li>支持箭头函数</li>
<li>函数的重载即提供同名但参数不同的函数，dart认为会导致混乱所以不支持</li>
<li>但dart支持更高效的可选命名参数{}和可选参数[],也支持参数默认值</li>
</ul>
</li>
<li>类<ul>
<li>实例变量/方法</li>
<li>类变量/方法 static关键字</li>
<li>变量/方法名称前面加上_即可作为private使用，否则就是public，_是库访问级别</li>
<li>构造函数语法糖就是类中调用同类名相同的方法</li>
<li>命名构造函数即类可以有多个构造函数</li>
<li>实例化时可以省略new关键字</li>
<li>dart支持初始化列表，即支持多个构造函数，构造函数可以重定向:到另一个构造函数</li>
</ul>
</li>
<li>复用<ul>
<li>继承父类 extends</li>
<li>接口实现 implements</li>
<li>混入 with 解决dart缺少对多重继承的支持问题还能避免多重继承导致的菱形歧义</li>
</ul>
</li>
<li>运算符(用于简化处理变量实例缺失即null的情况)<ul>
<li>?. p?.printInfo()表示p为null时跳过，不为null时再调用，避免抛错</li>
<li>??= a??=value 如果a为null则赋值value，否则跳过</li>
<li>?? a ?? b 如果a不为null则返回a，否则返回b</li>
<li>dart提供了类似C++的运算符覆写机制，使用户可以自定义运算符，使用operator关键字和运算符一起使用来表示类成员运算符函数</li>
</ul>
</li>
</ul>
<h1 id="flutter基础"><a href="#flutter基础" class="headerlink" title="flutter基础"></a>flutter基础</h1><h2 id="widget"><a href="#widget" class="headerlink" title="widget"></a>widget</h2><ul>
<li>描述<ul>
<li>是flutter功能的抽象描述</li>
<li>是视图的配置信息</li>
<li>是数据的映射</li>
<li>一切皆widget(view/viewController/Activity/Application/Layout等)</li>
<li>由父到子、自顶向下方式构建，父widget控制子widget的样式</li>
<li>widget是不可变的，更新则意味着销毁和重建</li>
</ul>
</li>
<li>分类<ul>
<li>statelessWidget Model在build后不变，父widget通过初始化参数完全控制UI</li>
<li>statefulWidget build后还要关心和响应数据变化来进行重绘，setState就会触发</li>
</ul>
</li>
<li>渲染过程<ul>
<li>widget树 对视图的一种结构化描述数据，widget是不可变的需要很多的重建</li>
<li>element树 是widget的一个实例化对象，element.renderObject承载了视图构建的上下文数据，element是可变的，把真正需要修改的部分同步到renderObject中</li>
<li>renderObject树 主要负责视图渲染的对象<ul>
<li>布局 在renderObject中完成，采用深度优先机制遍历，确定位置和尺寸</li>
<li>绘制 在renderObject中完成，采用深度优先机制遍历，确定图层</li>
<li>合成 交给skia引擎</li>
<li>渲染 交给skia引擎，在VSync信号同步时直接从渲染树合成Bitmap，交给GPU</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><ul>
<li>app的生命周期<ul>
<li>WidgetsBindingObserver类实现钩子，此类中有很多函数</li>
<li>didChangeAppLifecycleState<ul>
<li>resumed 可见的，可以响应用户交互</li>
<li>inactive 非活动状态，不能响应用户交互(上下两个状态切换时的中间状态)</li>
<li>paused 不可见并不能响应用户交互但后台继续活动</li>
</ul>
</li>
<li>addPostFrameCallback<ul>
<li>单次frame绘制回调，只会回调1次</li>
</ul>
</li>
<li>addPersistentFrameCallback<ul>
<li>实时frame绘制回调，每次frame绘制完成后都回调</li>
<li>适合做FPS监测</li>
</ul>
</li>
</ul>
</li>
<li>视图的生命周期，通过state体现<ul>
<li>创建<ul>
<li>构造方法，调用createState创建state，构造方法决定了最初呈现效果在state生命周期只会被调用1次</li>
<li>initState，在state生命周期只会被调用1次</li>
<li>didChangeDependencies</li>
<li>build，构建视图返回一个widget</li>
</ul>
</li>
<li>更新<ul>
<li>setState</li>
<li>didChangeDependencies</li>
<li>didUpdateWidget</li>
</ul>
</li>
<li>销毁<ul>
<li>deactivate</li>
<li>dispose<img src="/2019/10/01/flutter/lifecycle1.png" title="生命周期1">
<img src="/2019/10/01/flutter/lifecycle2.png" title="生命周期2">

</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="常用widget"><a href="#常用widget" class="headerlink" title="常用widget"></a>常用widget</h2><ul>
<li>Text<ul>
<li>Text</li>
<li>Text.rich</li>
</ul>
</li>
<li>TextSpan</li>
<li>Image<ul>
<li>Image.asset(“images/logo.png”)加载本地资源图片</li>
<li>Image.file(new File(“/path/to/file”))本地图片</li>
<li>Image.network(“<a href="http://xxx/xx.xx&quot;)加载网络图片" target="_blank" rel="noopener">http://xxx/xx.xx&quot;)加载网络图片</a></li>
</ul>
</li>
<li>FadeInImage 提供了图片占位，加载动画效果</li>
<li>CachedNetworkImage 还可以把图片缓存到fs中，更强大</li>
<li>FloatingActionButton 圆形按钮</li>
<li>FlatButton 扁平化的按钮，默认背景透明，有交互效果</li>
<li>RaisedButton 凸起的按钮，默认带有灰色背景，有交互效果</li>
<li>ListView<ul>
<li>ListView 适用于少量子元素，需要提前创建子widget，性能较差</li>
<li>ListView.builder 适用于子widget比较多的情况懒加载widget</li>
<li>ListView.separated 可设置分割线样式</li>
</ul>
</li>
<li>CustomScrollView<ul>
<li>处理多个需要自定义滚动效果的widget</li>
<li>彼此独立的可滚动的widget统称为sliver</li>
</ul>
</li>
<li>ScrollController 滚动信息的监听</li>
<li>ScrollNotification 获取滚动事件的通知，将ListView纳入子widget</li>
<li>布局类widget<ul>
<li>单子widget<ul>
<li>Container</li>
<li>Padding</li>
<li>Center</li>
</ul>
</li>
<li>多子widget<ul>
<li>Row</li>
<li>Column</li>
<li>Expanded 处理容器的剩余空间</li>
</ul>
</li>
<li>层叠widget<ul>
<li>Stack 提供了层叠布局的容器</li>
<li>Positioned 提供了设置子widget位置的能力</li>
</ul>
</li>
</ul>
</li>
<li>自定义widget<ul>
<li>组合</li>
<li>自绘<ul>
<li>CustomPaint是用以承接自绘控件的容器，并不负责真正的绘制</li>
<li>绘制使用画布Canvas和画笔Paint及绘制逻辑CustomPainter控制</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="主题定制"><a href="#主题定制" class="headerlink" title="主题定制"></a>主题定制</h2><ul>
<li>主题一般包括颜色、图片、字体、字号等资源和配置</li>
<li>实现<ul>
<li>ios中通常将配置信息预写到plist中通过单例来控制</li>
<li>android中通常将配置信息写到style属性值的xml中，通过activity的setTheme切换</li>
<li>前端通过切换css即可实现</li>
</ul>
</li>
<li>flutter使用ThemeData统一管理<ul>
<li>app全局范围 MaterialApp.theme</li>
<li>widget局部范围 Theme.data<ul>
<li>不想继承任何全局配置可直接新建一个ThemeData实例</li>
<li>想继承可使用Theme.of(context).copyWith()</li>
</ul>
</li>
<li>Theme.of(context)向上查找widget树，返回最近的Theme</li>
<li>defaultTargetPlatform 可判断当前运行的平台</li>
</ul>
</li>
</ul>
<h2 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h2><ul>
<li>原生<ul>
<li>ios使用Images.xcassets管理图片，其他资源直接拖进项目即可</li>
<li>android使用drawable+分辨率命名的文件夹管理图片，res/layout放布局，res/values放资源描述文件，assets放原始文件</li>
</ul>
</li>
<li>flutter<ul>
<li>assets可管理任意类型的资源</li>
<li>pubspec.yaml中配置指向对应目录即可<ul>
<li>可以单独指向某个文件</li>
<li>也可以指向一个目录，目录制定并不会递归，所以需显示递归指定子目录</li>
</ul>
</li>
<li>资源引用<ul>
<li>Image.asset()引用图片<ul>
<li>遵循基于像素密度的管理方式1.0x、2.0x、3.0x</li>
<li>flutter根据设备分辨率加载比例最接近的图片资源实现自动降级</li>
<li>资源目录应该将1.0x、2.0x、3.0x图片资源分开管理</li>
<li>assets/bg.jpg</li>
<li>assets/2.0x/bg.jpg</li>
<li>assets/3.0x/bg.jpg</li>
<li>pubspec.yaml中仅声明1.0x资源即可 flutter.assets: assets/bg.jpg</li>
</ul>
</li>
<li>rootBundle.loadString()加载字符串文件资源</li>
<li>rootBundle.load()加载二进制文件资源</li>
<li>fonts:[{family: name,fonts:[{asset:assets/fonts/name.ttf},{asset:assets/fonts/name-Italic.ttf,style:italic},{asset:assets/fonts/name-Bold.ttf,weight:700}]}]</li>
</ul>
</li>
</ul>
</li>
<li>flutter框架前的原生配置<ul>
<li>更换app图标<ul>
<li>ios ios/Runner/Assets.xcassets/AppIcon.appiconset</li>
<li>android android/app/src/main/res/mipmap</li>
</ul>
</li>
<li>更换app启动图<ul>
<li>ios ios/Runner/Assets.xcassets/LaunchImage.imageset</li>
<li>android android/app/src/main/res/drawable/launch_background.xml</li>
</ul>
</li>
</ul>
</li>
<li>第三方组件库<ul>
<li>pubspec.yaml<ul>
<li>类似于ios中的Podfile/android中的build.gradle/前端的package.json</li>
<li>pub<ul>
<li>dart的包管理工具，类似于ios中的cocoaPods/android中的maven/前端npm</li>
<li>dart的包实际上就是一个包含了pubspec.yaml的目录</li>
</ul>
</li>
</ul>
</li>
<li>推荐包使用区间进行版本的管理，dart/flutter的sdk运行环境使用固定版本号</li>
<li>包依赖可以直接获取pub资源，也可以使用本地路径或git地址</li>
<li>所有依赖确定并下载完毕后会生成.packages文件记录包映射信息，此文件需要忽略</li>
<li>最后pub会生成pubspec.lock文件记录包的来源和版本号，此文件需要git</li>
</ul>
</li>
</ul>
<h2 id="用户交互事件"><a href="#用户交互事件" class="headerlink" title="用户交互事件"></a>用户交互事件</h2><ul>
<li>原始的指针事件(PointerEvent)<ul>
<li>原生常见的触摸事件</li>
<li>事件会从最内层冒泡到根节点，无法取消冒泡或停止分发，只能hitTestBehavior</li>
<li>ListenerWidget可以监听子widget的原始指针事件</li>
</ul>
</li>
<li>手势识别(GestureDetector)<ul>
<li>多个原始指针事件的组合操作，是指针事件的语义化封装</li>
<li>GestureDetector可以处理各种高级触摸行为，可监听多个手势但最终只有一个生效</li>
<li>不同手势通过flutter内部的arena进行PK，最终决定是什么手势</li>
<li>父组件也需要处理子组件手势时需要RawGestureDetector和GestureFactory自定义</li>
</ul>
</li>
</ul>
<h2 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h2><ul>
<li>组件通信标准方式是通过属性传值</li>
<li>跨组件通信三种方案<ul>
<li>InheritedWidget</li>
<li>Notification</li>
<li>EventBus</li>
</ul>
</li>
<li>InheritedWidget<ul>
<li>从上到下传递</li>
<li>Theme是典型案例，父子建立观察者关系，上层属性修改后，子也会更新，默认只读</li>
</ul>
</li>
<li>Notification<ul>
<li>从下到上传递</li>
<li>NotificationListener进行监听</li>
</ul>
</li>
<li>EventBus<ul>
<li>上面两种依赖父子widget关系树</li>
<li>eventBus遵循了发布/订阅模式</li>
<li>全局作用，但容易引起冲突，组件移除要清理事件</li>
</ul>
</li>
</ul>
<h2 id="路由与导航"><a href="#路由与导航" class="headerlink" title="路由与导航"></a>路由与导航</h2><ul>
<li>Route <ul>
<li>是页面的抽象，主要负责接收参数，创建页面，响应navigator的打开和关闭</li>
</ul>
</li>
<li>Navigator<ul>
<li>维护一个路由栈管理Route，可打开/关闭/替换</li>
</ul>
</li>
<li>路由管理<ul>
<li>基本路由<ul>
<li>无需提前注册，页面切换时需要自己构造页面实例</li>
<li>Navigator.push(context,MaterialPageRouter(builder:()=&gt;{}))</li>
</ul>
</li>
<li>命名路由<ul>
<li>需要提前注册，页面切换时根据注册的标示符打开</li>
<li>Navigator.pushNamed(context,”name”)</li>
<li>Navigator.of(context).pushNamed(“name”,arguments:”args”);</li>
</ul>
</li>
</ul>
</li>
<li>其他<ul>
<li>默认路由 UnknownRoute</li>
<li>路由页面打开参数<ul>
<li>RouteSettings </li>
<li>args = ModalRoute.of(context).settings.arguments as String;</li>
</ul>
</li>
<li>路由页面返回参数<ul>
<li>push页面时要设置目标页面关闭时的监听函数以获取返回参数Navigator.pushNamed(context,”name”).then(args =&gt; print args);</li>
<li>目标页面关闭路由时要传递相关返回参数 Navigator.pop(context,”args”);</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="flutter进阶"><a href="#flutter进阶" class="headerlink" title="flutter进阶"></a>flutter进阶</h1><h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><ul>
<li>Animation<ul>
<li>flutter动画库的核心类</li>
<li>flutter的动画状态和渲染是分离的</li>
<li>fultter动画的生成器</li>
</ul>
</li>
<li>AnimationController<ul>
<li>flutter动画的控制器</li>
<li>管理Animation，可设置动画的时长、启动动画、暂停、反转等</li>
<li>controller.forward()启动动画</li>
<li>controller.repeat()重复动画</li>
<li>controller.dispose()释放资源</li>
</ul>
</li>
<li>Listener<ul>
<li>flutter动画的监听器</li>
<li>是Animation的回调函数，可监听动画的进度变化</li>
<li>监听变化后重新触发刷新实现动画</li>
<li>实践中尽量避免直接使用提高性能</li>
</ul>
</li>
<li>AnimatedWidget<ul>
<li>将Animation状态与其子widget视觉样式绑定，省去了状态监听和刷新UI</li>
<li>使用时要继承此widget并接收Animation对象作为初始化参数,build方法中读值初始化</li>
</ul>
</li>
<li>AnimatedBuilder<ul>
<li>自动监听Animation对象变化根据需要刷新UI</li>
<li>尺寸变化由builder(context,child)函数管理</li>
<li>此类实现了动画与渲染的职责分离</li>
</ul>
</li>
<li>跨页面共享的动画<ul>
<li>共享元素变换 SharedElementTransition</li>
<li>Hero(tag:”name”,child:Widget)</li>
</ul>
</li>
</ul>
<h2 id="单线程模型"><a href="#单线程模型" class="headerlink" title="单线程模型"></a>单线程模型</h2><ul>
<li>EventLoop机制<ul>
<li>MicrotaskQueue微任务队列<ul>
<li>表示短时间就会完成的异步任务</li>
<li>微任务在事件循环中的优先级最高，只要有任务就一直霸占着事件循环</li>
<li>scheduleMicroTask()</li>
<li>一般不需要此队列</li>
</ul>
</li>
<li>EventQueue事件队列<ul>
<li>优先级比较低，比较常用</li>
<li>dart为EventQueue任务提供了Future封装</li>
<li>Future提供了链式调用能力，可在异步完成后依次执行</li>
<li>then与Future函数体共用一个事件循环</li>
<li>Future执行完毕了又给引用添加了一个then方法或Future函数体为null时会把then方法体放入微任务队列，尽快执行<img src="/2019/10/01/flutter/eventLoop.png" title="事件循环">
<img src="/2019/10/01/flutter/eventLoop.gif" title="事件循环"></li>
</ul>
</li>
</ul>
</li>
<li>异步处理<ul>
<li>async/await</li>
</ul>
</li>
<li>并发编程<ul>
<li>dart是基于单线程模型，但也提供了基于Isolate的多线程机制提高多核cpu利用率</li>
<li>Isolate都有自己的EventLoop和Queue，资源隔离做的很好</li>
<li>Isolate之间不共享任何资源，只能依靠消息机制SendPort通信，避免了资源抢占需要加锁的问题</li>
<li>Isolate.spawn(fnName,args)</li>
<li>主/并发Isolate之间通信靠ReceivePort.listen()和sendPort.send()</li>
<li>为了方便使用抽象了支持并发计算的compute函数</li>
</ul>
</li>
</ul>
<h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><ul>
<li>网络请求流程<ul>
<li>构造client，设置通用请求行为（超时）</li>
<li>构造URI，设置请求header/body</li>
<li>发起请求，等待响应</li>
<li>解析响应的内容</li>
</ul>
</li>
<li>flutter实现方式<ul>
<li>dart:io里的HttpClient</li>
<li>dart原生的http请求库</li>
<li>第三方库dio(支持拦截器/请求合并等高级能力)</li>
</ul>
</li>
<li>JSON解析<ul>
<li>flutter不支持运行时反射，所以不能自动解析JSON只能手动解析</li>
<li>dart:convert库中内置的JSON解码器把JSON字符串解析成对象</li>
<li>字符串传给JSON.decode()返回一个Map再传给自定义解析类</li>
<li>如果JSON数据格式比较复杂或量比较大推荐使用compute函数将解析放到新Isolate完成</li>
</ul>
</li>
</ul>
<h2 id="持久化存储"><a href="#持久化存储" class="headerlink" title="持久化存储"></a>持久化存储</h2><ul>
<li>文件<ul>
<li>目录<ul>
<li>临时目录Temporary(ios的NSTemporaryDirectory和andriod的getCacheDir)</li>
<li>文档目录Documents(ios的NSDocumentDirectory和andriod的AppData目录)</li>
</ul>
</li>
<li>编码<ul>
<li>非常耗时需要在异步环境中编码</li>
<li>防止异常需要try/catch</li>
</ul>
</li>
</ul>
</li>
<li>SharedPreferences<ul>
<li>以原生方式为简单的键值对数据提供存储（string/int/double/bool）</li>
<li>ios中使用NSUserDefaults</li>
<li>android中使用SharedPreferences</li>
</ul>
</li>
<li>数据库sqlite<ul>
<li>设定数据库存储地址时使用join方法自动处理路径分隔符</li>
<li>创建数据库时传入的version与onCreate方法的回调中的version一致</li>
<li>在app版本升级过程中需要对数据库存储字段改动需要onUpgrade方法处理</li>
<li>数据库只会创建1次即onCreate在app卸载前只会执行1次</li>
</ul>
</li>
</ul>
<h2 id="dart层兼容原生"><a href="#dart层兼容原生" class="headerlink" title="dart层兼容原生"></a>dart层兼容原生</h2><ul>
<li>方法通道MethodChannel 解决原生能力复用问题<ul>
<li>基于方法通道(MethodChannel)机制可以把原生代码接口形式暴露给Dart</li>
<li>构造方法通道时需要指定一个唯一的字符串标识符，然后在这个通道上发起方法调用</li>
<li>const mc = MethodChannel(‘com.ceair/utils’);</li>
<li>try { await mc.invokeMethod(‘methodName’) } catch(e){}</li>
<li>方法通道调用过程中涉及的跨平台数据格式flutter会使用StandardMessageCodec进行序列化</li>
<li>方法通道是非线程安全的，所以原生和flutter都需要在主线程操作否则可能会有奇怪的bug</li>
</ul>
</li>
<li>平台视图PlatformView 解决原生视图复用问题<ul>
<li>允许flutter里嵌入原生的视图并加入flutter渲染树中实现混合视图</li>
<li>flutter通过原生视图的封装类(UIKitView和AndroidView)传入视图标识符发起请求</li>
<li>原生代码交给PlatformViewFactory实现</li>
<li>原生代码把视图标识符和工厂进行关联注册让flutter可直接找到工厂</li>
</ul>
</li>
</ul>
<h2 id="原生工程混编flutter"><a href="#原生工程混编flutter" class="headerlink" title="原生工程混编flutter"></a>原生工程混编flutter</h2><ul>
<li>混编原理 <ul>
<li>android原生提供一个FLutterView</li>
<li>ios原生提供一个FlutterViewController</li>
</ul>
</li>
<li>混编方式<ul>
<li>原生工程作为flutter工程的子工程，flutter统一管理（开发效率低）</li>
<li>flutter工程作为原生工程共用的子模块，原生工程不变的三端分离模式（推荐使用）<ul>
<li>抽离flutter工程，将不同平台的构建产物依照标准组件化形式管理</li>
<li>android项目把flutter模块打包成aar，通过build.gradle进行依赖管理</li>
<li>ios项目把flutter模块打包成pod，通过Podfle进行依赖管理</li>
</ul>
</li>
</ul>
</li>
<li>flutter模块<ul>
<li>flutter create -t module flutter_library</li>
</ul>
</li>
<li>android模块集成<ul>
<li>依赖1 flutter库和引擎 Flutter.jar</li>
<li>依赖2 flutter工程产物 isolate_snapshot_instr/vm_snapshot_data/FLutter_assets…</li>
<li>集成1 flutter build apk –[debug|release]</li>
<li>集成2 把上一步的产物flutter-debug.aar放到安卓工程app/libs目录下</li>
<li>集成3 build.gradle中添加对aar的依赖后sync一下</li>
<li>集成4 MainActivity.java中进行调用</li>
</ul>
</li>
<li>ios模块集成<ul>
<li>依赖1 flutter库和引擎 Flutter.framework</li>
<li>依赖2 flutter工程产物 App.framework</li>
<li>集成1 flutter build ios –[debug|release]</li>
<li>集成2 把上一步的产物拷贝到原生项目根目录下的FlutterEngine目录并创建FlutterEngine.podspec</li>
<li>集成3 pod lib lint</li>
<li>集成4 Podfile中集成后需要pod install</li>
<li>集成5 AppDelegate.m中进行调用</li>
</ul>
</li>
</ul>
<h2 id="混合导航栈"><a href="#混合导航栈" class="headerlink" title="混合导航栈"></a>混合导航栈</h2><ul>
<li>原生采用单容器单页面机制(一个ViewController/Activity对应一个页面)</li>
<li>Flutter采用单容器多页面机制(一个ViewController/Activity对应多个flutter页面)</li>
<li>原生跳转到flutter<ul>
<li>ios初始化flutter容器(FlutterViewController)并设置初始路由页面即可</li>
<li>android需要把View包装到Activity的contentView中并设置初始化路由</li>
</ul>
</li>
<li>flutter跳转到原生<ul>
<li>flutter打开新的原生页面(通过方法通道进行实现)</li>
<li>flutter回退到旧的原生页面(需要关闭flutter容器也是通过方法通道进行实现)</li>
</ul>
</li>
<li>性能问题<ul>
<li>由于flutter容器初始化成本比较高，每启动一个实例都要创建一个新的engine和Isolate</li>
<li>尽量避免flutter跳到原生后又跳到flutter，尽量在flutter完成业务的闭环</li>
<li>业界解决方案<ul>
<li>今日头条修改flutterEngine源码，使多engine在底层共享Isolate</li>
<li>闲鱼的共享FlutterView，通过hack方法由原生层驱动flutter层渲染内容</li>
<li>上面2种解决方案都有自己的不足，所以尽量减少此应用场景<img src="/2019/10/01/flutter/hybridNav.png" title="混合导航栈">

</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="状态管理"><a href="#状态管理" class="headerlink" title="状态管理"></a>状态管理</h2><ul>
<li><h1 id="综合应用"><a href="#综合应用" class="headerlink" title="综合应用"></a>综合应用</h1></li>
</ul>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>


    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2019 prief
    
  </p>
</footer>
    
  </div>
</div>
</body>
</html>