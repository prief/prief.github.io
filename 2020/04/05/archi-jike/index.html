<!DOCTYPE HTML>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  
  <title>archi-jike | prief | about share and go on</title>

  
  <meta name="author" content="prief">
  

  
  <meta name="description" content="简介
软件架构是有关软件整体结构与组件的抽象描述，用于指导软件系统各个方面的设计
目标
高性能
高可用
可扩展


分层
访问层
网关层
服务层
存储层
监控/限流/降级分层


目的
分而治之
各司其职


常见分层
计算机OSI7层模型
web系统的mvc/mvvm模型
基于领域模型的分层(电商">
  

  
  
  <meta name="keywords" content>
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <meta property="og:title" content="archi-jike">

  <meta property="og:site_name" content="prief">

  
  <meta property="og:image" content="/favicon.ico">
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="prief" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
</head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">prief</a>
    </h1>
    <p class="site-description">about share and go on</p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">Home</a></li>
      
        <li><a href="/tags">Tags</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    <article>

  
    
    <h3 class="article-title"><span>archi-jike</span></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2020/04/05/archi-jike/" rel="bookmark">
        <time class="entry-date published" datetime="2020-04-04T23:53:24.000Z">
          2020-04-05
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul>
<li>软件架构是有关软件整体结构与组件的抽象描述，用于指导软件系统各个方面的设计</li>
<li>目标<ul>
<li>高性能</li>
<li>高可用</li>
<li>可扩展</li>
</ul>
</li>
<li>分层<ul>
<li>访问层</li>
<li>网关层</li>
<li>服务层</li>
<li>存储层</li>
<li>监控/限流/降级<h3 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h3></li>
</ul>
</li>
<li>目的<ul>
<li>分而治之</li>
<li>各司其职</li>
</ul>
</li>
<li>常见分层<ul>
<li>计算机OSI7层模型</li>
<li>web系统的mvc/mvvm模型</li>
<li>基于领域模型的分层(电商系统…)</li>
</ul>
</li>
<li>演进<ul>
<li>servletJSP时代<ul>
<li>servlet+tomcat完成web接入</li>
<li>javaBean+JDBC完成数据层接入</li>
<li>JSP完成页面展示</li>
</ul>
</li>
<li>SSH<ul>
<li>strutsMVC完成web接入JSP完成表示层</li>
<li>spring完成业务逻辑/会话管理</li>
<li>hibernate完成数据存储接入和持久化</li>
</ul>
</li>
<li>SSM<ul>
<li>springMVC更适用前后端分离</li>
<li>spring支持注解/配置声明式事务处理</li>
<li>mybatis配置缓存/解耦数据库对象和java对象</li>
</ul>
</li>
<li>SpringBoot<ul>
<li>整合了spring所有框架，提供allInOne服务</li>
<li>提供简单的配置和注解的接入方式</li>
</ul>
</li>
<li>分布式分层</li>
</ul>
</li>
<li>亿级流量平台分层架构<ul>
<li>功能<ul>
<li>水平扩展</li>
<li>负载均衡</li>
<li>高可用</li>
<li>数据一致性</li>
</ul>
</li>
<li>分层(需要每一层都能分布式)<ul>
<li>访问层，用于web接入/反向代理/负载均衡</li>
<li>网关层，用于业务api</li>
<li>服务层，具备服务治理/调度/异步通信等</li>
<li>存储层(存储接入层/存储层)，用于提供透明的存储结构的访问代理和数据落地能力</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="访问层"><a href="#访问层" class="headerlink" title="访问层"></a>访问层</h3><ul>
<li>lvs<ul>
<li>采用ip负载均衡技术和基于内容请求分发技术做的负载均衡</li>
<li>概念<ul>
<li>CIP clientIP</li>
<li>DIP directorIP</li>
<li>RIP realServerIP</li>
</ul>
</li>
<li>模式<ul>
<li>NAT<ul>
<li>networkAddressTranslation网络地址转换</li>
<li>CIP-&gt;DIP-&gt;RIP-&gt;DIP-&gt;CIP(lvs两次SNAT/DNAT)</li>
<li>进出流量都走lvs,部署和配置比较简单，但lvs始终要维护两端的socket连接,可能会成为瓶颈</li>
</ul>
</li>
<li>DR<ul>
<li>directRouting直接路由</li>
<li>CIP-&gt;DIP-&gt;RIP-&gt;CIP(要修改DIP-&gt;RIP时的mac地址)</li>
<li>响应流量不走lvs,减少lvs始终维护两端socket的性能开销,但要求DIP和RIP要在同一机房</li>
<li>通常使用此模式，在同一机房也会有很高的性能</li>
</ul>
</li>
<li>TUN<ul>
<li>tunneling隧道</li>
<li>CIP-&gt;DIP-&gt;RIP-&gt;CIP(在DIP发送到RIP时做了二次封装,RIP拿到包后要二次解析)</li>
<li>响应流量不走lvs,同时DIP和RIP也不一定要在同一机房,但要求RS必须支持隧道模式即要二次解析IP包</li>
</ul>
</li>
</ul>
</li>
<li>调度策略<ul>
<li>轮询/权重轮询</li>
<li>最少连接/权重最少连接</li>
<li>ip_hash/ip_hash_group/url_hash/url_hash_group…</li>
</ul>
</li>
<li>优势<ul>
<li>ip层的负载均衡,没有应用层回调的消耗，性能高</li>
<li>通过DR/TUN模式使响应不走lvs</li>
<li>支持后端心跳检测,自动故障转移恢复</li>
<li>配合主从keepAlive和VIP实现自身高可用</li>
</ul>
</li>
</ul>
</li>
<li>nginx<ul>
<li>功能<ul>
<li>请求解析(http/https)</li>
<li>负载均衡(应用层)</li>
<li>缓存调度</li>
<li>授权认证</li>
<li>接入处理(过滤非法请求)</li>
<li>业务逻辑</li>
<li>响应处理</li>
<li>压缩技术</li>
</ul>
</li>
<li>职责分类<ul>
<li>接入层nginx</li>
<li>应用层nginx(缓存调度/业务逻辑/限流降级)</li>
</ul>
</li>
<li>高性能原因<ul>
<li>master-worker进程模型<ul>
<li>master进程系统调用<ul>
<li>socket()</li>
<li>bind()</li>
<li>listen()</li>
<li>fork()</li>
</ul>
</li>
<li>worker进程系统调用<ul>
<li>accept()</li>
<li>recv()</li>
<li>send()</li>
<li>close()</li>
</ul>
</li>
</ul>
</li>
<li>异步模型<ul>
<li>select(缺点:只能并发1024个请求/低效的遍历性能消耗)</li>
<li>epoll(linux2.6后实现的事件机制,解决了上面2个问题)</li>
</ul>
</li>
<li>流式处理请求workflow,有主子请求</li>
<li>协程机制解决worker上不能有阻塞操作<ul>
<li>协程<ul>
<li>栈/局部变量在用户空间模拟，切换开销小</li>
<li>协程间是协作关系</li>
<li>临界区不需要加锁</li>
<li>遇到阻塞主动放弃切换</li>
</ul>
</li>
<li>线程<ul>
<li>栈/局部变量是内核空间的映射，切换开销大</li>
<li>多线程并发运行是竞争cpu关系</li>
<li>临界区需要同步加锁</li>
<li>遇到阻塞进入等待cpu切换</li>
</ul>
</li>
</ul>
</li>
<li>nginx lua</li>
</ul>
</li>
<li>具体应用<ul>
<li>负载均衡<ul>
<li>upstream</li>
<li>proxy_pass</li>
</ul>
</li>
<li>代理缓存(先要有后端的代理才能使用代理缓存)<ul>
<li>proxy_cache_path PATH levels=1:2 keys_zone=NAME:100m inactive=7d max_size=100g;<ul>
<li>把缓存文件放在PATH中</li>
<li>levels=1:2 缓存文件目录层级和目录名称长度</li>
<li>keys_zone 指定了一个内存空间，并设置大小来缓存key与缓存文件目录的映射关系</li>
<li>inactive=7d 缓存文件7天后失效淘汰</li>
<li>max_size=100g 缓存文件总大小超过100g后释放淘汰</li>
</ul>
</li>
<li>使用<ul>
<li>proxy_cache NAME; # 使用缓存空间</li>
<li>proxy_cache_valid 200 206 302 304 10d; # 后端返回以下响应码时缓存多久</li>
<li>proxy_cache_key $uri; # 一般使用$uri作为缓存的key;</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="网关层"><a href="#网关层" class="headerlink" title="网关层"></a>网关层</h3><ul>
<li>分布式会话管理<ul>
<li>会话机制<ul>
<li>session<ul>
<li>通过判断SID里是否包含用户信息判定用户是否登陆</li>
<li>依赖后端的session容器和前端的cookie，无法解决cookie跨域和禁用的问题</li>
</ul>
</li>
<li>cookie<ul>
<li>后端验证用户信息后将凭证做数字签名，加密后写入cookie的ticket，验证时取出ticket解密判断</li>
<li>不依赖后端session容器但也没有解决cookie跨域和禁用的问题</li>
</ul>
</li>
<li>token<ul>
<li>后端验证用户信息后将凭证做数字签名，加密后写入token返回前端，前端请求时参数或header中携带token</li>
<li>不依赖cookie，但需要请求时携带token</li>
</ul>
</li>
</ul>
</li>
<li>安全问题<ul>
<li>cookie被劫持，xss/csrf安全攻击</li>
<li>token凭证被劫持，伪造</li>
</ul>
</li>
<li>解决方式<ul>
<li>https</li>
<li>风控系统主动失效及过期机制</li>
</ul>
</li>
<li>分布式会话管理<ul>
<li>登陆凭证放入集中的会话管理redis/memcached</li>
<li>对应session的处理机制要重写</li>
</ul>
</li>
</ul>
</li>
<li>接入层控制<ul>
<li>控制内容<ul>
<li>身份验证<ul>
<li>通过会话管理获取用户登陆凭证</li>
<li>通过用户凭证获取用户信息</li>
<li>验证对应的url/资源是否可以被用户访问</li>
</ul>
</li>
<li>流量控制<ul>
<li>对应url流量是否可以被承载否则限流(filter的pre/post进行计数即可实现)</li>
<li>对应服务分级的流量是否被承载</li>
<li>对应整个系统的总流量是否被承载</li>
</ul>
</li>
<li>路由服务<ul>
<li>根据url规则找到对应的服务</li>
<li>判断服务的状态，做服务路由调用</li>
</ul>
</li>
<li>记录调试或统计信息</li>
</ul>
</li>
<li>通过接入层框架的通用的filter功能实现<ul>
<li>javaServletFilter</li>
<li>springMVCHandlerInterceptor</li>
<li>zuulFilter</li>
</ul>
</li>
</ul>
</li>
<li>服务调用及聚合<ul>
<li>如果需要多个后端服务调用则需要在网关层这里做聚合</li>
<li>分类<ul>
<li>重接入<ul>
<li>springMVC+dubbo</li>
<li>优点：可灵活的在controller层处理业务逻辑，聚合服务</li>
<li>缺点：服务的单一性不够，后端服务不便管理</li>
</ul>
</li>
<li>轻接入<ul>
<li>zuul</li>
<li>优点：服务单一，接入控制可以页面配置</li>
<li>缺点：聚合能力不够，需要后端提供</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="核心服务层之服务通信"><a href="#核心服务层之服务通信" class="headerlink" title="核心服务层之服务通信"></a>核心服务层之服务通信</h3><ul>
<li>微服务<ul>
<li>传统服务缺点<ul>
<li>所有服务耦合在一起</li>
<li>隔离型弱，互相影响</li>
<li>部署臃肿</li>
<li>开发维护困难</li>
</ul>
</li>
<li>微服务<ul>
<li>特性<ul>
<li>高内聚,低耦合,专注自己的核心业务</li>
<li>隔离型强,不会相互影响(进程上)</li>
<li>轻量的通信机制</li>
<li>独立开发,单独部署</li>
</ul>
</li>
<li>需要解决的问题<ul>
<li>服务治理(服务注册和发现,负载均衡和智能容错,服务监控和健康管理,限流降级熔断)</li>
<li>数据一致性</li>
<li>调用性能</li>
<li>研发流程调试,部署,测试</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>dubbo服务治理<ul>
<li>来解决微服务服务治理的轻量级开源javaRPC框架</li>
<li>核心能力<ul>
<li>面向接口的远程方法调用</li>
<li>服务自动注册和发现</li>
<li>负载均衡和智能容错</li>
</ul>
</li>
</ul>
</li>
<li>异步消息服务<ul>
<li>分类<ul>
<li>JMS(apacheActiveMQ)</li>
<li>Kafka(流式处理)</li>
<li>RocketMQ(alibaba基于Kafka开发的分布式一致性服务)</li>
</ul>
</li>
<li>JMS<ul>
<li>javaMessageService</li>
<li>特点<ul>
<li>点对点(每个消息都被发送到特定的队列,接收者从队列中顺序消费,队列保留着消息直到被消费或超时)</li>
<li>发布订阅(客户端将消息发到主题,消息队列存放主题,订阅者消费主题)</li>
</ul>
</li>
<li>activeMQ缺点<ul>
<li>以消息为单位,为保证消息稳定性需要落盘,但可能落盘时不连续,磁盘寻值有性能问题</li>
<li>消费时是推模式,对consumer的线程压力非常大</li>
</ul>
</li>
</ul>
</li>
<li>Kafka<ul>
<li>默认支持点对点，但不常用，常用发布订阅</li>
<li>客户端将消息发到主题,消息队列存放主题,订阅者消费主题,消息持久化到队尾,消费通过客户端指针,吞吐量高</li>
<li>比activeMQ优点<ul>
<li>引入broker概念把相同topic的消息连续的落到同一个文件,保证磁盘IO性能</li>
<li>消费时是拉模式,根据consumer性能决定消费速度</li>
<li>引入了nameServer类似zookeeper的组件和队列/失败重试队列来保证消息稳定可靠</li>
</ul>
</li>
</ul>
</li>
<li>RocketMQ<ul>
<li>结合了Kafka和ActiveMQ的优点,把Kafka很多的api封装成类似ActiveMQ简单易用</li>
<li>消息队列维护高可用,并支持事务回溯机制(增加了prepare队列)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="核心服务层之调度-池化"><a href="#核心服务层之调度-池化" class="headerlink" title="核心服务层之调度/池化"></a>核心服务层之调度/池化</h3><ul>
<li>任务调度<ul>
<li>应用场景<ul>
<li>业务跑批轮询等待处理</li>
<li>失败的异常重试</li>
<li>定时任务处理</li>
</ul>
</li>
<li>单机实现方式<ul>
<li>Timer定时器机制<ul>
<li>java自带，比较简单</li>
<li>所有任务都在同一个线程中串行执行，同一时间只能执行一个任务，不适合多线程并发多任务</li>
</ul>
</li>
<li>ScheduledExecutor<ul>
<li>内置了线程池，解决Timer单线程的问题</li>
<li>任务数不能超过线程池数，否则也会相互影响</li>
</ul>
</li>
<li>Quartz<ul>
<li>包含任务JobDetail类和调度Trigger类</li>
<li>定时检测到任务后Job会在线程池中申请线程执行</li>
</ul>
</li>
</ul>
</li>
<li>分布式调度方式及实现<ul>
<li>Quartz分布式版本<ul>
<li>部署机器的时间一致</li>
<li>部署的代码一致</li>
<li>需要中间层同步竞争锁(数据库)</li>
</ul>
</li>
<li>Elasticsearch-Job分片分布式<ul>
<li>借鉴了竞争锁的机制,不过使用zookeeper实现</li>
<li>自己实现了任务是否分片，解决大job问题</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>池化技术<ul>
<li>通过复用减少系统消耗，提升系统性能</li>
<li>分类<ul>
<li>对象池<ul>
<li>利用复用对象减少创建对象/垃圾回收的开销</li>
<li>例如线程池通过复用线程提升性能</li>
</ul>
</li>
<li>连接池<ul>
<li>数据库连接池/redis连接池/http连接池</li>
<li>通过复用tcp连接减少创建和释放连接的时间</li>
</ul>
</li>
</ul>
</li>
<li>实战<ul>
<li>java线程池<ul>
<li>核心/最小线程数大小(任务进来后首选核心线程)</li>
<li>等待队列长度(核心线程都busy时新进的任务进等待队列)</li>
<li>最大线程数大小(等待队列也满了又有新进的任务则开启新线程,等待队列出对执行)</li>
<li>拒绝策略(达到最大线程后又有新进的任务则会按拒绝策略执行,分为被动等待或直接报错)</li>
<li>idle等待时间(弹性线程空闲等待时间后会回收)</li>
</ul>
</li>
<li>连接池(数据库/redis/httpClient)<ul>
<li>连接状态<ul>
<li>init</li>
<li>connect</li>
<li>busy</li>
<li>close</li>
</ul>
</li>
<li>核心连接数</li>
<li>最大连接数</li>
<li>连接等待时间(tcp/ip建连时间)</li>
<li>数据读取时间</li>
<li>idle等待时间(弹性连接空闲等待时间后会释放)</li>
<li>validate<ul>
<li>获取连接时</li>
<li>使用连接时(常用)</li>
<li>释放连接时</li>
</ul>
</li>
</ul>
</li>
<li>tomcat线程/连接池<ul>
<li>客户端连接池</li>
<li>io线程池</li>
<li>worker线程池</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="核心服务层之缓存-隔离-队列"><a href="#核心服务层之缓存-隔离-队列" class="headerlink" title="核心服务层之缓存/隔离/队列"></a>核心服务层之缓存/隔离/队列</h3><ul>
<li>缓存<ul>
<li>设计原则<ul>
<li>存储设备读写速度最快(cpu/内存)</li>
<li>数据离应用最近(业务服务器/局域网/机房)</li>
<li>数据离用户最近(app/CDN/nginx缓存/api网关/核心业务redis)</li>
</ul>
</li>
<li>分类<ul>
<li>CDN缓存</li>
<li>反向代理缓存 nginxProxyCache</li>
<li>分布式缓存 redis</li>
<li>本地应用缓存 JVM Guava</li>
</ul>
</li>
</ul>
</li>
<li>隔离<ul>
<li>硬件隔离(虚拟机)</li>
<li>操作系统隔离(容器虚拟化)</li>
<li>进程隔离(系统拆分)</li>
<li>线程隔离(线程池独立)</li>
<li>读写隔离</li>
<li>动静隔离</li>
<li>冷热隔离(热点账户/热点数据)</li>
</ul>
</li>
<li>队列<ul>
<li>先进先出的线性表</li>
<li>用途<ul>
<li>异步处理</li>
<li>系统解耦</li>
<li>流量削峰<ul>
<li>排队有时候会比并发效率更高</li>
<li>排队可以控制并发流量开关/大小</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="数据存储层"><a href="#数据存储层" class="headerlink" title="数据存储层"></a>数据存储层</h3><ul>
<li>数据存储<ul>
<li>分类<ul>
<li>传统IT<ul>
<li>excel提供简单的关系存储</li>
<li>磁盘提供文件存储</li>
<li>sql数据库提供关系型存储</li>
</ul>
</li>
<li>互联网行业<ul>
<li>分布式存储需要无限可扩展的网络文件系统</li>
<li>关系型数据库需要提供事务一致性的保证</li>
<li>非关系型数据库需要提供更高性能的简化存储</li>
<li>磁盘和内存需要性能和稳定中间权衡</li>
</ul>
</li>
</ul>
</li>
<li>数据结构<ul>
<li>结构化数据(表,有完备的模式)</li>
<li>非结构化数据(音视频文件等)</li>
<li>半结构化数据(xml表示简历格式)</li>
</ul>
</li>
<li>数据库结构<ul>
<li>关系型数据库</li>
<li>非关系型数据库</li>
</ul>
</li>
<li>选型<ul>
<li>非结构化数据选择网络文件系统/网络磁盘</li>
<li>结构化数据根据是否需要SQL和关系事务的支持<ul>
<li>关系型数据库</li>
<li>非关系型数据库(磁盘非关系/内存非关系)</li>
</ul>
</li>
<li>半结构化数据<ul>
<li>首先使用XML或JSON等可扩展的结构化数据进行描述</li>
<li>然后根据是否落地选择非关系型数据库</li>
</ul>
</li>
</ul>
</li>
<li>常用<ul>
<li>NAS <ul>
<li>network attached storage网络附属存储</li>
<li>网络文件系统,基底层设备,提供文件磁盘</li>
<li>有cpu/内存/网络接入端口/磁盘插槽</li>
</ul>
</li>
<li>OSS<ul>
<li>object storage service</li>
<li>基于bucket管理网络文件</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>关系型与非关系型<ul>
<li>关系型数据库mysql<ul>
<li>关系型存储格式,如表</li>
<li>非主键字段依赖索引提高查询速度,查询需要快照和锁机制</li>
<li>事务保障效率高<ul>
<li>set autocommit=0;</li>
<li>begin;</li>
<li>SQL;</li>
<li>commit;</li>
</ul>
</li>
<li>可以使用join进行复杂查询</li>
</ul>
</li>
<li>非关系型数据库mongoDB<ul>
<li>kv存储格式</li>
<li>通常使用k查询,对应关系型的主键,比索引更快,大多使用单线程存储,无需锁</li>
<li>没有事务的概念</li>
<li>对复杂查询的能力较弱但场景也比较少</li>
<li>mongoDB<ul>
<li>是非关系型数据库中功能最丰富,最像关系型数据库的非关系型数据库</li>
<li>数据结构非常松散,类似JSON的BSON格式</li>
<li>db.NAME.find().pretty()/insert()/update()/remove()/createIndex()/sort()/limit()/skip()</li>
</ul>
</li>
<li>redis<ul>
<li>用作数据库/高速缓存/消息队列代理</li>
<li>支持字符串/哈希表/列表/集合/有序集合/位图等数据类型</li>
<li>内置复制/LRU淘汰回收/事务及不同级别的磁盘持久化功能</li>
<li>通过Redis Sentinel提供高可用</li>
<li>通过Redis Cluster提供自动分区</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>代理访问层<ul>
<li>代理对象分类<ul>
<li>nginx反向代理</li>
<li>mycat代理mysql</li>
<li>twemproxy代理redis/redis4自带的redisCluster也可支持代理</li>
</ul>
</li>
<li>代理作用<ul>
<li>集中收口</li>
<li>负载均衡</li>
<li>故障转移</li>
<li>路由策略</li>
<li>缓存策略</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="监控-限流-降级"><a href="#监控-限流-降级" class="headerlink" title="监控/限流/降级"></a>监控/限流/降级</h3><ul>
<li>监控<ul>
<li>指标<ul>
<li>硬件(zabbix监控)<ul>
<li>CpuIdleTime</li>
<li>FreeMemory</li>
<li>IOWait</li>
<li>NetworkFree</li>
</ul>
</li>
<li>软件(cat heartbeat监控)<ul>
<li>CpuLoadAverage</li>
<li>ParNewCount</li>
<li>ParNewTime</li>
<li>OldGCCount</li>
<li>OldGCTime</li>
</ul>
</li>
<li>接口(cat transaction监控)<ul>
<li>url/dubbo failure times</li>
<li>9X线(95%Line/99.9%Line/99.99%Line)</li>
</ul>
</li>
<li>异常(cat exception监控)<ul>
<li>ExceptionTimesAndContent</li>
</ul>
</li>
<li>大盘(cat 大盘监控)<ul>
<li>基线成功率</li>
<li>基线失败率</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>限流<ul>
<li>原因<ul>
<li>流量远比能力大</li>
<li>永远不知道对方会怎么样</li>
<li>永远不知道自己会怎么样</li>
</ul>
</li>
<li>维度<ul>
<li>url(外部接口)</li>
<li>dubbo接口(内部接口)</li>
<li>sql操作数</li>
</ul>
</li>
<li>内容<ul>
<li>TPS/QPS</li>
<li>限制并发数</li>
<li>限制总数</li>
</ul>
</li>
<li>算法原理<ul>
<li>限制并发数(服务内以接口为单位设置并发总数锁,超过并发总数返回异常,达到限制并发的功能)</li>
<li>令牌桶算法(以桶模拟对应的令牌池,定时器会根据TPS重置桶,达到限制TPS的功能)</li>
<li>漏桶算法(以固定的速度流出流量,可以应对一定程度的突发流量,达到削峰填谷的功能)</li>
</ul>
</li>
<li>实战<ul>
<li>Guava的ratelimiter实现令牌桶</li>
</ul>
</li>
</ul>
</li>
<li>降级<ul>
<li>保护系统正常运行,也要保证用户体验</li>
<li>策略<ul>
<li>关闭接口并设置默认返回</li>
<li>降级逻辑</li>
<li>主动降级</li>
</ul>
</li>
</ul>
</li>
</ul>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>


    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2020 prief
    
  </p>
</footer>
    
  </div>
</div>
</body>
</html>