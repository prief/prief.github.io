<!DOCTYPE HTML>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  
  <title>fe | prief | about share and go on</title>

  
  <meta name="author" content="prief">
  

  
  <meta name="description" content="fejs
原始类型
Boolean
String
Number
Undefined
Null
Symbol


类型判断
typeof
undefined
boolean
string
number
function
object


instanceof
数组
自定义类




类型传递
值类型按">
  

  
  
  <meta name="keywords" content>
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <meta property="og:title" content="fe">

  <meta property="og:site_name" content="prief">

  
  <meta property="og:image" content="/favicon.ico">
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="prief" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
</head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">prief</a>
    </h1>
    <p class="site-description">about share and go on</p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">Home</a></li>
      
        <li><a href="/tags">Tags</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    <article>

  
    
    <h3 class="article-title"><span>fe</span></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2020/02/28/fe/" rel="bookmark">
        <time class="entry-date published" datetime="2020-02-28T05:18:52.000Z">
          2020-02-28
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h3 id="fe"><a href="#fe" class="headerlink" title="fe"></a>fe</h3><h4 id="js"><a href="#js" class="headerlink" title="js"></a>js</h4><ul>
<li>原始类型<ul>
<li>Boolean</li>
<li>String</li>
<li>Number</li>
<li>Undefined</li>
<li>Null</li>
<li>Symbol</li>
</ul>
</li>
<li>类型判断<ul>
<li>typeof<ul>
<li>undefined</li>
<li>boolean</li>
<li>string</li>
<li>number</li>
<li>function</li>
<li>object</li>
</ul>
</li>
<li>instanceof<ul>
<li>数组</li>
<li>自定义类</li>
</ul>
</li>
</ul>
</li>
<li>类型传递<ul>
<li>值类型按值传递<ul>
<li>Boolean</li>
<li>String</li>
<li>Number</li>
<li>Undefined</li>
<li>Null</li>
</ul>
</li>
<li>引用类型按共享传递<ul>
<li>Object</li>
<li>Function</li>
<li>Array</li>
<li>Date</li>
</ul>
</li>
</ul>
</li>
<li>原型和原型链<ul>
<li>引用类型都有对象的特性，可自由扩展属性</li>
<li>引用类型都有一个<strong>proto</strong>属性指向原型对象</li>
<li>所有的函数都有prototype属性指向原型对象</li>
<li>引用类型的<strong>proto</strong>指向它构造函数的prototype</li>
<li>当试图得到一个对象的某个属性时如果本身没有则去<strong>proto</strong>上寻找形成原型链</li>
</ul>
</li>
<li>作用域和作用域链<ul>
<li>全局作用域</li>
<li>函数作用域</li>
<li>ES6后增加块级作用域</li>
<li>当前作用域中没有的变量称为自由变量，自由变量向父级作用域寻值，形成作用域链</li>
</ul>
</li>
</ul>
<h4 id="css"><a href="#css" class="headerlink" title="css"></a>css</h4><ul>
<li>选择器权重和优先级<ul>
<li>!important</li>
<li>内联样式</li>
<li>ID选择器</li>
<li>类、伪类、属性选择器</li>
<li>元素选择器</li>
</ul>
</li>
<li>盒子模型<ul>
<li>margin</li>
<li>border</li>
<li>padding</li>
<li>content</li>
<li>分类<ul>
<li>border-box</li>
<li>content-box</li>
</ul>
</li>
</ul>
</li>
<li>position<ul>
<li>static</li>
<li>relative</li>
<li>absolute</li>
<li>fixed</li>
</ul>
</li>
<li>flex<ul>
<li>container<ul>
<li>flex-direction</li>
<li>justify-content</li>
<li>align-items</li>
</ul>
</li>
<li>item</li>
</ul>
</li>
<li>重绘和回流<ul>
<li>重绘<ul>
<li>简单的进行样式的变化，如颜色、背景等，不影响几何信息</li>
<li>开销小</li>
</ul>
</li>
<li>回流（重排）<ul>
<li>DOM中的尺寸大小几何信息，位置信息发生变化导致重新渲染</li>
<li>开销大</li>
<li>getComputedStyle/currentStyle获取即时属性值的操作也会触发回流</li>
</ul>
</li>
<li>避免<ul>
<li>缓存DOM对象</li>
<li>避免逐条修改样式，使用类名合并</li>
<li>将DOM离线后操作不会有性能问题，操作完毕后上线display:none/block;</li>
<li>现代浏览器会维护一个flush队列，在不得已的时候会执行队列</li>
</ul>
</li>
</ul>
</li>
<li>1px线实现方式<ul>
<li>渐变</li>
<li>缩放</li>
<li>图片(base64/svg)</li>
</ul>
</li>
<li>图片保真<ul>
<li>统一使用最高倍图，但浪费带宽</li>
<li>srcset属性</li>
</ul>
</li>
<li>字体适配<ul>
<li>默认最小限制<ul>
<li>PC上是12px</li>
<li>手机上是8px</li>
</ul>
</li>
<li>不建议使用奇数数值，容易在低端手机上出现锯齿</li>
<li>尽量使用默认系统字体</li>
<li>font-family取值<ul>
<li>具体字体名称</li>
<li>通用类别<ul>
<li>serif 衬线字体族</li>
<li>sans-serif 非衬线字体族</li>
<li>monospace 等宽字体</li>
<li>cursive 草书字体</li>
<li>fantasy 艺术字体</li>
<li>systme-ui 系统默认字体</li>
<li>emoji 兼容表情符号</li>
<li>math 数学表达式</li>
<li>fangsong 仿宋</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><ul>
<li>程序<ul>
<li>数据</li>
<li>算法</li>
</ul>
</li>
<li>数据结构<ul>
<li>简单数据结构<ul>
<li>有序数据结构：栈、队列、链表，省空间，存储空间小</li>
<li>无序数据结构：字典、集合、散列集，省时间，读取时间快</li>
</ul>
</li>
<li>高级数据结构<ul>
<li>树、堆</li>
<li>图</li>
</ul>
</li>
</ul>
</li>
<li>常见算法<ul>
<li>递归</li>
<li>排序</li>
<li>枚举</li>
</ul>
</li>
<li>算法复杂度<ul>
<li>时间复杂度（好估算、好评估）<ul>
<li>常数阶O(1) #每行一次性的语句就是常数阶</li>
<li>线性阶O(n)</li>
<li>平方阶O(n^2)</li>
<li>立方阶O(n^3)</li>
<li>k次方阶O(n^k)</li>
<li>指数阶O(2^n)</li>
<li>对数阶O(logN)</li>
<li>线性对数阶O(nlogN)</li>
</ul>
</li>
<li>空间复杂度</li>
<li>分析技巧<ul>
<li>几重循环，一般就是1层循环就是O(n)，两重循环就是O(n^2)</li>
<li>如果有二分，则为O(logN)</li>
<li>每行一次性的语句则为1</li>
<li>所有行的复杂度相加后除去常数即得复杂度</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="浏览器相关"><a href="#浏览器相关" class="headerlink" title="浏览器相关"></a>浏览器相关</h4><ul>
<li>加载过程<ul>
<li>DNS解析</li>
<li>TCP连接</li>
<li>HTTP请求</li>
<li>HTTP响应</li>
<li>客户端渲染<ul>
<li>根据html生成DOM</li>
<li>根据css生成CSSOM</li>
<li>DOM和CSSOM整合生成RenderTree</li>
<li>布局合成 、绘制渲染</li>
<li>遇到script会阻塞渲染，因为js执行和浏览器渲染共用一个线程</li>
</ul>
</li>
</ul>
</li>
<li>性能优化<ul>
<li>减少页面体积，提升网络加载<ul>
<li>静态资源压缩、合并</li>
<li>静态资源缓存</li>
<li>使用CDN</li>
</ul>
</li>
<li>优化页面渲染<ul>
<li>css放前、js放后</li>
<li>懒加载</li>
<li>减少DOM操作</li>
<li>事件节流</li>
<li>SSR</li>
</ul>
</li>
</ul>
</li>
<li>web安全<ul>
<li>SQL注入</li>
<li>XSS</li>
<li>CSRF</li>
</ul>
</li>
</ul>
<h4 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h4><ul>
<li><p>DNS解析</p>
<ul>
<li>浏览器DNS缓存</li>
<li>DNS prefetch</li>
</ul>
</li>
<li><p>TCP连接</p>
<ul>
<li>长连接</li>
<li>预连接</li>
<li>接入SPDY协议</li>
</ul>
</li>
<li><p>HTTP请求</p>
<ul>
<li>减少次数（loader中的exclude、三方库DllPlugin/DllReferencePlugin）</li>
<li>减少体积（webpack-bundle-analyzer、代码压缩混淆、gzip、tree-shaking、按需加载）</li>
<li>CDN<ul>
<li>content delivery network</li>
<li>2大功能<ul>
<li>缓存</li>
<li>回源</li>
</ul>
</li>
<li>CDN域名和业务服务域名一定要分开，避免cookie无用传输</li>
</ul>
</li>
<li>Gzip<ul>
<li>gzip的内核就是Deflate</li>
<li>通常能减小70%的体积</li>
<li>原理就是把内容中重复的字符串临时替换，使整个文件变小，所以重复率越高，收益越好</li>
<li>nginx等代理文件中可以配置index.js/index.js.gz 以减少cpu临时压缩的消耗</li>
</ul>
</li>
<li>图片优化<ul>
<li>JPEG/JPG 有损压缩、体积小、色彩丰富，常用轮播图，不支持透明</li>
<li>PNG 无损压缩、质量高、支持透明，常用单色小图logo，体积大<ul>
<li>PNG-8  二进制的位数8，最多支持256种颜色</li>
<li>PNG-24 二进制的位数24，最多支持1600万种颜色</li>
</ul>
</li>
<li>SVG<ul>
<li>文本文件</li>
<li>体积小、不失真、可压缩</li>
<li>对图像的处理不是基于像素，而是基于对图像的描述</li>
<li>可以放到HTML的DOM中，也可以单独保存.svg文件</li>
<li>渲染成本比较高，性能要求比较高</li>
</ul>
</li>
<li>Base64<ul>
<li>文本文件</li>
<li>依赖编码，小图标解决方案</li>
<li>编码后，体积会增大1/3</li>
</ul>
</li>
<li>WebP<ul>
<li>年轻的全能选手</li>
<li>支持有损和无损压缩</li>
<li>支持透明、支持动态图、支持丰富的色彩、体积比较小</li>
<li>兼容性比较差，编码时比jpg需要更多计算资源</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>渲染</p>
<ul>
<li>SSR<ul>
<li>SEO</li>
<li>首屏白屏</li>
</ul>
</li>
<li>CSS</li>
<li>JSji</li>
<li>DOM</li>
<li>懒加载</li>
<li>事件节流和防抖</li>
<li>回流和重绘</li>
</ul>
</li>
<li><p>浏览器引擎</p>
<ul>
<li>渲染引擎（内核）<ul>
<li>功能部件<ul>
<li>html解释器，将html输出DOM</li>
<li>css解释器，将css输出CSSOM</li>
<li>布局绘制，合成renderTree</li>
<li>网络</li>
<li>存储</li>
<li>图形、图片解码器</li>
<li>音视频</li>
</ul>
</li>
<li>常见分类<ul>
<li>Trident（IE）</li>
<li>Gecko（Firefox）</li>
<li>Blink（Chrome、Opera）是webkit的一个分支</li>
<li>Webkit（Safari）</li>
</ul>
</li>
<li>优化<ul>
<li>css<ul>
<li>css解释器对每条规则都按从右到左的顺序去匹配，因此要减少选择器嵌套</li>
<li>避免使用通配符，只对需要用到的元素进行选择</li>
<li>css是阻塞渲染的资源，需要尽早加载，尽早渲染，把css往前放</li>
</ul>
</li>
<li>js<ul>
<li>默认的js也会阻塞DOM和CSSOM，因为可能会操作DOM</li>
<li>async模式加载js不会阻塞浏览器，异步加载js，加载完毕后立即执行</li>
<li>defer模式加载js不会阻塞浏览器，异步加载js，加载完毕后延迟到DOMContentLoaded后执行</li>
</ul>
</li>
<li>DOM<ul>
<li>对DOM的修改引发了DOM几何尺寸的变化，浏览器都要重新计算几何属性，再将结果绘制出来，即回流重排</li>
<li>对DOM的修改没有引发几何尺寸的变化，不需要重新计算几何属性，跳过重排直接执行重绘</li>
<li>减少DOM的访问和操作</li>
<li>必要的DOM操作可以使用DocumentFragment，不会有性能问题</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>js引擎<ul>
<li>异步队列<ul>
<li>micro-task<ul>
<li>process.nextTick</li>
<li>promise</li>
<li>MutationObserver</li>
</ul>
</li>
<li>macro-task<ul>
<li>setTimeout</li>
<li>setInteral</li>
<li>setImmediate</li>
<li>IO操作</li>
</ul>
</li>
</ul>
</li>
<li>执行过程<ul>
<li>将一个macro-task执行并出队</li>
<li>将一对micro-task执行并出对</li>
<li>执行渲染，更新界面</li>
<li>处理worker相关的任务</li>
<li>循环，当我们需要在异步任务中实现DOM修改时，把它包装成micro-task是明智的选择</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>浏览器缓存</p>
<ul>
<li><p>MemoryCache</p>
<ul>
<li>本着节约内存的原则，一般较小的资源有几率入内存</li>
</ul>
</li>
<li><p>ServiceWorkerCache 离线缓存</p>
<ul>
<li>脱离主线程之外的独立线程</li>
<li>不能操作DOM，只能做些js的计算，数据的请求</li>
<li>serviceWorker生命周期<ul>
<li>install</li>
<li>active</li>
<li>working</li>
</ul>
</li>
</ul>
</li>
<li><p>HTTPCache</p>
<ul>
<li>强缓存（200）<ul>
<li>expires（http1.0,依赖本地时间）</li>
<li>cache-control(http1.1,完全替代expires，优先级高)<ul>
<li>max-age=31536000(有效时间长度，单位秒)</li>
<li>s-maxage优先级高于max-age，只在代理服务器上有效</li>
<li>public可以被客户端和代理服务器缓存，private只能被客户端缓存，默认private</li>
<li>no-cache 忽略所有客户端缓存，与服务器协商缓存</li>
<li>no-store 忽略所有缓存，包括协商缓存，直接请求资源</li>
</ul>
</li>
</ul>
</li>
<li>协商缓存（304）<ul>
<li>Last-Modified/If-Modified-Since（时间戳）<ul>
<li>只是更新了文件的元信息，比如touch了文件一下，也会造成更新</li>
<li>时间粒度只能到秒，如果1秒内完成了内容的变更，却不会更新</li>
</ul>
</li>
<li>ETag/If-None-Match<ul>
<li>解决上述2个问题</li>
<li>基于文件内容为资源编码的唯一字符串标示</li>
<li>因为ETag的生成要耗费服务器资源，所以是上面的补充，不能完全替代，优先级高于上面<img src="/2020/02/28/fe/http协商缓存响应头设置流程.png" title="http协商缓存响应头设置流程">
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>PushCache </p>
<ul>
<li>http2的特性</li>
<li>是缓存的最后一道防线，在上面3种缓存都未命中的情况下才会询问PushCache</li>
<li>不同的页面共享了一个http2连接，就共享同一个PushCache</li>
<li>会话级的缓存，session关闭，缓存失效</li>
</ul>
</li>
</ul>
</li>
<li><p>本地存储</p>
<ul>
<li>cookie<ul>
<li>状态维持，解决http无状态的问题</li>
<li>体积限制，最大4k</li>
<li>流量消耗</li>
</ul>
</li>
<li>storage<ul>
<li>localStorage 永久有效</li>
<li>sessionStorage 会话级有效</li>
</ul>
</li>
<li>IndexedDB<ul>
<li>非关系型数据库<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">var db;</span><br><span class="line">// 参数1位数据库名，参数2为版本号</span><br><span class="line">const request = window.indexedDB.open(&quot;name&quot;, 1)</span><br><span class="line">// 使用IndexedDB失败时的监听函数</span><br><span class="line">request.onerror = function(event) &#123;</span><br><span class="line">  console.log(&apos;无法使用IndexedDB&apos;)</span><br><span class="line">&#125;</span><br><span class="line">// 成功</span><br><span class="line">request.onsuccess  = function(event)&#123;</span><br><span class="line">  // 此处就可以获取到db实例</span><br><span class="line">  db = event.target.result</span><br><span class="line">  console.log(&quot;你打开了IndexedDB&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// onupgradeneeded事件会在初始化数据库/版本发生更新时被调用，我们在它的监听函数中创建object store</span><br><span class="line">request.onupgradeneeded = function(event)&#123;</span><br><span class="line">  let objectStore</span><br><span class="line">  // 如果同名表未被创建过，则新建test表</span><br><span class="line">  if (!db.objectStoreNames.contains(&apos;test&apos;)) &#123;</span><br><span class="line">    objectStore = db.createObjectStore(&apos;test&apos;, &#123; keyPath: &apos;id&apos; &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">  // 创建事务，指定表格名称和读写权限</span><br><span class="line">  const transaction = db.transaction([&quot;test&quot;],&quot;readwrite&quot;)</span><br><span class="line">  // 拿到Object Store对象</span><br><span class="line">  const objectStore = transaction.objectStore(&quot;test&quot;)</span><br><span class="line">  // 向表格写入数据</span><br><span class="line">  objectStore.add(&#123;id: 1, name: &apos;test1&apos;&#125;)</span><br><span class="line"></span><br><span class="line">  // 操作成功时的监听函数</span><br><span class="line">  transaction.oncomplete = function(event) &#123;</span><br><span class="line">    console.log(&quot;操作成功&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">  // 操作失败时的监听函数</span><br><span class="line">  transaction.onerror = function(event) &#123;</span><br><span class="line">    console.log(&quot;这里有一个Error&quot;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// lazyload</span><br><span class="line">// 获取所有的图片标签</span><br><span class="line">const imgs = document.getElementsByTagName(&apos;img&apos;)</span><br><span class="line">// 获取可视区域的高度</span><br><span class="line">const viewHeight = window.innerHeight || document.documentElement.clientHeight</span><br><span class="line">// num用于统计当前显示到了哪一张图片，避免每次都从第一张图片开始检查是否露出</span><br><span class="line">let num = 0</span><br><span class="line">function lazyload()&#123;</span><br><span class="line">    for(let i=num; i&lt;imgs.length; i++) &#123;</span><br><span class="line">        // 用可视区域高度减去元素顶部距离可视区域顶部的高度</span><br><span class="line">        let distance = viewHeight - imgs[i].getBoundingClientRect().top</span><br><span class="line">        // 如果可视区域高度大于等于元素顶部距离可视区域顶部的高度，说明元素露出</span><br><span class="line">        if(distance &gt;= 0 )&#123;</span><br><span class="line">            // 给元素写入真实的src，展示图片</span><br><span class="line">            imgs[i].src = imgs[i].getAttribute(&apos;data-src&apos;)</span><br><span class="line">            // 前i张图片已经加载完毕，下次从第i+1张开始检查是否露出</span><br><span class="line">            num = i + 1</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 监听Scroll事件</span><br><span class="line">window.addEventListener(&apos;scroll&apos;, lazyload, false);</span><br><span class="line"></span><br><span class="line">// fn是我们需要包装的事件回调, delay是时间间隔的阈值</span><br><span class="line">function throttle(fn, delay) &#123;</span><br><span class="line">  // last为上一次触发回调的时间, timer是定时器</span><br><span class="line">  let last = 0, timer = null</span><br><span class="line">  // 将throttle处理结果当作函数返回</span><br><span class="line">  </span><br><span class="line">  return function () &#123; </span><br><span class="line">    // 保留调用时的this上下文</span><br><span class="line">    let context = this</span><br><span class="line">    // 保留调用时传入的参数</span><br><span class="line">    let args = arguments</span><br><span class="line">    // 记录本次触发回调的时间</span><br><span class="line">    let now = +new Date()</span><br><span class="line">    </span><br><span class="line">    // 判断上次触发的时间和本次触发的时间差是否小于时间间隔的阈值</span><br><span class="line">    if (now - last &lt; delay) &#123;</span><br><span class="line">    // 如果时间间隔小于我们设定的时间间隔阈值，则为本次触发操作设立一个新的定时器</span><br><span class="line">       clearTimeout(timer)</span><br><span class="line">       timer = setTimeout(function () &#123;</span><br><span class="line">          last = now</span><br><span class="line">          fn.apply(context, args)</span><br><span class="line">        &#125;, delay)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 如果时间间隔超出了我们设定的时间间隔阈值，那就不等了，无论如何要反馈给用户一次响应</span><br><span class="line">        last = now</span><br><span class="line">        fn.apply(context, args)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 用新的throttle包装scroll的回调</span><br><span class="line">const better_scroll = throttle(() =&gt; console.log(&apos;触发了滚动事件&apos;), 1000)</span><br><span class="line">document.addEventListener(&apos;scroll&apos;, better_scroll)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// throttle</span><br><span class="line">// fn是我们需要包装的事件回调, interval是时间间隔的阈值</span><br><span class="line">function throttle(fn, interval) &#123;</span><br><span class="line">  // last为上一次触发回调的时间</span><br><span class="line">  let last = 0</span><br><span class="line">  </span><br><span class="line">  // 将throttle处理结果当作函数返回</span><br><span class="line">  return function () &#123;</span><br><span class="line">      // 保留调用时的this上下文</span><br><span class="line">      let context = this</span><br><span class="line">      // 保留调用时传入的参数</span><br><span class="line">      let args = arguments</span><br><span class="line">      // 记录本次触发回调的时间</span><br><span class="line">      let now = +new Date()</span><br><span class="line">      </span><br><span class="line">      // 判断上次触发的时间和本次触发的时间差是否小于时间间隔的阈值</span><br><span class="line">      if (now - last &gt;= interval) &#123;</span><br><span class="line">      // 如果时间间隔大于我们设定的时间间隔阈值，则执行回调</span><br><span class="line">          last = now;</span><br><span class="line">          fn.apply(context, args);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 用throttle来包装scroll的回调</span><br><span class="line">const better_scroll = throttle(() =&gt; console.log(&apos;触发了滚动事件&apos;), 1000)</span><br><span class="line">document.addEventListener(&apos;scroll&apos;, better_scroll)</span><br><span class="line"></span><br><span class="line">// fn是我们需要包装的事件回调, delay是每次推迟执行的等待时间</span><br><span class="line">function debounce(fn, delay) &#123;</span><br><span class="line">  // 定时器</span><br><span class="line">  let timer = null</span><br><span class="line">  </span><br><span class="line">  // 将debounce处理结果当作函数返回</span><br><span class="line">  return function () &#123;</span><br><span class="line">    // 保留调用时的this上下文</span><br><span class="line">    let context = this</span><br><span class="line">    // 保留调用时传入的参数</span><br><span class="line">    let args = arguments</span><br><span class="line"></span><br><span class="line">    // 每次事件被触发时，都去清除之前的旧定时器</span><br><span class="line">    if(timer) &#123;</span><br><span class="line">        clearTimeout(timer)</span><br><span class="line">    &#125;</span><br><span class="line">    // 设立新定时器</span><br><span class="line">    timer = setTimeout(function () &#123;</span><br><span class="line">      fn.apply(context, args)</span><br><span class="line">    &#125;, delay)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 用debounce来包装scroll的回调</span><br><span class="line">const better_scroll = debounce(() =&gt; console.log(&apos;触发了滚动事件&apos;), 1000)</span><br><span class="line">document.addEventListener(&apos;scroll&apos;, better_scroll)</span><br></pre></td></tr></table></figure>

<ul>
<li>性能监测<ul>
<li>可视化工具<ul>
<li>Performance</li>
<li>LightHouse</li>
</ul>
</li>
<li>性能api<ul>
<li>performance</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="技能分层"><a href="#技能分层" class="headerlink" title="技能分层"></a>技能分层</h4><ul>
<li><p>基础页面开发（pc网页）</p>
<ul>
<li>设计稿审查<ul>
<li>确定设计稿的开发友好性（是否有还原成本高和无法实现的地方）</li>
<li>特殊元素是否有合理的边界处理（如文案超出外层容器怎么办）</li>
<li>确定页面的框架结构（layout）</li>
<li>识别可复用的组件（跨页面可复用/当前页面可复用）</li>
</ul>
</li>
<li>编写页面骨骼框架<ul>
<li>盒模型统一 box-sizing:border-box;</li>
<li>布局<ul>
<li>普通文档流</li>
<li>浮动布局</li>
<li>绝对布局</li>
<li>弹性布局</li>
<li>网格布局</li>
</ul>
</li>
</ul>
</li>
<li>填充网页内容</li>
<li>润色<ul>
<li>BEM <ul>
<li>基于组件的css命名规范</li>
<li>block模块，模块名字的单词之间用-连接</li>
<li>element元素，模块中的子元素，用__连接模块名</li>
<li>modifier修饰符，元素的其他形态，用–连接</li>
<li>B-B__E–M</li>
</ul>
</li>
</ul>
</li>
<li>兼容性测试<ul>
<li>html兼容性</li>
<li>css兼容性</li>
<li>js兼容性</li>
</ul>
</li>
</ul>
</li>
<li><p>响应式页面开发（移动端网页） </p>
<ul>
<li>目标<ul>
<li>为不同的浏览器窗口使用不同的样式代码</li>
<li>页面元素的尺寸能够依据浏览器窗口变化而平滑变化</li>
</ul>
</li>
<li>步骤<ul>
<li>添加vierport的meta标签</li>
<li>使用mediaQuery <ul>
<li>@media(min|max-width|height orientation)</li>
<li>两种方式<ul>
<li>style代码里@media (){}</li>
<li><link media="(min-width: 769px)" href="min-769.css"></li>
</ul>
</li>
<li>样式断点，参考bulma框架<ul>
<li>mobile</li>
<li>tablet 769</li>
<li>desktop 1024</li>
<li>widescreen 1216</li>
<li>fullhd 1408</li>
</ul>
</li>
</ul>
</li>
<li>使用viewport单位和rem 解决元素的尺寸能响应变化<ul>
<li>使用vw作为唯一单位<ul>
<li>sass函数将设计稿尺寸的像素单位转换为vw单位</li>
<li>所有尺寸全部转换为vw包括文字</li>
<li>1px使用transform的scale实现</li>
<li>vw缺点就是会无限放大或缩小</li>
</ul>
</li>
<li>vw + rem<ul>
<li>根元素的字体大小为vw，同时限制最大值/最小值并配合body最大宽/最小宽实现断点</li>
<li>其他元素统一使用rem单位<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// iPhone 6尺寸作为设计稿基准</span><br><span class="line">$vw_base: 375; </span><br><span class="line">@function vw($px) &#123;</span><br><span class="line">    @return ($px / $vm_base) * 100vw;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.mod_grid &#123;</span><br><span class="line">    position: relative;</span><br><span class="line">    &amp;::after &#123;</span><br><span class="line">        // 实现1物理像素的下边框线</span><br><span class="line">        content: &apos;&apos;;</span><br><span class="line">        position: absolute;</span><br><span class="line">        z-index: 1;</span><br><span class="line">        pointer-events: none;</span><br><span class="line">        background-color: #ddd;</span><br><span class="line">        height: 1px;</span><br><span class="line">        left: 0;</span><br><span class="line">        right: 0;</span><br><span class="line">        top: 0;</span><br><span class="line">        @media only screen and (-webkit-min-device-pixel-ratio: 2) &#123;</span><br><span class="line">            -webkit-transform: scaleY(0.5);</span><br><span class="line">            -webkit-transform-origin: 50% 0%;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// vw+rem</span><br><span class="line">// rem 单位换算：定为 75px 只是方便运算，750px-75px、640-64px、1080px-108px，如此类推</span><br><span class="line">$vw_fontsize: 75; // iPhone 6尺寸的根元素大小基准值</span><br><span class="line">@function rem($px) &#123;</span><br><span class="line">     @return ($px / $vw_fontsize ) * 1rem;</span><br><span class="line">&#125;</span><br><span class="line">// 根元素大小使用 vw 单位</span><br><span class="line">$vw_design: 750;</span><br><span class="line">html &#123;</span><br><span class="line">    font-size: ($vw_fontsize / ($vw_design / 2)) * 100vw; </span><br><span class="line">    // 同时，通过Media Queries 限制根元素最大最小值</span><br><span class="line">    @media screen and (max-width: 320px) &#123;</span><br><span class="line">        font-size: 64px;</span><br><span class="line">    &#125;</span><br><span class="line">    @media screen and (min-width: 540px) &#123;</span><br><span class="line">        font-size: 108px;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// body 也增加最大最小宽度限制，避免默认100%宽度的 block 元素跟随 body 而过大过小</span><br><span class="line">body &#123;</span><br><span class="line">    max-width: 540px;</span><br><span class="line">    min-width: 320px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>滑屏应用开发（活动营销页面）</p>
<ul>
<li>swiper</li>
<li>自己实现<ul>
<li>手势动作判断</li>
<li>执行相应动画</li>
</ul>
</li>
</ul>
</li>
<li><p>动效开发（活动营销页面）</p>
<ul>
<li>transition 补间动画 </li>
<li>animation 逐帧动画+补间动画</li>
<li>gif</li>
<li>js控制关键帧sprite的background-position</li>
<li>canvas库（createJS，pixi.js）</li>
<li>svg+SMIL<ul>
<li>声明视窗 <svg width="100" height="100"/></li>
<li>绘制路径 <path d="指令数据" style="填充描边"></path></li>
<li>绘制图形 <circle cx cy r style></circle></li>
<li>添加动画 <animatemotion></animatemotion></li>
<li>SMIL synchronizedMultimediaIntegrationLanguage同步多媒体集成语言，主要用作交互</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="软技能"><a href="#软技能" class="headerlink" title="软技能"></a>软技能</h4><ul>
<li>健身</li>
<li>理财</li>
<li>韧性</li>
<li>责任心</li>
<li>持续学习能力</li>
<li>团队合作能力</li>
<li>交流沟通能力</li>
</ul>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>


    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2020 prief
    
  </p>
</footer>
    
  </div>
</div>
</body>
</html>