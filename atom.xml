<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>prief</title>
  
  <subtitle>about share and go on</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://prief.github.io/"/>
  <updated>2019-10-05T09:36:57.928Z</updated>
  <id>https://prief.github.io/</id>
  
  <author>
    <name>prief</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>flutter</title>
    <link href="https://prief.github.io/2019/10/01/flutter/"/>
    <id>https://prief.github.io/2019/10/01/flutter/</id>
    <published>2019-10-01T08:24:22.000Z</published>
    <updated>2019-10-05T09:36:57.928Z</updated>
    
    <content type="html"><![CDATA[<h1 id="flutter开发起步"><a href="#flutter开发起步" class="headerlink" title="flutter开发起步"></a>flutter开发起步</h1><h2 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h2><ul><li>底层渲染逻辑skia<ul><li>利用自己的渲染引擎skia，不依赖OS的组件</li><li>保证了高度一致性</li></ul></li><li>上层开发语言dart<ul><li>Dart同时支持JIT/AOT</li><li>开发期调试效率高，发布期执行性能好<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2></li></ul></li><li>跨平台</li><li>高保真(自己的渲染引擎skia完成了渲染的闭环，不用js扩展调用原生)</li><li>高性能</li></ul><h2 id="分层架构"><a href="#分层架构" class="headerlink" title="分层架构"></a>分层架构</h2><ul><li>embedder<ul><li>操作系统适配层</li><li>实现了渲染设置，线程设置，平台插件适配等</li></ul></li><li>engine<ul><li>skia和text提供了调用底层渲染和排版的能力</li><li>dart提供了运行时调用dart和渲染引擎的能力</li></ul></li><li>framework<ul><li>dart实现的UI SDK包含动画、图形绘制、手势识别等</li></ul></li></ul><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><ul><li>Widget以树的形式组织成控件树</li><li>flutter通过每个控件创建不同类型的渲染对象组成渲染对象树</li><li>渲染对象树通过4个阶段完成展示<ul><li>布局 采用深度优先机制遍历渲染对象树，决定对象的位置和尺寸(支持布局边界和父约束)</li><li>绘制 按位置和尺寸绘制到不同的图层，采用深度优先机制遍历(支持重绘边界)</li><li>合成 将所有图层根据位置，尺寸，层级，大小，透明度等规则计算出最终显示效果简化渲染树</li><li>渲染 几何图层数据交给skia引擎加工成二维图像数据最终给GPU进行渲染<img src="/2019/10/01/flutter/flutter.jpg" title="flutter技术点"></li></ul></li></ul><h2 id="跨平台方案"><a href="#跨平台方案" class="headerlink" title="跨平台方案"></a>跨平台方案</h2><ul><li><p>三个时代</p><ul><li>web容器时代(cordova,ionic,微信小程序都使用webview+jsBridge)</li><li>泛web容器时代(reactNative,weex,快应用都把渲染交给原生)</li><li>自绘引擎时代(flutter,客户端只提供一块画布即可)<img src="/2019/10/01/flutter/hybrid.png" title="技术选型对比"></li></ul></li><li><p>图像显示基本原理</p><ul><li>CPU负责图像数据的计算</li><li>GPU负责图像数据的渲染，渲染后放入帧缓冲区，视频控制器根据垂直同步信号VSync以60t/s刷新</li><li>显示器负责图像显示</li></ul></li><li><p>skia</p><ul><li>c++开发的高性能2D图像绘制引擎</li></ul></li></ul><h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><ul><li>android<ul><li>AS</li><li>AVD(Nexus6P)</li></ul></li><li>ios<ul><li>Xcode</li><li>open -a Simulator</li></ul></li><li>flutter<ul><li>export PUB_HOSTED_URL=<a href="https://pub.flutter-io.cn" target="_blank" rel="noopener">https://pub.flutter-io.cn</a></li><li>export FLUTTER_STORAGE_BASE_URL=<a href="https://storage.flutter-io.cn" target="_blank" rel="noopener">https://storage.flutter-io.cn</a></li><li>export FLUTTER_HOME=/Users/dh/dev/flutter</li><li>export PATH=$PATH:$FLUTTER_HOME/bin</li><li>flutter emulators [–launch apple_ios_simulator]</li><li>flutter doctor</li></ul></li><li>doctor问题解决方案<ul><li>ios<ul><li>gem sources –add <a href="https://gems.ruby-china.com/" target="_blank" rel="noopener">https://gems.ruby-china.com/</a> –remove <a href="https://rubygems.org/" target="_blank" rel="noopener">https://rubygems.org/</a></li><li>gem sources -l</li><li>gem update –system</li><li>sudo gem install cocoapods</li><li>pod setup</li><li>brew update</li><li>brew install –HEAD usbmuxd #usb通信抽象为tcp通信，与设备进行多路socket守护进程</li><li>brew link usbmuxd</li><li>brew install –HEAD libimobiledevice # 与设备进行通信的跨平台协议库</li><li>brew install ideviceinstaller # 在ios设备上管理app的工具</li><li>signing</li></ul></li><li>android<ul><li>flutter doctor –android-licenses</li><li>flutter plugin</li></ul></li><li>vscode<ul><li>flutter extension</li></ul></li></ul></li></ul><h2 id="工程结构"><a href="#工程结构" class="headerlink" title="工程结构"></a>工程结构</h2><ul><li>android 安卓子工程</li><li>build 构建产物</li><li>ios ios子工程</li><li>lib/main.dart flutter工程入口文件</li><li>test 测试目录</li><li>flutter_app_demo.iml 工程配置文件</li><li>pubspec.lock 记录当前项目实际依赖信息的文件</li><li>pubspec.yaml 管理第三方库和资源的配置文件</li></ul><h1 id="Dart基础"><a href="#Dart基础" class="headerlink" title="Dart基础"></a>Dart基础</h1><h2 id="特性-1"><a href="#特性-1" class="headerlink" title="特性"></a>特性</h2><ul><li>同时支持JIT/AOT编译模式<ul><li>JIT just in time即时编译，适合开发环境</li><li>AOT ahead of time运行前编译，适合生产环境</li></ul></li><li>内存分配和垃圾回收机制<ul><li>内存线性增长，创建对象时只在堆上移动指针</li><li>并发是通过Isolate实现，使dart实现了无锁的内存分配</li><li>避免了抢占式调度和共享内存</li><li>垃圾回收采用多生代算法，只操作少量的活跃对象，忽略死亡对象</li></ul></li><li>单线程模型<ul><li>dar中没有线程，只有Isolate隔离区，isolate不共享内存</li><li>通过事件循环在事件队列上传递消息</li></ul></li><li>无需单独的声明式布局语言</li></ul><h2 id="语言基础"><a href="#语言基础" class="headerlink" title="语言基础"></a>语言基础</h2><ul><li>dart概述<ul><li>是类型安全的语言，不会隐式转换类型</li><li>所有的类型都是对象类型，都继承自顶层的Object</li></ul></li><li>main()作为程序的入口 </li><li>变量与类型<ul><li>var声明变量表示变量类型自动推断</li><li>未初始化的变量的值都是null</li></ul></li><li>基本类型<ul><li>String<ul><li>UTF-16的字符串组成</li><li>支持单引号、双引号</li><li>支持${expression}或$var</li><li>三个单引号或双引号来表示多行字符串</li></ul></li><li>num<ul><li>64位int，代表整数类型</li><li>64位double，代表浮点类型</li></ul></li><li>bool<ul><li>true</li><li>false</li></ul></li><li>List<ul><li>类型约束List<int>/ list = <int>[]</int></int></li><li>类型判断 list is List<int></int></li></ul></li><li>Map<ul><li>类型约束Map&lt;String,String&gt;/ map = &lt;String,String&gt;{}</li><li>类型判断 map is Map&lt;String,String&gt;</li></ul></li></ul></li><li>常量<ul><li>const 表示在编译期间即能确定的值</li><li>final 表示在运行时确定的值，一旦确定后就不可改变</li></ul></li><li>函数<ul><li>类型Function</li><li>支持箭头函数</li><li>函数的重载即提供同名但参数不同的函数，dart认为会导致混乱所以不支持</li><li>但dart支持更高效的可选命名参数{}和可选参数[],也支持参数默认值</li></ul></li><li>类<ul><li>实例变量/方法</li><li>类变量/方法 static关键字</li><li>变量/方法名称前面加上_即可作为private使用，否则就是public，_是库访问级别</li><li>构造函数语法糖就是类中调用同类名相同的方法即命名构造函数</li><li>实例化时可以省略new关键字</li><li>dart支持初始化列表，即支持多个构造函数，构造函数可以重定向:到另一个构造函数</li></ul></li><li>复用<ul><li>继承父类 extends</li><li>接口实现 implements</li><li>混入 with 解决dart缺少对多重继承的支持问题还能避免多重继承导致的菱形歧义</li></ul></li><li>运算符(用于简化处理变量实例缺失即null的情况)<ul><li>?. p?.printInfo()表示p为null时跳过，不为null时再调用，避免抛错</li><li>??= a??=value 如果a为null则赋值value，否则跳过</li><li>?? a ?? b 如果a不为null则返回a，否则返回b</li><li>dart提供了类似C++的运算符覆写机制，使用户可以自定义运算符，使用operator关键字和运算符一起使用来表示类成员运算符函数</li></ul></li></ul><h1 id="flutter基础"><a href="#flutter基础" class="headerlink" title="flutter基础"></a>flutter基础</h1><h2 id="widget"><a href="#widget" class="headerlink" title="widget"></a>widget</h2><ul><li>描述<ul><li>是flutter功能的抽象描述</li><li>是视图的配置信息</li><li>是数据的映射</li><li>一切皆widget(view/viewController/Activity/Application/Layout等)</li><li>由父到子、自顶向下方式构建，父widget控制子widget的样式</li><li>widget是不可变的，更新则意味着销毁和重建</li></ul></li><li>分类<ul><li>statelessWidget Model在build后不变，父widget通过初始化参数完全控制UI</li><li>statefulWidget build后还要关心和响应数据变化来进行重绘，setState就会触发</li></ul></li><li>渲染过程<ul><li>widget树 对视图的一种结构化描述数据，widget是不可变的需要很多的重建</li><li>element树 是widget的一个实例化对象，element.renderObject承载了视图构建的上下文数据，element是可变的，把真正需要修改的部分同步到renderObject中</li><li>renderObject树 主要负责视图渲染的对象<ul><li>布局 在renderObject中完成，采用深度优先机制遍历，确定位置和尺寸</li><li>绘制 在renderObject中完成，采用深度优先机制遍历，确定图层</li><li>合成 交给skia引擎</li><li>渲染 交给skia引擎，在VSync信号同步时直接从渲染树合成Bitmap，交给GPU</li></ul></li></ul></li></ul><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><ul><li>app的生命周期<ul><li>WidgetsBindingObserver类实现钩子，此类中有很多函数</li><li>didChangeAppLifecycleState<ul><li>resumed 可见的，可以响应用户交互</li><li>inactive 非活动状态，不能响应用户交互(上下两个状态切换时的中间状态)</li><li>paused 不可见并不能响应用户交互但后台继续活动</li></ul></li><li>addPostFrameCallback<ul><li>单次frame绘制回调，只会回调1次</li></ul></li><li>addPersistentFrameCallback<ul><li>实时frame绘制回调，每次frame绘制完成后都回调</li><li>适合做FPS监测</li></ul></li></ul></li><li>视图的生命周期，通过state体现<ul><li>创建<ul><li>构造方法，调用createState创建state，构造方法决定了最初呈现效果在state生命周期只会被调用1次</li><li>initState，在state生命周期只会被调用1次</li><li>didChangeDependencies</li><li>build，构建视图返回一个widget</li></ul></li><li>更新<ul><li>setState</li><li>didChangeDependencies</li><li>didUpdateWidget</li></ul></li><li>销毁<ul><li>deactivate</li><li>dispose<img src="/2019/10/01/flutter/lifecycle1.png" title="生命周期1"><img src="/2019/10/01/flutter/lifecycle2.png" title="生命周期2"></li></ul></li></ul></li></ul><h2 id="常用widget"><a href="#常用widget" class="headerlink" title="常用widget"></a>常用widget</h2><ul><li>Text<ul><li>Text</li><li>Text.rich</li></ul></li><li>TextSpan</li><li>Image<ul><li>Image.asset(“images/logo.png”)加载本地资源图片</li><li>Image.file(new File(“/path/to/file”))本地图片</li><li>Image.network(“<a href="http://xxx/xx.xx&quot;)加载网络图片" target="_blank" rel="noopener">http://xxx/xx.xx&quot;)加载网络图片</a></li></ul></li><li>FadeInImage 提供了图片占位，加载动画效果</li><li>CachedNetworkImage 还可以把图片缓存到fs中，更强大</li><li>FloatingActionButton 圆形按钮</li><li>FlatButton 扁平化的按钮，默认背景透明，有交互效果</li><li>RaisedButton 凸起的按钮，默认带有灰色背景，有交互效果</li><li>ListView<ul><li>ListView 适用于少量子元素，需要提前创建子widget，性能较差</li><li>ListView.builder 适用于子widget比较多的情况懒加载widget</li><li>ListView.separated 可设置分割线样式</li></ul></li><li>CustomScrollView<ul><li>处理多个需要自定义滚动效果的widget</li><li>彼此独立的可滚动的widget统称为sliver</li></ul></li><li>ScrollController 滚动信息的监听</li><li>ScrollNotification 获取滚动事件的通知，将ListView纳入子widget</li><li>布局类widget<ul><li>单子widget<ul><li>Container</li><li>Padding</li><li>Center</li></ul></li><li>多子widget<ul><li>Row</li><li>Column</li><li>Expanded 处理容器的剩余空间</li></ul></li><li>层叠widget<ul><li>Stack 提供了层叠布局的容器</li><li>Positioned 提供了设置子widget位置的能力</li></ul></li></ul></li><li>自定义widget<ul><li>组合</li><li>自绘<ul><li>CustomPaint是用以承接自绘控件的容器，并不负责真正的绘制</li><li>绘制使用画布Canvas和画笔Paint及绘制逻辑CustomPainter控制</li></ul></li></ul></li></ul><h2 id="主题定制"><a href="#主题定制" class="headerlink" title="主题定制"></a>主题定制</h2><ul><li>主题一般包括颜色、图片、字体、字号等资源和配置</li><li>实现<ul><li>ios中通常将配置信息预写到plist中通过单例来控制</li><li>android中通常将配置信息写到style属性值的xml中，通过activity的setTheme切换</li><li>前端通过切换css即可实现</li></ul></li><li>flutter使用ThemeData统一管理<ul><li>app全局范围 MaterialApp.theme</li><li>widget局部范围 Theme.data<ul><li>不想继承任何全局配置可直接新建一个ThemeData实例</li><li>想继承可使用Theme.of(context).copyWith()</li></ul></li><li>Theme.of(context)向上查找widget树，返回最近的Theme</li><li>defaultTargetPlatform 可判断当前运行的平台</li></ul></li></ul><h2 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h2><ul><li>原生<ul><li>ios使用Images.xcassets管理图片，其他资源直接拖进项目即可</li><li>android使用drawable+分辨率命名的文件夹管理图片，res/layout放布局，res/values放资源描述文件，assets放原始文件</li></ul></li><li>flutter<ul><li>assets可管理任意类型的资源</li><li>pubspec.yaml中配置指向对应目录即可<ul><li>可以单独指向某个文件</li><li>也可以指向一个目录，目录制定并不会递归，所以需显示递归指定子目录</li></ul></li><li>资源引用<ul><li>Image.asset()引用图片<ul><li>遵循基于像素密度的管理方式1.0x、2.0x、3.0x</li><li>flutter根据设备分辨率加载比例最接近的图片资源实现自动降级</li><li>资源目录应该将1.0x、2.0x、3.0x图片资源分开管理</li><li>assets/bg.jpg</li><li>assets/2.0x/bg.jpg</li><li>assets/3.0x/bg.jpg</li><li>pubspec.yaml中仅声明1.0x资源即可 flutter.assets: assets/bg.jpg</li></ul></li><li>rootBundle.loadString()加载字符串文件资源</li><li>rootBundle.load()加载二进制文件资源</li><li>fonts:[{family: name,fonts:[{asset:assets/fonts/name.ttf},{asset:assets/fonts/name-Italic.ttf,style:italic},{asset:assets/fonts/name-Bold.ttf,weight:700}]}]</li></ul></li></ul></li><li>flutter框架前的原生配置<ul><li>更换app图标<ul><li>ios ios/Runner/Assets.xcassets/AppIcon.appiconset</li><li>android android/app/src/main/res/mipmap</li></ul></li><li>更换app启动图<ul><li>ios ios/Runner/Assets.xcassets/LaunchImage.imageset</li><li>android android/app/src/main/res/drawable/launch_background.xml</li></ul></li></ul></li><li>第三方组件库<ul><li>pubspec.yaml<ul><li>类似于ios中的Podfile/android中的build.gradle/前端的package.json</li><li>pub<ul><li>dart的包管理工具，类似于ios中的cocoaPods/android中的maven/前端npm</li><li>dart的包实际上就是一个包含了pubspec.yaml的目录</li></ul></li></ul></li><li>推荐包使用区间进行版本的管理，dart/flutter的sdk运行环境使用固定版本号</li><li>包依赖可以直接获取pub资源，也可以使用本地路径或git地址</li><li>所有依赖确定并下载完毕后会生成.packages文件记录包映射信息，此文件需要忽略</li><li>最后pub会生成pubspec.lock文件记录包的来源和版本号，此文件需要git</li></ul></li></ul><h2 id="用户交互事件"><a href="#用户交互事件" class="headerlink" title="用户交互事件"></a>用户交互事件</h2><ul><li>原始的指针事件(PointerEvent)<ul><li>原生常见的触摸事件</li><li>事件会从最内层冒泡到根节点，无法取消冒泡或停止分发，只能hitTestBehavior</li><li>ListenerWidget可以监听子widget的原始指针事件</li></ul></li><li>手势识别(GestureDetector)<ul><li>多个原始指针事件的组合操作，是指针事件的语义化封装</li><li>GestureDetector可以处理各种高级触摸行为，可监听多个手势但最终只有一个生效</li><li>不同手势通过flutter内部的arena进行PK，最终决定是什么手势</li><li>父组件也需要处理子组件手势时需要RawGestureDetector和GestureFactory自定义</li></ul></li></ul><h2 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h2><ul><li>组件通信标准方式是通过属性传值</li><li>跨组件通信三种方案<ul><li>InheritedWidget</li><li>Notification</li><li>EventBus</li></ul></li><li>InheritedWidget<ul><li>从上到下传递</li><li>Theme是典型案例，父子建立观察者关系，上层属性修改后，子也会更新，默认只读</li></ul></li><li>Notification<ul><li>从下到上传递</li><li>NotificationListener进行监听</li></ul></li><li>EventBus<ul><li>上面两种依赖父子widget关系树</li><li>eventBus遵循了发布/订阅模式</li><li>全局作用，但容器引起冲突，组件移除要清理事件</li></ul></li></ul><h2 id="路由与导航"><a href="#路由与导航" class="headerlink" title="路由与导航"></a>路由与导航</h2><ul><li>Route <ul><li>是页面的抽象，主要负责接收参数，创建页面，响应navigator的打开和关闭</li></ul></li><li>Navigator<ul><li>维护一个路由栈管理Route，可打开/关闭/替换</li></ul></li><li>路由管理<ul><li>基本路由<ul><li>无需提前注册，页面切换时需要自己构造页面实例</li><li>Navigator.push(context,MaterialPageRouter(builder:()=&gt;{}))</li></ul></li><li>命名路由<ul><li>需要提前注册，页面切换时根据注册的标示符打开</li><li>Navigator.pushNamed(context,”name”)</li></ul></li></ul></li><li>其他<ul><li>默认路由 UnknownRoute</li><li>路由页面打开参数 RouteSettings</li><li>路由页面返回参数</li></ul></li></ul><h1 id="flutter进阶"><a href="#flutter进阶" class="headerlink" title="flutter进阶"></a>flutter进阶</h1><h1 id="综合应用"><a href="#综合应用" class="headerlink" title="综合应用"></a>综合应用</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;flutter开发起步&quot;&gt;&lt;a href=&quot;#flutter开发起步&quot; class=&quot;headerlink&quot; title=&quot;flutter开发起步&quot;&gt;&lt;/a&gt;flutter开发起步&lt;/h1&gt;&lt;h2 id=&quot;核心&quot;&gt;&lt;a href=&quot;#核心&quot; class=&quot;head
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>k8s-mooc</title>
    <link href="https://prief.github.io/2019/09/09/k8s-mooc/"/>
    <id>https://prief.github.io/2019/09/09/k8s-mooc/</id>
    <published>2019-09-09T14:37:42.000Z</published>
    <updated>2019-09-11T14:18:50.871Z</updated>
    
    <content type="html"><![CDATA[<h1 id="k8s快速入门"><a href="#k8s快速入门" class="headerlink" title="k8s快速入门"></a>k8s快速入门</h1><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><ul><li>kubernetes 舵手</li><li>container</li><li>image</li><li>pod</li><li>replicaset</li><li>deployment<h2 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h2></li><li>master<ul><li>etcd</li><li>apiServer</li><li>scheduler</li><li>controllerManager</li></ul></li><li>worker<ul><li>kubelet</li><li>docker<h2 id="认证授权"><a href="#认证授权" class="headerlink" title="认证授权"></a>认证授权</h2><h2 id="集群搭建方案对比"><a href="#集群搭建方案对比" class="headerlink" title="集群搭建方案对比"></a>集群搭建方案对比</h2><h1 id="kubeadm方式搭建"><a href="#kubeadm方式搭建" class="headerlink" title="kubeadm方式搭建"></a>kubeadm方式搭建</h1><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><h2 id="高可用部署"><a href="#高可用部署" class="headerlink" title="高可用部署"></a>高可用部署</h2><h2 id="可用性测试"><a href="#可用性测试" class="headerlink" title="可用性测试"></a>可用性测试</h2><h2 id="dashboard"><a href="#dashboard" class="headerlink" title="dashboard"></a>dashboard</h2><h1 id="二进制方式搭建"><a href="#二进制方式搭建" class="headerlink" title="二进制方式搭建"></a>二进制方式搭建</h1><h2 id="环境准备-1"><a href="#环境准备-1" class="headerlink" title="环境准备"></a>环境准备</h2><h2 id="高可用部署-1"><a href="#高可用部署-1" class="headerlink" title="高可用部署"></a>高可用部署</h2><h2 id="可用性测试-1"><a href="#可用性测试-1" class="headerlink" title="可用性测试"></a>可用性测试</h2><h2 id="dashboard-1"><a href="#dashboard-1" class="headerlink" title="dashboard"></a>dashboard</h2><h1 id="业务迁移到k8s"><a href="#业务迁移到k8s" class="headerlink" title="业务迁移到k8s"></a>业务迁移到k8s</h1><h2 id="harbor"><a href="#harbor" class="headerlink" title="harbor"></a>harbor</h2><h2 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h2><h2 id="部署ingress-nginx"><a href="#部署ingress-nginx" class="headerlink" title="部署ingress-nginx"></a>部署ingress-nginx</h2><h2 id="定时任务迁移"><a href="#定时任务迁移" class="headerlink" title="定时任务迁移"></a>定时任务迁移</h2><h2 id="springboot迁移"><a href="#springboot迁移" class="headerlink" title="springboot迁移"></a>springboot迁移</h2><h2 id="dubbo迁移"><a href="#dubbo迁移" class="headerlink" title="dubbo迁移"></a>dubbo迁移</h2><h2 id="传统web迁移"><a href="#传统web迁移" class="headerlink" title="传统web迁移"></a>传统web迁移</h2><h1 id="cicd"><a href="#cicd" class="headerlink" title="cicd"></a>cicd</h1><h2 id="git"><a href="#git" class="headerlink" title="git"></a>git</h2><h2 id="maven"><a href="#maven" class="headerlink" title="maven"></a>maven</h2><h2 id="docker-build"><a href="#docker-build" class="headerlink" title="docker build"></a>docker build</h2><h2 id="harbor-1"><a href="#harbor-1" class="headerlink" title="harbor"></a>harbor</h2><h2 id="服务发布"><a href="#服务发布" class="headerlink" title="服务发布"></a>服务发布</h2><h2 id="健康检查"><a href="#健康检查" class="headerlink" title="健康检查"></a>健康检查</h2><h1 id="重要资源对象"><a href="#重要资源对象" class="headerlink" title="重要资源对象"></a>重要资源对象</h1><h2 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a>namespace</h2><h2 id="resources"><a href="#resources" class="headerlink" title="resources"></a>resources</h2><h2 id="label"><a href="#label" class="headerlink" title="label"></a>label</h2><h1 id="调度与编排"><a href="#调度与编排" class="headerlink" title="调度与编排"></a>调度与编排</h1><h2 id="健康检查-1"><a href="#健康检查-1" class="headerlink" title="健康检查"></a>健康检查</h2><h2 id="scheduler"><a href="#scheduler" class="headerlink" title="scheduler"></a>scheduler</h2><h2 id="部署策略"><a href="#部署策略" class="headerlink" title="部署策略"></a>部署策略</h2><h2 id="pod"><a href="#pod" class="headerlink" title="pod"></a>pod</h2><h1 id="落地实践"><a href="#落地实践" class="headerlink" title="落地实践"></a>落地实践</h1><h2 id="ingress"><a href="#ingress" class="headerlink" title="ingress"></a>ingress</h2><h2 id="共享存储pv-pvc-sc"><a href="#共享存储pv-pvc-sc" class="headerlink" title="共享存储pv/pvc/sc"></a>共享存储pv/pvc/sc</h2><h2 id="statefulset"><a href="#statefulset" class="headerlink" title="statefulset"></a>statefulset</h2><h2 id="k8sApi"><a href="#k8sApi" class="headerlink" title="k8sApi"></a>k8sApi</h2><h1 id="日志和监控"><a href="#日志和监控" class="headerlink" title="日志和监控"></a>日志和监控</h1><h2 id="日志方案"><a href="#日志方案" class="headerlink" title="日志方案"></a>日志方案</h2><h2 id="监控入门"><a href="#监控入门" class="headerlink" title="监控入门"></a>监控入门</h2><h2 id="部署实战"><a href="#部署实战" class="headerlink" title="部署实战"></a>部署实战</h2><h2 id="监控落地"><a href="#监控落地" class="headerlink" title="监控落地"></a>监控落地</h2><h1 id="istio"><a href="#istio" class="headerlink" title="istio"></a>istio</h1><h2 id="架构原理"><a href="#架构原理" class="headerlink" title="架构原理"></a>架构原理</h2><h2 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h2><h2 id="智能路由"><a href="#智能路由" class="headerlink" title="智能路由"></a>智能路由</h2><h2 id="指标收集和查询"><a href="#指标收集和查询" class="headerlink" title="指标收集和查询"></a>指标收集和查询</h2><h2 id="分布式追踪"><a href="#分布式追踪" class="headerlink" title="分布式追踪"></a>分布式追踪</h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;k8s快速入门&quot;&gt;&lt;a href=&quot;#k8s快速入门&quot; class=&quot;headerlink&quot; title=&quot;k8s快速入门&quot;&gt;&lt;/a&gt;k8s快速入门&lt;/h1&gt;&lt;h2 id=&quot;核心概念&quot;&gt;&lt;a href=&quot;#核心概念&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>cli</title>
    <link href="https://prief.github.io/2019/08/17/cli/"/>
    <id>https://prief.github.io/2019/08/17/cli/</id>
    <published>2019-08-17T08:46:23.000Z</published>
    <updated>2019-09-09T10:45:24.270Z</updated>
    
    <content type="html"><![CDATA[<h1 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h1><h2 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h2><ul><li>三种使用方式<ul><li>webpack.config.js</li><li>内联在import语句中</li><li>在cli命令中指定</li></ul></li><li>常用loader<ul><li>babel-loader</li><li>style-loader 在html中注入style标签</li><li>css-loader 解析@import url()等</li><li>postcss-loader</li><li>sass-loader</li><li>html-loader</li><li>vue-loader</li><li>file-loader</li><li>url-loader</li></ul></li></ul><h2 id="plugin"><a href="#plugin" class="headerlink" title="plugin"></a>plugin</h2><ul><li>常用plugin<ul><li>HtmlWebpackPlugin</li><li>CommonsChunkPlugin</li><li>DefinePlugin</li><li>DllPlugin</li><li>ExtractTextWebpackPlugin</li><li>HotModuleReplacementPlugin</li><li>UglifyjsWebpackPlugin</li><li>CopyWebpackPlugin</li></ul></li></ul><h1 id="工程化模版"><a href="#工程化模版" class="headerlink" title="工程化模版"></a>工程化模版</h1><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><ul><li>mkdir template &amp;&amp; cd template &amp;&amp; npm init -y</li><li>npm i -D webpack webpack-cli vue-loader vue-template-compiler html-webpack-plugin css-loader style-loader sass-loader sass postcss-loader  postcss-preset-env url-loader file-loader @babel/core @babel/preset-env babel-loader webpack-dev-server connect-multiparty mockjs concurrently</li><li>npm i vue vue-router @babel/polyfill axios</li><li>浏览器支持列表<ul><li>package.json.browserslist</li><li>.browserlistrc</li><li>browserlist</li><li>环境变量BROWSERLIST </li></ul></li><li>.babelrc</li><li>postcss.config.js</li><li>webpack.config.js</li></ul><h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><ul><li>意义<ul><li>避免命名/变量冲突</li><li>更清晰的依赖关系</li><li>可维护</li><li>可复用</li><li>降低复杂度</li></ul></li><li>主流实现<ul><li>AMD<ul><li>异步加载，适合浏览器端</li><li>require</li><li>define([deps…],(deps…)=&gt;{return {}})</li></ul></li><li>CommonJS<ul><li>同步加载，适合服务端，因为大都在本地</li><li>require</li><li>module.exports | exports.</li></ul></li><li>ES6<ul><li>js语言层面支持的模块化，可做静态依赖分析，适合多端</li><li>import</li><li>export</li></ul></li></ul></li></ul><h2 id="本地开发环境"><a href="#本地开发环境" class="headerlink" title="本地开发环境"></a>本地开发环境</h2><ul><li><p>npm install –save-dev webpack-dev-server</p></li><li><p>“start”: “webpack-dev-server –open”</p></li><li><p>HMR</p><ul><li>hotModuleReplacement</li><li>能生效是因为模块实现了HMR接口<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (module.hot) &#123;</span><br><span class="line">  module.hot.accept(&quot;./print.js&quot;, function() &#123;</span><br><span class="line">    console.log(&quot;接收更新后的模块&quot;);</span><br><span class="line">    print();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>sourceMap</p><ul><li>source-map 适合生产环境，映射关系完整但运行慢</li><li>eval-source-map 适合开发环境，只映射到行但运行快</li></ul></li></ul><h2 id="本地mock"><a href="#本地mock" class="headerlink" title="本地mock"></a>本地mock</h2><ul><li>服务 express</li><li>路由 url与数据的路由绑定</li><li>数据模拟 mockjs<ul><li>数据模版定义规范DTD(data template definition)<ul><li>属性名 与规则之间用|分割</li><li>生成规则 依赖属性值的类型，是可选的</li><li>属性值 可以有@占位符，指定了最终值的类型和初始值</li><li>例如：’name|rule’: value</li></ul></li><li>数据占位符定义规范DPD(data placeholder definition)</li><li>核心api<ul><li>mock 将模版输出为最终的数据</li><li>random 生成随机数据</li></ul></li></ul></li><li>concurrently<ul><li>同一终端同时运行多个npm命令，不管是否同一进程</li></ul></li></ul><h2 id="代码检查"><a href="#代码检查" class="headerlink" title="代码检查"></a>代码检查</h2><ul><li>eslint<ul><li>npm install -D eslint eslint-loader eslint-plugin-vue babel-eslint eslint-friendly-formatter</li><li>plugins指定需要的插件名称，可以忽略eslint-plugin-</li><li>默认使用espree解析器，因为有新的语言特性需要指定为babel-eslint</li><li>换解析器需要在parserOptions中，防止全局替换导致其他插件失败</li><li>es6模块的sourceType为module</li><li>禁用eslint规则<ul><li>文件开头/* eslint-disable */禁用整个文件的检查</li><li>行// eslint-disable-line 禁用行检查</li><li>行// eslint-disable-line no-console 禁用console规则</li></ul></li><li>自定义规则<ul><li>extends: eslint:recommended</li><li>rules:{ no-console: off, quotes:[“wanr”,”single”],indent:[“error”,2]}</li><li>数组值第一项表示级别，默认是error</li></ul></li></ul></li><li>stylelint<ul><li>npm install -D stylelint stylelint-webpack-plugin</li><li>.stylelintrc.js</li><li>禁用规则<ul><li>/* stylelint-disable unit-whitelist*/ 禁用unit规则校验</li><li>/* stylelint-disable */ 禁用所有规则校验</li></ul></li><li>自定义规则<ul><li>extends: “stylelint-config-standard”</li><li>rules: {“color-no-invalid-hex”: true}</li></ul></li></ul></li></ul><h2 id="雪碧图"><a href="#雪碧图" class="headerlink" title="雪碧图"></a>雪碧图</h2><ul><li>npm install -D webpack-spritesmith</li><li>resolve.modules如果是相对路径则按照规则一级一级向上查找，如果是绝对路径不会向上查找</li><li>使用<ul><li>@import “~sprite.scss”</li><li>.icon-picName{@include sprite($picName)}</li></ul></li><li>自定义生成2x样式表<ul><li>官网的templateFunction</li><li>customTemplates: {function_based_template: templateFunction},</li><li>target.css = [[],path.resolve(__dirname, “src/assets/generated/sprite.scss”)]</li><li>使用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@import &apos;~sprite2.scss&apos;;</span><br><span class="line">&lt;li class=&quot;ico ico-picName&quot;&gt;&lt;/li&gt; </span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="按浏览器构建"><a href="#按浏览器构建" class="headerlink" title="按浏览器构建"></a>按浏览器构建</h2><ul><li>新版本浏览器<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;module&quot;&gt;&lt;/script&gt; 可直接加载ES6</span><br><span class="line">&lt;link rel=&quot;modulepreload&quot;&gt;&lt;/link&gt; 预加载</span><br></pre></td></tr></table></figure></li><li>老版本浏览器<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script nomodule&gt;加载旧版本js，新版本浏览器会忽略该引用</span><br></pre></td></tr></table></figure></li></ul><h2 id="按环境构建"><a href="#按环境构建" class="headerlink" title="按环境构建"></a>按环境构建</h2><ul><li>development</li><li>test</li><li>production</li><li>插件<ul><li>npm install –save-dev extract-text-webpack-plugin</li><li>npm install –save-dev optimize-css-assets-webpack-plugin</li><li>npm install terser-webpack-plugin –save-dev</li><li>HashedModuleIdsPlugin 避免不必要的hash变化</li></ul></li></ul><h2 id="集成调试工具"><a href="#集成调试工具" class="headerlink" title="集成调试工具"></a>集成调试工具</h2><ul><li>weinre / spy-debugger</li><li>vconsole<ul><li>npm install vconsole</li><li>DebugPlugin.js里面去实现 debugtool插件</li><li>vconsole.js 里面去new Vconsole</li><li>可以单独发一个npm包 debugtool-webpack-plugin</li></ul></li></ul><h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><ul><li>chai作为断言库</li><li>Mocha编写测试用例、测试框架</li><li>Karma测试过程管理TestRunner及启动浏览器和生成测试报告</li><li>npm install –save-dev karma mocha karma-mocha karma-chrome-launcher karma-webpack karma-sourcemap-loader karma-spec-reporter chai @vue/test-utils karma-coverage babel-plugin-istanbul cross-env</li><li>覆盖率<ul><li>语句覆盖率</li><li>分支覆盖率</li><li>函数覆盖率</li><li>行覆盖率</li></ul></li></ul><h2 id="e2e测试"><a href="#e2e测试" class="headerlink" title="e2e测试"></a>e2e测试</h2><ul><li>npm install –save-dev nightwatch chromedriver</li><li>npm install –save-dev geckodriver # firefox</li><li>npm install –save-dev cross-spawn # 启动子进程</li><li>npm install –save-dev nightwatch-html-reporter</li><li>nightwatch接口<ul><li>断言相关<ul><li>expect.element()</li><li>.value</li><li>.text</li><li>.equal(val)/.contain(val)/.match(val)</li></ul></li><li>协议映射相关<ul><li>.click()</li><li>.url()</li><li>.setValue()</li><li>.pause()</li><li>.waitForElementVisible()</li></ul></li></ul></li></ul><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><ul><li>缓存<ul><li>开启cache后，模块和生成的chunk如果内容不变则直接用cache，主要解决增量构建过程的性能</li><li>HardSourceWebpackPlugin，缓存编译过程中间结果 npm i -D hard-source-webpack-plugin</li></ul></li><li>多线程<ul><li>HappyPack</li><li>thread-loader #官方推荐</li></ul></li><li>预先编译<ul><li>DllPlugin 把基本不变的预先打包出单独dll文件</li><li>DllReferencePlugin 配置在文件中引用dll文件</li><li>运行一次npm run dll后不需在运行除非dll包有更新</li><li>npm i -D add-asset-html-webpack-plugin dll文件提前插入html</li><li>与splitChunks功能类似，可以去除splitChunks</li></ul></li></ul><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><ul><li>ecs<ul><li>const { spawn } = require(“child_process”);</li><li>ssh免密登陆</li></ul></li><li>oss<ul><li>vinyl-fs</li><li>vinyl-ftp</li></ul></li></ul><h1 id="cli"><a href="#cli" class="headerlink" title="cli"></a>cli</h1><h2 id="聚合配置并模版化"><a href="#聚合配置并模版化" class="headerlink" title="聚合配置并模版化"></a>聚合配置并模版化</h2><ul><li>app.config.js 聚合用户自定义配置</li><li>相应的配置都要从app.config.js中获取</li></ul><h2 id="handlebars模版化"><a href="#handlebars模版化" class="headerlink" title="handlebars模版化"></a>handlebars模版化</h2><ul><li>template 存放模版</li><li>meta.js 配置入口<ul><li>helpers<ul><li>语法{{#helperName}}...{{/helperName}}</li><li>内置helper if,上面都语法可根据helperName的truthy进行判断</li><li>自定义registerHelper</li></ul></li><li>prompts</li><li>filters</li><li>completeMessage</li></ul></li></ul><h2 id="cli-1"><a href="#cli-1" class="headerlink" title="cli"></a>cli</h2><ul><li>工作流程<ul><li>运行命令 mc init weex pro</li><li>下载模版 </li><li>交互配置信息</li><li>渲染模版</li></ul></li><li>mc<ul><li>1个主命令</li><li>2个子命令<ul><li>mc init</li><li>mc help 默认子命令</li></ul></li></ul></li><li>主命令开发<ul><li>npm i commander</li><li>npm link #将包链接到全局</li></ul></li><li>子命令模块<ul><li>commander</li><li>chalk</li><li>inquirer</li><li>download-git-repo</li><li>rimraf</li><li>user-home</li><li>ora</li><li>metalsmith  <ul><li>文件处理工具,从哪里读，做什么处理，写到哪里去</li><li>use方法绑定插件</li><li>source设定源文件目录</li><li>destination指定文件写入的目录</li><li>clean(true|false)写入前是否删除原来已经存在的文件</li><li>build完成对文件的处理接收回调</li><li>metadata读取全局数据对象</li></ul></li><li>handlebars </li><li>async </li><li>consolidate<ul><li>各种模版引擎的整合库</li><li>还需要引用需要的模版引擎库</li></ul></li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">bin/mc</span><br><span class="line"></span><br><span class="line">#!/usr/bin/env node</span><br><span class="line">const program = require(&apos;commander&apos;);</span><br><span class="line">program</span><br><span class="line">  .version(require(&apos;../package&apos;).version)</span><br><span class="line">  .usage(&apos;&lt;command&gt; [options]&apos;)</span><br><span class="line">  .command(&apos;init&apos;, &apos;generate a new fe project&apos;);</span><br><span class="line">program.parse(process.argv);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;webpack&quot;&gt;&lt;a href=&quot;#webpack&quot; class=&quot;headerlink&quot; title=&quot;webpack&quot;&gt;&lt;/a&gt;webpack&lt;/h1&gt;&lt;h2 id=&quot;loader&quot;&gt;&lt;a href=&quot;#loader&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>webpack</title>
    <link href="https://prief.github.io/2019/08/17/webpack/"/>
    <id>https://prief.github.io/2019/08/17/webpack/</id>
    <published>2019-08-17T08:29:05.000Z</published>
    <updated>2019-09-09T10:21:04.293Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h1><h2 id="webpack及发展历史"><a href="#webpack及发展历史" class="headerlink" title="webpack及发展历史"></a>webpack及发展历史</h2><ul><li>目的<ul><li>css的预处理</li><li>ES6等的支持</li><li>图片压缩</li><li>发布产物的压缩混淆</li></ul></li><li>同类<ul><li>rollup</li><li>parcel</li></ul></li><li>安装准备<ul><li>brew install nvm , windows可以安装nvm-windows</li><li>nvm install v10.16.3</li><li>node -v</li><li>npm -v</li><li>mkdir webpack-demo &amp;&amp; cd webpack-demo</li><li>npm init -y</li><li>npm i -D webpack webpack-cli</li><li>./node_modules/.bin/webpack -v</li></ul></li></ul><h2 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h2><ul><li>基础<ul><li>mode</li><li>entry</li><li>output</li><li>module</li><li>plugins</li></ul></li><li>mode<ul><li>production 默认</li><li>development</li><li>none</li></ul></li><li>entry<ul><li>单入口 “path”</li><li>多入口 {name:path}</li></ul></li><li>output<ul><li>path 输出路径</li><li>filename 构建文件名称<ul><li>‘[name]’ 对应入口中的name</li><li>‘[hash]’ 对应文件的hash</li></ul></li></ul></li><li>loaders<ul><li>本质是一个函数，接收源文件作为参数输出转换后的结果</li><li>babel-loader<ul><li>解析ES6/7</li><li>需要安装@babel/core @babel/preset-env @babel/proposal-class-properties等</li><li>配置文件.babelrc中增加presets和plugins</li></ul></li><li>style-loader<ul><li>将css插入head的style标签</li></ul></li><li>css-loader<ul><li>解析.css文件转换成commonjs对象</li></ul></li><li>less-loader<ul><li>解析less代码成css，依赖less</li></ul></li><li>file-loader<ul><li>解析各种文件资源（图片/字体等）</li><li>如果希望能把小资源转成base64可以使用url-loader的limit</li><li>把二进制文件转成base64后文件大小会增加二进制文件的1/3左右</li></ul></li><li>raw-loader 将文件以字符串内容形式导入</li><li>thread-loader</li></ul></li><li>plugins<ul><li>本质是一个类，实现了apply方法</li><li>CommonsChunkPlugin chunk相同代码抽取成公共js</li><li>CleanWebpackPlugin 清理构建目录</li><li>CopyWebpackPlugin</li><li>ZipWebpackPlugin 将打包出的资源生成一个zip包</li><li>HtmlWebpackPlugin </li><li>ExtractTextWebpackPlugin</li><li>MiniCssExtractPlugin 需要配合.loader替换style-loader进行css文件提取</li><li>OptimizeCssAssetsWebpackPlugin</li><li>UglifyjsWebpackPlugin</li></ul></li></ul><h2 id="高级配置"><a href="#高级配置" class="headerlink" title="高级配置"></a>高级配置</h2><ul><li><p>构建监听</p><ul><li>webpack 命令行传 –watch</li><li>webpack.config.js中 watch:true</li><li>是通过轮询文件最后修改时间进行的，同时也有aggregateTimeout防止短时间多次修改，有poll指定每秒轮询多少次，ignore指定忽略，这些属性在watchOptions中</li></ul></li><li><p>WDS</p><ul><li>webpack-dev-server</li><li>WDS不输出文件都是存在内存中，所以不用手动刷新浏览器可实现HMR</li><li>dev: “webpack-dev-server –open”</li><li>webpack.config.js<ul><li>mode: ‘development’</li><li>plugins: [new webpack.HotModuleReplacementPlugin()]</li><li>devServer:{hot:true,contentBase:’./dist’}</li></ul></li><li>WDS灵活定制版WDM webapck-dev-middleware</li><li>HMR <ul><li>由compiler把源码编译成bundle和HMR的patch</li><li>bundle由本地的bundleServer返回给浏览器</li><li>HMR的patch由本地的HMRServer(WebSockt)返回浏览器的HMRRuntime</li><li>浏览器执行bundle和patch执行代码</li></ul></li></ul></li><li><p>文件指纹</p><ul><li>hash 和整个项目有关，只要项目内有变化hash就变，文件处理也可以用[hash:8]</li><li>chunkhash 不同的entry会生成不同的chunkhash，常用于js，常设置在output.filename中[chunkhash:8]</li><li>contenthash 文件内容不变contenthash不变，常用于css，常设置在MiniCssExtractPlugin的filename中[contenthash:8]</li></ul></li><li><p>代码压缩</p><ul><li>html 使用html-webpack-plugin的minify对象属性</li><li>css 使用optimize-css-assets-webpack-plugin和cssnano</li><li>js 内置了uglifyjs-webpack-plugin</li></ul></li><li><p>postcss</p><ul><li>autoprefixer<ul><li>o presto</li><li>ms trident</li><li>moz gecko</li><li>webkit webkit</li></ul></li><li>npm i -D postcss-loader autoprefixer</li></ul></li><li><p>屏幕分辨率</p><ul><li>rem: font-size of the root element，是相对单位</li><li>npm i -D px2rem-loader</li><li>options:{remUnit:75,remPrecision:8}</li><li>npm i lib-flexible lib-flexible在页面渲染时计算rem的值</li></ul></li><li><p>内联资源到html</p><ul><li>内联html/js<ul><li>raw-loader </li><li>html模版里写${ require(‘raw-loader!./meta.html’)} 直接内联html</li><li>script里写${ require(‘raw-loader!babel-loader!../node_modules/lib-flexible/flexible.js’) }内联js</li></ul></li><li>内联css<ul><li>style-loader options:{insertAt:’top’,singleton:true //所有style合并成1个 }</li><li>html-inline-css-webpack-plugin 将打包好的css内联</li></ul></li></ul></li><li><p>MPA</p><ul><li>手动的可增加1个entry，然后增加1个对应的htmlWP，不方便维护</li><li>通用的动态设置entry:glob.sync(path.join(__dirname,’./src/*/index.js’))和对应的htmlWP<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const setMPA = () =&gt; &#123;</span><br><span class="line">    const entry = &#123;&#125;;</span><br><span class="line">    const htmlWebpackPlugins = [];</span><br><span class="line">    const entryFiles = glob.sync(path.join(__dirname, &apos;./src/*/index.js&apos;));</span><br><span class="line">    Object.keys(entryFiles)</span><br><span class="line">        .map((index) =&gt; &#123;</span><br><span class="line">            const entryFile = entryFiles[index];</span><br><span class="line">            const match = entryFile.match(/src\/(.*)\/index\.js/);</span><br><span class="line">            const pageName = match &amp;&amp; match[1];</span><br><span class="line"></span><br><span class="line">            entry[pageName] = entryFile;</span><br><span class="line">            htmlWebpackPlugins.push(</span><br><span class="line">                new HtmlWP(&#123;</span><br><span class="line">                    inlineSource: &apos;.css$&apos;,</span><br><span class="line">                    template: path.join(__dirname, `src/$&#123;pageName&#125;/index.html`),</span><br><span class="line">                    filename: `$&#123;pageName&#125;.html`,</span><br><span class="line">                    chunks: [&apos;vendors&apos;, pageName],</span><br><span class="line">                    inject: true,</span><br><span class="line">                    minify: &#123;</span><br><span class="line">                        html5: true,</span><br><span class="line">                        collapseWhitespace: true,</span><br><span class="line">                        preserveLineBreaks: false,</span><br><span class="line">                        minifyCSS: true,</span><br><span class="line">                        minifyJS: true,</span><br><span class="line">                        removeComments: false</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            );</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">        entry,</span><br><span class="line">        htmlWebpackPlugins</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const &#123;entry,htmlWebpackPlugins&#125; = setMPA()</span><br></pre></td></tr></table></figure></li></ul></li><li><p>sourceMap</p><ul><li>开发环境使用，生产环境只需要传到监控平台</li><li>关键字<ul><li>eval 使用eval包裹模块代码，最后面制定对应的源文件，不生成单独的map文件</li><li>cheap 不包含列信息</li><li>source-map 生成.map文件</li><li>inline 将.map作为DataURI嵌入，不单独生成.map</li><li>module 包含loader的source-map,可对依赖分析</li></ul></li><li>类型<ul><li>生产环境使用source-map，map文件上传到监控平台</li><li>开发环境使用eval-source-map，加速打包</li></ul></li></ul></li><li><p>提取公共资源</p><ul><li>基础库(vue/react/react-dom)分离到cdn，可使用html-webpack-externals-plugin</li><li>也可以用webpack4内置的splitChunksPlugin代替CommonsChunkPlugin</li><li>chunks说明<ul><li>async 默认选项，表示异步引入的库进行分离</li><li>initial 同步引入的库进行分离</li><li>all 推荐使用，所有引入的库都进行分离</li></ul></li><li>chunks分离后需要把分离出的name添加到htmlWP中的chunks<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">optimization:&#123;</span><br><span class="line">       splitChunks:&#123;</span><br><span class="line">           minSize: 0,</span><br><span class="line">           maxSize:1000,</span><br><span class="line">           minChunks: 2,</span><br><span class="line">           cacheGroups:&#123;</span><br><span class="line">               vendors:&#123;</span><br><span class="line">                   test:/(react|react-dom)/,</span><br><span class="line">                   name:&quot;vendors&quot;,</span><br><span class="line">                   chunks:&quot;all&quot;</span><br><span class="line">               &#125;,</span><br><span class="line">               commons:&#123;</span><br><span class="line">                 name:&quot;commons&quot;,</span><br><span class="line">                 chunks:&quot;all&quot;,</span><br><span class="line">                 minChunks:2</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>treeShaking</p><ul><li>把模块中没被引用的方法在uglify阶段去除掉</li><li>使用<ul><li>必须是ES6的语法，不能用在CommonJS，ES6可以静态分析</li><li>在.babelrc里设置module:false即可</li><li>mode为production情况下默认开启了此功能</li><li>要求导出的函数不能有副作用，否则也会失效</li></ul></li><li>原理<ul><li>DCE dead code elimination 无用代码擦除<ul><li>代码不可到达</li><li>代码执行的结果不会被用到</li><li>只写不读的代码</li></ul></li><li>ES6模块特点<ul><li>import只能出现在代码顶层</li><li>import的模块名只能是字符串常量</li><li>import的binding是immutable的</li></ul></li></ul></li></ul></li><li><p>ScopeHoisting</p><ul><li>问题<ul><li>构建后的模块代码都是通过闭包实现IIFE</li><li>大量的闭包导致代码体积增大，运行时内存开销增大</li></ul></li><li>分析<ul><li>把所有的模块都包裹一层函数形成IIFE</li><li>把import转换成_webpack_require,export转换成_webpack_exports</li><li>把所有模块都缓存到modules数组</li><li>通过WEBPACK_REQUIRE_METHOD(0) 启动程序</li></ul></li><li>scopeHoisting将模块代码按照引用顺序放在一个函数作用域，适当的做重命名防止变量冲突，达到减少函数声明和内存开销</li><li>使用时mode设置为production默认开启</li><li>手动开启使用 new webpack.optimize.ModuleConcatenationPlugin()</li></ul></li><li><p>动态import</p><ul><li>把相同的代码抽离到一个共享模块，在通过懒加载动态import使初始下载的代码更小</li><li>懒加载<ul><li>CommonJS使用方式require.ensure()</li><li>ES6使用方式 动态import目前还没有原生支持，需要babel插件<ul><li>npm i @babel/plugin-syntax-dynamic-import</li><li>.babelrc中plugins:[‘@babel/plugin-syntax-dynamic-import’]</li><li>代码中需要的地方用import(‘./dynamic.js’).then()</li></ul></li></ul></li></ul></li><li><p>ESLint</p><ul><li>制定规范<ul><li>基于eslint:recommmend配置进行改进，不重复造轮子</li><li>能够帮助发现错误的规则全部开启</li><li>保持风格统一，不要限制开发体验</li></ul></li><li>落地<ul><li>和CICD集成 如gitlab的pipline</li><li>和webpack集成</li></ul></li><li>本地开发增加precommit钩子(本地可以–no-verify绕过，所以CICD必须要有)<ul><li>npm i -D husky</li><li>“precommit”: “lint-staged”</li><li>“lint-staged”: {“linters”:”*.{js,scss}”:[“eslint –fix”, “git add”]}</li></ul></li><li>webpack集成ESLint<ul><li>.js文件先用eslint-loader再使用babel-loader</li><li>npm i -D eslint eslint-loader babel-eslint eslint-plugin-import …</li><li>.eslintrc.js<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    parser:&quot;babel-eslint&quot;,</span><br><span class="line">    extends:[&apos;&apos;],</span><br><span class="line">    env:&#123;</span><br><span class="line">        browser:true,</span><br><span class="line">        node:true</span><br><span class="line">    &#125;,</span><br><span class="line">    rules:&#123;</span><br><span class="line">        indent:[2,2]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>打包库和组件</p><ul><li>需求<ul><li>打包压缩版和非压缩版</li><li>支持AMD/CJS/ESM模块引入和script直接引入，统称UMD</li></ul></li><li>实现<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">const TerserPlugin = require(&apos;terser-webpack-plugin&apos;)</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  mode:&apos;none&apos;,</span><br><span class="line">  entry:&#123;</span><br><span class="line">    &apos;name&apos;:&apos;./src/index.js&apos;,</span><br><span class="line">    &apos;name.min&apos;:&apos;./src/index.js&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  output:&#123;</span><br><span class="line">    filename:&apos;[name].js&apos;,</span><br><span class="line">    library:&apos;libName&apos;, // 库的全局变量</span><br><span class="line">    libraryExport:&apos;default&apos;,</span><br><span class="line">    libraryTarget:&apos;umd&apos; // 库的引入方式</span><br><span class="line">  &#125;,</span><br><span class="line">  optimization:&#123;</span><br><span class="line">    minimize:true,</span><br><span class="line">    minimizer:[</span><br><span class="line">      new TerserPlugin(&#123;</span><br><span class="line">        include:/\.min\.js$/, //只对.min压缩</span><br><span class="line">      &#125;)</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// package.json</span><br><span class="line">&quot;main&quot;: &quot;index.js&quot;,</span><br><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;build&quot;: &quot;webpack&quot;,</span><br><span class="line">  &quot;prepublish&quot;: &quot;webpack&quot;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">// index.js</span><br><span class="line">if(process.env.NODE_ENV === &apos;production&apos;)&#123;</span><br><span class="line">  module.exports = require(&apos;./dist/name.min.js&apos;)</span><br><span class="line">&#125;else&#123;</span><br><span class="line">  module.exports = require(&apos;./dist/name.js&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>SSR</p><ul><li>server side render</li><li>优势<ul><li>减少网络请求</li><li>减少白屏时间</li><li>对SEO友好</li></ul></li><li>实现思路<ul><li>服务端使用server的renderToString将组件渲染成字符串，路由返回对应的字符串模板</li><li>客户端进行环境判断请求对应的文件</li></ul></li><li>问题<ul><li>nodejs中没有浏览器的window需要hack：if(typeof window === ‘undefined’){ global.window = {} }</li><li>不兼容的组件需要根据打包环境进行适配</li><li>http请求需要改写成axios</li><li>css样式不显示可以采用浏览器端模板占位符替换的方式’<!--HTML_PLACEHOLDER-->‘</li><li>首屏业务数据也可用模板占位符替换的方式<!--INITIAL_DATA_PLACEHOLDER--></li></ul></li></ul></li><li><p>优化构建日志</p><ul><li>webpack.config.js中stats字段控制统计信息<ul><li>errors-only</li><li>minimal</li><li>none | false</li><li>normal | true</li><li>verbose </li></ul></li><li>friendly-errors-webpack-plugin<ul><li>stats: ‘errors-only’</li><li>new FriendlyErrorsWebpackPlugin()</li><li>日志提示<ul><li>success</li><li>warning</li><li>error</li></ul></li></ul></li></ul></li><li><p>构建异常和中断</p><ul><li>如果没有错误则process.exit(0)</li><li>如果有错误则process.exit(非0)，回调函数err.code则为非0数值</li><li>compiler每次构建结束后都会触发done这个hook</li><li>hook回调stats.compilation.errors错误对象</li></ul></li></ul><h1 id="进阶篇"><a href="#进阶篇" class="headerlink" title="进阶篇"></a>进阶篇</h1><h2 id="可维护的配置"><a href="#可维护的配置" class="headerlink" title="可维护的配置"></a>可维护的配置</h2><ul><li><p>抽离成npm包的意义</p><ul><li>通用性<ul><li>开发者无需关注构建配置</li><li>统一团队构建脚本</li></ul></li><li>可维护性<ul><li>构建配置合理拆分</li><li>README/CHANGELOG</li></ul></li><li>质量<ul><li>冒烟测试/单元测试/测试覆盖率</li><li>CI</li></ul></li></ul></li><li><p>构建配置管理的可选方案</p><ul><li>通过多个配置文件管理对应环境 webpack –config参数控制</li><li>构建配置设计成一个库 如neutrino webpack-blocks</li><li>设计成一个工具 如create-react-app nwb</li><li>配置放在一个文件，通过–env控制</li></ul></li><li><p>构建配置包设计</p><ul><li>通过多个配置文件管理对应环境<ul><li>webpack.base.js<ul><li>资源解析(es6/react/css/less/图片/字体)</li><li>样式增强(css前缀自动补齐/px2rem)</li><li>目录清理</li><li>多页面打包</li><li>构建过程日志优化</li><li>构建错误捕获和处理</li><li>css提取成一个单独的文件</li></ul></li><li>webpack.dev.js<ul><li>hmr</li><li>sourcemap</li></ul></li><li>webpack.prod.js<ul><li>代码压缩</li><li>文件指纹</li><li>treeShaking</li><li>scopeHoisting</li><li>速度优化 基础包放cdn</li><li>体积优化 代码分割动态import</li></ul></li><li>webpack.ssr.js<ul><li>output.libraryTarget</li><li>css解析</li></ul></li></ul></li><li>npm包<ul><li>规范(git commit/READMEESLINT/SemVer)</li><li>质量(冒烟测试/单元测试/测试覆盖率/CI)</li></ul></li><li>配置组合<ul><li>webpack-merge</li><li>module.exports=merge(baseConf,devConf)</li></ul></li><li>目录结构<ul><li>test/</li><li>lib/</li><li>README.md</li><li>CHANGELOG.md</li><li>.eslintrc.js</li><li>.gitignore</li><li>package.json</li><li>index.js</li></ul></li></ul></li><li><p>构建包使用ESLINT</p><ul><li>使用eslint-config-airbnb-base规则集</li><li>使用eslint –fix做自动修复</li><li>package.json “lint”:”eslint ./lib –fix”</li><li>.eslintrc.js<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  extends:[&apos;airbnb-base&apos;],</span><br><span class="line">  parser:&apos;babel-eslint&apos;,</span><br><span class="line">  env:&#123;</span><br><span class="line">    browser:true,</span><br><span class="line">    node:true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>冒烟测试smoke testing</p><ul><li>指对提交测试的软件在进行详细测试前的预测试</li><li>主要目的是暴露基本功能失效的严重问题</li><li>执行<ul><li>构建是否成功 webpack(conf,(err,stats)=&gt;{})</li><li>是否生成对应文件 glob.sync([‘*.js’]).length</li></ul></li></ul></li><li><p>单元测试和测试覆盖率</p><ul><li>框架<ul><li>mocha(单纯的测试框架)+chai(断言库)</li><li>jasmine/jest 集成框架，开箱即用</li></ul></li><li>mocha接入<ul><li>npm i -D mocha chai</li><li>test.js中编写describe/it/expect</li><li>package.json中”test”:”mocha “</li><li>npm run test</li></ul></li><li>测试覆盖率<ul><li>npm i -D istanbul</li><li>package.json中”test”:”istanbul cover mocha”</li></ul></li></ul></li><li><p>CI</p><ul><li>作用<ul><li>快速发现错误</li><li>防止分支大幅偏离主干</li></ul></li><li>措施<ul><li>集成前必须跑通测试，否则不予集成</li></ul></li><li>排名<ul><li>travis-ci</li><li>circle-ci</li><li>jenkins-ci</li></ul></li></ul></li><li><p>发布npm包</p><ul><li>npm login</li><li>npm version patch|minor|major(自动git提交和tag)</li><li>npm publish</li></ul></li><li><p>git提交规范和changeLog生成</p><ul><li>提交规范优势<ul><li>加快review流程</li><li>根据提交生成changeLog</li><li>可追溯可回顾</li></ul></li><li>技术方案<ul><li>目地统一提交日志标准</li><li>使用angular的git commit规范<ul><li>信息分3部分，空行分割<ul><li>标题(首字母不大写，末尾不要标点)<ul><li>type(scope): subject</li></ul></li><li>主题内容</li><li>尾注</li></ul></li><li>提交类型type限制<ul><li>feat：新增feature</li><li>fix：修复bug</li><li>docs：仅仅修改了文档</li><li>style：仅仅修改文件样式，不改变逻辑</li><li>perf：优化相关，提升体验性能等</li><li>refactor：代码重构无新功能或bug修复</li><li>test：测试用例</li><li>chore：改变构建流程或增加依赖库工具</li><li>revert：回滚到上一版本</li></ul></li><li>scope(可根项目分成大类如docs/components)</li><li>主题内容可以详细列明每个修改点影响点</li><li>尾注可以增加链接或关闭issue等</li></ul></li><li>日志提交时友好的提示工具:commitize</li><li>不符合要求的拒绝提交:validate-commit-msg</li><li>统一changeLog文档信息生成:conventional-changelog-cli</li></ul></li><li>本地增加precommit钩子<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">npm i -D husky validate-commit-msg conventional-changelog-cli</span><br><span class="line"></span><br><span class="line">&quot;scripts&quot;:&#123;</span><br><span class="line">  &quot;commitmsg&quot;:&quot;validate-commit-msg&quot;,</span><br><span class="line">  &quot;changelog&quot;:&quot;conventional-changelog -p angular -i CHANGELOG.md -s -r 0&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>语义化版本号</p><ul><li>semantic versioning<ul><li>major 做了不兼容api的修改</li><li>minor 做了向下兼容的功能新增</li><li>patch 做了向下兼容的问题修正</li><li>major.minor.patch版本号严格递增</li></ul></li><li>优势<ul><li>避免出现循环依赖</li><li>减少依赖冲突</li></ul></li><li>发布重要版本时可以发先行版本<ul><li>alpha 内测版</li><li>beta 外部小范围测试版，可以加新功能</li><li>rc 公测版release candidate不会加新功能，主要用排错</li><li>major.minor.patch-alpha.2</li></ul></li></ul></li></ul><h2 id="构建速度和体积优化"><a href="#构建速度和体积优化" class="headerlink" title="构建速度和体积优化"></a>构建速度和体积优化</h2><ul><li><p>初级分析</p><ul><li>使用webpack内置的stats<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;:&#123;</span><br><span class="line">  &quot;build:stats&quot;:&quot;webpack --env production --json &gt; stats.json&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>速度分析</p><ul><li>使用speed-measure-webpack-plugin插件</li><li>可以看到每个loader和插件执行耗时和总耗时<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">npm i -D speed-measure-webpack-plugin</span><br><span class="line"></span><br><span class="line">const SMWP = require(&apos;speed-measure-webpack-plugin&apos;)</span><br><span class="line"></span><br><span class="line">const smp = new SMWP();</span><br><span class="line"></span><br><span class="line">module.exports = smp.wrap(WEBPACK_CONFIG)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>体积分析</p><ul><li>使用webpack-bundle-analyzer插件</li><li>构建完毕自动在8888端口展示结果<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">npm i -D webpack-bundle-analyzer</span><br><span class="line"></span><br><span class="line">const &#123; BundleAnalyzerPlugin&#125; = require(&apos;webpack-bundle-analyzer&apos;);</span><br><span class="line"></span><br><span class="line">plugins:[</span><br><span class="line">  new webpack-bundle-analyzer()</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li></ul></li><li><p>速度提升</p><ul><li>使用高版本nodejs和webpack，从底层做了优化</li><li>多进程多实例构建 thread-loader </li><li>多进程多实例并行压缩terser-webpack-plugin<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">npm i -D thread-loader terser-webpack-plugin</span><br><span class="line"></span><br><span class="line">use:[</span><br><span class="line">  &#123;</span><br><span class="line">    loader:&quot;thread-loader&quot;,</span><br><span class="line">    options:&#123;</span><br><span class="line">      workers:3</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;babel-loader&quot;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">optimization:&#123;</span><br><span class="line">  minimizer:[</span><br><span class="line">    new TerserWebpackPlugin(&#123;</span><br><span class="line">      parallel:true // 默认cpu核心2倍-1</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>进一步分包</p><ul><li>htmlWebpackExternalsPlugin将基础包分离到cdn引入的缺点是可能有很多基础包很多script请求</li><li>splitChunks缺点是每次都要分析依赖的基础包</li><li>DLLPlugin分包可以把框架基础包和业务基础包进行预编译，打包成一个文件，然后通过DLLReferencePlugin对manifest.json引用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// webpack.dll.js</span><br><span class="line">const path = require(&apos;path&apos;)</span><br><span class="line">const webpack = require(&apos;webpack&apos;)</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  entry:&#123;</span><br><span class="line">    library:[</span><br><span class="line">      &apos;react&apos;,</span><br><span class="line">      &apos;react-dom&apos;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  output:&#123;</span><br><span class="line">    filename:&quot;[name]_[chunkhash]_dll.js&quot;,</span><br><span class="line">    path:path.join(__dirname,&apos;dll&apos;),</span><br><span class="line">    library:&quot;[name]&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins:[</span><br><span class="line">    new webpack.DllPlugin(&#123;</span><br><span class="line">      name:&quot;[name]_[hash]&quot;,</span><br><span class="line">      path:path.join(__dirname,&apos;dll/[name].json&apos;)</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// package.json</span><br><span class="line">&quot;scripts&quot;:&#123;</span><br><span class="line">  &quot;dll&quot;:&quot;webpack --config webpack.dll.js&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// webpack.prod.js</span><br><span class="line"></span><br><span class="line">new webpack.DllReferencePlugin(&#123;</span><br><span class="line">  manifest: require(&apos;./dll/library.json&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>缓存</p><ul><li>提升二次构建速度</li><li>思路<ul><li>babel-loader开启缓存</li><li>terser-webpack-plugin开启缓存</li><li>hard-source-webpack-plugin开启缓存<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// babel-loader</span><br><span class="line">&apos;babel-loader?cacheDirectory=true&apos;</span><br><span class="line"></span><br><span class="line">// terser-webpack-plugin</span><br><span class="line">optimization:&#123;</span><br><span class="line">  minimizer:[</span><br><span class="line">    new TerserWebpackPlugin(&#123;</span><br><span class="line">      parallel:true,</span><br><span class="line">      cache:true</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// hard-source-webpack-plugin</span><br><span class="line">let HSWP= require(&apos;hard-source-webpack-plugin&apos;)</span><br><span class="line"></span><br><span class="line">plugins:[</span><br><span class="line">  new HSWP()</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>缩小构建目标</p><ul><li>尽可能少的构建模块 exclude:’node_modules’</li><li>减少文件搜索范围<ul><li>优化resolve.modules [path.resolve(__dirname,’node_modules’)]</li><li>优化resolve.mainFields [‘main’]</li><li>优化resolve.extensions [‘.js’,’.json’]</li><li>优化resolve.alias {react:path.resolve(__dirname,’node_modules/….js’)}</li></ul></li></ul></li><li><p>图片压缩</p><ul><li>基于nodejs的imagemin或tinypng的api，使用image-webpack-loader</li><li>imagemin优势<ul><li>很多可配置项目</li><li>可引入第三方优化插件</li><li>可处理多种图片格式<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  loader: &apos;image-webpack-loader&apos;,</span><br><span class="line">  options: &#123;</span><br><span class="line">    mozjpeg: &#123;</span><br><span class="line">      progressive: true,</span><br><span class="line">      quality: 65</span><br><span class="line">    &#125;,</span><br><span class="line">    // optipng.enabled: false will disable optipng</span><br><span class="line">    optipng: &#123;</span><br><span class="line">      enabled: false,</span><br><span class="line">    &#125;,</span><br><span class="line">    pngquant: &#123;</span><br><span class="line">      quality: &apos;65-90&apos;,</span><br><span class="line">      speed: 4</span><br><span class="line">    &#125;,</span><br><span class="line">    gifsicle: &#123;</span><br><span class="line">      interlaced: false,</span><br><span class="line">    &#125;,</span><br><span class="line">    // the webp option will enable WEBP</span><br><span class="line">    webp: &#123;</span><br><span class="line">      quality: 75</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>treeShaking擦除无用css</p><ul><li>默认模块中只要有一个方法被引用整个文件会被打入bundle中，treeShaking是在uglify阶段擦除无用</li><li>webpack4中production默认开启treeShaking</li><li>前提必须是ESM语法，CJS不支持</li><li>手动开启需要在.babelrc中设置modules:false</li><li>删除无用css2种方案<ul><li>purifyCSS 遍历代码，识别已经用到的css</li><li>uncss 通过document.querySelector进行识别</li></ul></li><li>实践<ul><li>purgecss-webpack-plugin + mini-css-extract-plugin</li></ul></li></ul></li><li><p>动态polyfill</p><ul><li>减少构建体积</li><li>polyfill是根据UA下发需要的polyfill来按需加载</li><li>可以直接script[src=’’]来引用polyfill.io服务</li><li>也可以基于官方开源的方案自建polyfill的cdn服务</li><li>ua篡改也可以根据代码结果降级为获取全部polyfill</li></ul></li></ul><h1 id="原理篇"><a href="#原理篇" class="headerlink" title="原理篇"></a>原理篇</h1><h2 id="源码掌握原理"><a href="#源码掌握原理" class="headerlink" title="源码掌握原理"></a>源码掌握原理</h2><ul><li><p>webpack源码</p><ul><li>本质<ul><li>基于事件流的编程范例，运行一系列的插件</li><li>compiler = webpack(options)</li></ul></li><li>启动流程<ul><li>npm scripts</li><li>webpack cli</li><li>实际都是执行的node_modules/webpack/bin/webpack.js</li></ul></li><li>主要步骤<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">process.exitCode = 0;</span><br><span class="line">const runCommand = (cmd,args)=&gt;&#123;&#125;</span><br><span class="line">const installed = packageName=&gt;&#123;&#125;</span><br><span class="line">const CLIs = []</span><br><span class="line">const installedCLIs = CLIs.filter()</span><br><span class="line">if(installedCLIs.length ===0 )&#123;</span><br><span class="line"></span><br><span class="line">&#125;else if(installedCLIs.length ===1)&#123;</span><br><span class="line"></span><br><span class="line">&#125;else&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>webpack-cli源码</p><ul><li>主要流程<ul><li>引入yargs，对命令行进行定制</li><li>分析命令行参数，对参数进行转换，组成编译配置项</li><li>引入webpack，根据配置项进行编译</li></ul></li><li>不需编译的子命令<ul><li>init</li><li>migrate</li><li>add</li><li>remote</li><li>serve</li><li>info</li><li>generate-loader</li><li>generate-plugin</li></ul></li></ul></li><li><p>tapable</p><ul><li>类似nodejs的EventEmitter,主要控制钩子的发布和订阅</li><li>插件系统发布或订阅钩子函数进行处理</li><li>9大hook类<ul><li>SyncHook</li><li>SyncBailHook</li><li>SyncWaterfallHook</li><li>SyncLoopHook</li><li>AsyncParallelHook</li><li>AsyncParallelBailHook</li><li>AsyncSeriesHook</li><li>AsyncSeriesBailHook</li><li>AsyncSeriesWaterfallHook</li></ul></li><li>绑定和执行<ul><li>同步:tap和call</li><li>异步:tapAsync/tapPromise/tap和callAsync/<br>promise<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const hook1 = new SyncHook([&quot;a1&quot;,&quot;a2&quot;,&quot;a3&quot;])</span><br><span class="line"></span><br><span class="line">hook1.tap(&quot;hook1&quot;,(a1,a2,a3)=&gt;&#123;&#125;)</span><br><span class="line">hook1.call(1,2,3)</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>简易实现webpack</p><ul><li>babel语法转换 babylon</li><li>依赖分析 babel-traverse</li></ul></li></ul><h2 id="自定义loader"><a href="#自定义loader" class="headerlink" title="自定义loader"></a>自定义loader</h2><ul><li><p>loader链式调用和执行顺序</p><ul><li>loader只是一个导出为函数的js模块</li><li>module.exports = function(source){return s}</li><li>链式调用时从右到左从后到前依次串行执行</li><li>函数组合的2种方式<ul><li>unix的pipline从左到右</li><li>compose的方式从右到左compose=(f,g)=&gt;(…args)=&gt;f(g(…args)) webpack采用此方式</li></ul></li></ul></li><li><p>loader-runner</p><ul><li>可用webpack-cli的generate-loader命令</li><li>loader-runner可以在不安装webpack情况下运行loaders</li><li>webpack也使用loader-runner执行loader</li><li>开发中也可以用loader-runner进行loader的开发和调试</li></ul></li><li><p>实战</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">mkdir raw-loader &amp;&amp; cd raw-loader</span><br><span class="line">npm init -y </span><br><span class="line">npm i loader-runner</span><br><span class="line"></span><br><span class="line">/src/demo.txt</span><br><span class="line">demotxt</span><br><span class="line"></span><br><span class="line">/src/raw-loader.js</span><br><span class="line">module.exports=function(src)&#123;</span><br><span class="line">  const json = JSON.stringify(src)</span><br><span class="line">              .replace(/\u2028/g,&apos;\\u2028&apos;)</span><br><span class="line">              .replace(/\u2029/g,&apos;\\u2029&apos;)</span><br><span class="line"></span><br><span class="line">  // 正常返回 return `export default $&#123;json&#125;`; </span><br><span class="line">  // 抛错 throw new Error(&apos;myError&apos;);</span><br><span class="line">  // 也可通过this.callback(error,data1 [,data2...])</span><br><span class="line">  this.callback(null, json);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/run-loader.js</span><br><span class="line">const &#123;runLoaders &#125; = require(&apos;loader-runner&apos;);</span><br><span class="line">const fs = require(&apos;fs&apos;);</span><br><span class="line">const path = require(&apos;path&apos;)</span><br><span class="line">runLoaders(&#123;</span><br><span class="line">    resource:path.join(__dirname,&apos;./src/demo.txt&apos;),</span><br><span class="line">    loaders:[</span><br><span class="line">        path.join(__dirname,&apos;./src/raw-loader.js&apos;)</span><br><span class="line">    ],</span><br><span class="line">    context:&#123;</span><br><span class="line">        minimize:true</span><br><span class="line">    &#125;,</span><br><span class="line">    readResource:fs.readFile.bind(fs)</span><br><span class="line">&#125;,function(err,res)&#123;</span><br><span class="line">    console.log(err,res)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">node run-loader.js</span><br></pre></td></tr></table></figure></li><li><p>高级用法</p><ul><li><p>loader-utils的getOptions获取loader参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const loaderUtils = require(&apos;loader-utils&apos;);</span><br><span class="line">module.exports = function(source)&#123;</span><br><span class="line">  const &#123;name&#125; = loaderUtils.getOptions(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>loader的异步处理</p><ul><li>通过this.async()返回的一个函数进行异步处理</li><li>第一个参数是error，第二个参数是处理结果<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">module.exports = function(source)&#123;</span><br><span class="line">  const callback = this.async();</span><br><span class="line"></span><br><span class="line">  fs.readFile(path,&apos;utf-8&apos;,(err,data)=&gt;&#123;</span><br><span class="line">    callback(err,data)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>loader的缓存</p><ul><li>webpack中默认开启缓存</li><li>可使用this.cacheable(false)关掉缓存</li><li>缓存的条件是相同的输入有相同的输出</li><li>有依赖的loader无法使用缓存</li></ul></li><li><p>loader的文件输出</p><ul><li>this.emitFile(outputPath,content)</li></ul></li></ul></li></ul><h2 id="自定义plugin"><a href="#自定义plugin" class="headerlink" title="自定义plugin"></a>自定义plugin</h2><ul><li><p>插件</p><ul><li>没有loader那样的独立运行环境，只能在webpack内运行</li><li>插件需要导出一个类，类需要实现apply方法</li><li>apply方法接收到一个compiler对象参数</li><li>插件内通过compiler的hooks和compilation的hooks做逻辑处理</li></ul></li><li><p>搭建插件运行环境</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line">const DemoPlugin = require(&apos;./plugins/demo.js&apos;);</span><br><span class="line">const options = &#123;&#125;</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  entry:&#123;</span><br><span class="line">    lib: path.join(__dirname,&apos;src/lib.js&apos;)</span><br><span class="line">  &#125;,</span><br><span class="line">  output:&#123;</span><br><span class="line">    path:path.join(__dirname,&apos;dist&apos;),</span><br><span class="line">    filename:&apos;[name].js&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins:[</span><br><span class="line">    new DemoPlugin(options)</span><br><span class="line">  ]</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// plugins/demo.js</span><br><span class="line">module.exports = class DemoPlugin &#123;</span><br><span class="line">  constructor(options)&#123;</span><br><span class="line">    this.options = options</span><br><span class="line">  &#125;</span><br><span class="line">  apply(compiler)&#123;</span><br><span class="line">    console.log(this.options);</span><br><span class="line">    compiler.hooks.done.tap(&apos;demo&apos;,()=&gt;&#123;&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>错误处理</p><ul><li>接收参数时可以直接throw new Error()</li><li>hooks处理阶段通过compilation.warnings或errors.push(‘msg’)</li></ul></li><li><p>文件输出</p><ul><li>通过compilation.assets配合webpack-sources包<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">const JSZip = require(&apos;jszip&apos;)</span><br><span class="line">const RawSource = require(&apos;webpack-sources&apos;).RawSource</span><br><span class="line">const path = require(&apos;path&apos;)</span><br><span class="line">const zip = new JSZip()</span><br><span class="line">module.exports = class DemoPlugin &#123;</span><br><span class="line">  constructor (options) &#123;</span><br><span class="line">    this.options = options</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  apply (compiler) &#123;</span><br><span class="line">    compiler.hooks.emit.tapAsync(&apos;zipPlugin&apos;, (compilation, cb) =&gt; &#123;</span><br><span class="line">      const folder = zip.folder(this.options.name)</span><br><span class="line">      for (const filename in compilation.assets) &#123;</span><br><span class="line">        const source = compilation.assets[filename].source()</span><br><span class="line">        folder.file(filename, source)</span><br><span class="line">      &#125;</span><br><span class="line">      zip.generateAsync(&#123;</span><br><span class="line">        type: &apos;nodebuffer&apos;</span><br><span class="line">      &#125;).then((content) =&gt; &#123;</span><br><span class="line">        console.log(compilation.options)</span><br><span class="line">        const outputPath = path.join(compilation.options.output.path, this.options.name + &apos;.zip&apos;)</span><br><span class="line">        const relativePath = path.relative(compilation.options.output.path, outputPath)</span><br><span class="line">        compilation.assets[relativePath] = new RawSource(content)</span><br><span class="line">        cb()</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基础篇&quot;&gt;&lt;a href=&quot;#基础篇&quot; class=&quot;headerlink&quot; title=&quot;基础篇&quot;&gt;&lt;/a&gt;基础篇&lt;/h1&gt;&lt;h2 id=&quot;webpack及发展历史&quot;&gt;&lt;a href=&quot;#webpack及发展历史&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
      <category term="webpack" scheme="https://prief.github.io/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>vscode</title>
    <link href="https://prief.github.io/2019/08/15/vscode/"/>
    <id>https://prief.github.io/2019/08/15/vscode/</id>
    <published>2019-08-15T14:44:49.000Z</published>
    <updated>2019-09-09T10:40:17.673Z</updated>
    
    <content type="html"><![CDATA[<h1 id="命令面板"><a href="#命令面板" class="headerlink" title="命令面板"></a>命令面板</h1><h2 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h2><ul><li>cmd + shift + P<ul><li>shell &amp;&amp; install code in PATH</li><li>transfrom upper|lower</li></ul></li><li>cmd + P<ul><li>快速搜索打开文件</li></ul></li><li>cmd<ul><li>code –help</li><li>code -r reuseWindow folder|file</li><li>code -r -g package.json:128 #打开文件128行</li><li>code -r -d file1 file2 #对比2个文件</li><li>ls | code -r - #接受管道数据</li></ul></li></ul><h1 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h1><h2 id="光标"><a href="#光标" class="headerlink" title="光标"></a>光标</h2><ul><li>option + 左箭头 #单词为单位向左跳动</li><li>option + 右箭头 #单词为单位向右跳动</li><li>cmd + 左箭头  #直接跳到行首</li><li>cmd + 右箭头  #直接跳到行尾</li><li>cmd + 上箭头  #直接跳到文件头部</li><li>cmd + 下箭头  #直接跳到文件尾部</li><li>cmd + Enter  #下面开始一行</li><li>cmd + option + 上下 # 创建多光标</li><li>ctrl + g #跳到指定行</li><li>cmd + shift + O #跳到指定符号</li></ul><h2 id="文本选择"><a href="#文本选择" class="headerlink" title="文本选择"></a>文本选择</h2><ul><li>移动光标的同时按住shift进行文本的选择</li><li>cmd + D #多文本选择</li></ul><h2 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h2><ul><li>option + 上下 #移动当前行</li></ul><h2 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h2><ul><li>option + shift + 上下 #复制当前行</li></ul><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><ul><li>cmd + delete #删除光标到行首</li><li>cmd + shift + K #删除当前行</li><li>cmd + X #剪切</li></ul><h2 id="格式化代码"><a href="#格式化代码" class="headerlink" title="格式化代码"></a>格式化代码</h2><ul><li>option + shift + F </li></ul><h1 id="vscode相关"><a href="#vscode相关" class="headerlink" title="vscode相关"></a>vscode相关</h1><h2 id="创建codeSnippets"><a href="#创建codeSnippets" class="headerlink" title="创建codeSnippets"></a>创建codeSnippets</h2><ul><li>cmd + shift + P</li><li>user snippets<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> &quot;Print to console&quot;: &#123;</span><br><span class="line">    &quot;prefix&quot;: &quot;log&quot;,</span><br><span class="line">    &quot;body&quot;: [</span><br><span class="line">        &quot;console.log($&#123;1:i&#125;);&quot;,</span><br><span class="line">        &quot;console.log($&#123;1:i&#125; + 1); // $&#123;1:i&#125; + 1&quot;,</span><br><span class="line">        &quot;$2&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;description&quot;: &quot;Log output to console&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="vscode"><a href="#vscode" class="headerlink" title=".vscode"></a>.vscode</h2><ul><li>settings.json</li><li>tasks.json</li><li>launch.json</li><li>extensions.json</li></ul><h2 id="语言支持"><a href="#语言支持" class="headerlink" title="语言支持"></a>语言支持</h2><ul><li>json<ul><li>可自己定义jsonSchema做智能提示</li></ul></li><li>markdown<ul><li>open preview</li></ul></li><li>js<ul><li>jsDoc(可做接口文档/编码提示)</li><li>d.ts(ts接口定义)</li><li>// @ts-check 开启ts校验逐步过度到ts</li><li>logpoint 把原本调试时需要的console.log与断点结合 { str + “” }</li></ul></li><li>emmet<ul><li>emmet.triggerExpansionOnTab: true #输入后按tab自动展开</li><li>“emmet.includeLanguages”: {“vue-html”: “html”}</li><li>ui&gt;li*3</li><li>div+p</li><li>div#list&gt;li.list-item</li><li>#page&gt;div.logo+ul#navigation&gt;li*5&gt;a{Item $}</li><li>转到匹配对/删除节点(自动删除开闭节点)</li></ul></li></ul><h1 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h1><h2 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h2><ul><li>是一个nodejs应用</li><li>可以操作vscodeAPI进行插件功能实现</li></ul><h2 id="创建插件"><a href="#创建插件" class="headerlink" title="创建插件"></a>创建插件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">npm i -g yeoman generator-code</span><br><span class="line">yo code myExtName</span><br><span class="line">// extension.js</span><br><span class="line">const vscode = require(&quot;vscode&quot;);</span><br><span class="line">exports.activate = function activate(ctx)&#123;&#125;</span><br><span class="line">exports.deactivate = function deactivate()&#123;&#125;</span><br><span class="line"></span><br><span class="line">//package.json</span><br><span class="line">engines : &#123; &quot;vscode&quot;: &quot;^1.29.0&quot; &#125;</span><br><span class="line">&quot;activationEvents&quot;: [ &quot;onCommand:extension.sayHello&quot; ]</span><br><span class="line">&quot;contributes&quot;: &#123; &quot;commands&quot;: [ &#123;&quot;command&quot;: &quot;extension.sayHello&quot;, &quot;title&quot;: &quot;Hello World&quot; &#125;]&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;命令面板&quot;&gt;&lt;a href=&quot;#命令面板&quot; class=&quot;headerlink&quot; title=&quot;命令面板&quot;&gt;&lt;/a&gt;命令面板&lt;/h1&gt;&lt;h2 id=&quot;常用&quot;&gt;&lt;a href=&quot;#常用&quot; class=&quot;headerlink&quot; title=&quot;常用&quot;&gt;&lt;/a&gt;常用&lt;/h
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>my tools</title>
    <link href="https://prief.github.io/2019/08/11/my-tools/"/>
    <id>https://prief.github.io/2019/08/11/my-tools/</id>
    <published>2019-08-11T03:13:12.000Z</published>
    <updated>2019-09-09T10:43:03.531Z</updated>
    
    <content type="html"><![CDATA[<h1 id="os"><a href="#os" class="headerlink" title="os"></a>os</h1><ul><li>git</li><li>iterm</li><li>wireshark</li></ul><h1 id="fe"><a href="#fe" class="headerlink" title="fe"></a>fe</h1><ul><li>chrome</li><li>vscode<ul><li>vscode-icons</li><li>markdown TOC</li><li>gitlens</li><li>debugger for chrome</li><li>code runner</li><li>Java Extension Pack</li><li>go</li><li>python</li><li>vetur</li><li>eslint</li></ul></li><li>node<ul><li></li></ul></li></ul><h1 id="android"><a href="#android" class="headerlink" title="android"></a>android</h1><ul><li>as</li></ul><h1 id="ios"><a href="#ios" class="headerlink" title="ios"></a>ios</h1><ul><li>homebrew</li><li>xcode</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;os&quot;&gt;&lt;a href=&quot;#os&quot; class=&quot;headerlink&quot; title=&quot;os&quot;&gt;&lt;/a&gt;os&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;git&lt;/li&gt;
&lt;li&gt;iterm&lt;/li&gt;
&lt;li&gt;wireshark&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;fe&quot;&gt;&lt;a 
      
    
    </summary>
    
    
      <category term="tools" scheme="https://prief.github.io/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>net protocol &amp; capature packets</title>
    <link href="https://prief.github.io/2019/08/11/net-protocol-capature-packets/"/>
    <id>https://prief.github.io/2019/08/11/net-protocol-capature-packets/</id>
    <published>2019-08-10T23:30:55.000Z</published>
    <updated>2019-08-15T13:54:34.340Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="协议栈"><a href="#协议栈" class="headerlink" title="协议栈"></a>协议栈</h2><ul><li>应用层<ul><li>http/1.1</li><li>websocket</li><li>http/2.0</li></ul></li><li>表示层<ul><li>tls/ssl</li></ul></li><li>传输层<ul><li>tcp</li></ul></li><li>网络层<ul><li>ip</li></ul></li><li>链路层<ul><li>以太网</li></ul></li></ul><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><ul><li>chrome</li><li>wireshark</li><li>dig</li><li>tcpdump</li></ul><h1 id="http-1-1"><a href="#http-1-1" class="headerlink" title="http/1.1"></a>http/1.1</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><ul><li>RFC: request for comments</li><li>http/1.1<ul><li>无状态</li><li>请求/响应模式</li><li>可扩展的语义</li><li>自描述的消息格式</li></ul></li><li>ABNF: 扩充巴科斯-瑙尔范式<ul><li>空白字符SP来分割各个元素</li><li>/表示可供选择的规则</li><li>%x##-##表示值的范围</li><li>()组合，视为一个元素</li><li>m*n表示重复m-n次</li><li>[]表示可选序列</li><li>DIGIT表示数字</li><li>HEXDIG表示十六进制数字</li><li>SP表示空格</li><li>CRLF表示兼容的回车换行</li></ul></li><li>OSI: open system interconnection reference model概念模型<ul><li>应用层（http/email/dns/smtp/ftp/telnet）</li><li>表示层（ssl）</li><li>会话层（session）</li><li>传输层（tcp/udp）</li><li>网络层（ip，广域网路由器）</li><li>数据链路层（mac，局域网交换机）</li><li>物理层</li></ul></li><li>TCP/IP 事实实现方案<ul><li>应用层（http/email/dns/smtp/ftp/telnet）</li><li>传输层（tcp/udp）</li><li>网络层（ip/icmp/arp）</li><li>物理层（ethernet）</li></ul></li><li>评估web架构的关键属性<ul><li>性能performance<ul><li>网络性能 throughput吞吐量&lt;=bandwidth</li><li>用户感知性能</li><li>网络效率 缓存/cdn/减少交互次数</li></ul></li><li>可伸缩性scalability</li><li>简单性simplicity</li><li>可见性visiable</li><li>可移植性portablity</li><li>可靠性reliability</li><li>可修改性modifiability<ul><li>可进化</li><li>可定制</li><li>可扩展</li><li>可配置</li><li>可重用</li></ul></li></ul></li><li>URI<ul><li>URI是URL+URN的超集，统一掉概念</li><li>schema://user:pass@hostname:port/path?query#fragment</li></ul></li><li>method<ul><li>GET</li><li>HEAD</li><li>POST</li><li>PUT</li><li>DELETE</li><li>CONNECT</li><li>OPTIONS</li><li>TRACE</li></ul></li><li>status<ul><li>1xx 请求服务器已经收到，需要进一步处理<ul><li>100 Continue常用上传大文件前</li><li>101 Switch Protocols升级协议ws/h2</li><li>102 Processing webdav协议</li></ul></li><li>2xx 成功处理了请求，当接收到不认识的2xx时默认用200<ul><li>200 OK</li><li>201 Created成功创建</li><li>202 Accepted</li><li>206 Partial Content 使用range协议返回部分内容</li></ul></li><li>3xx 重定向<ul><li>301 Moved Permanently 永久重定向，可被缓存</li><li>302 Found 临时重定向，不能被缓存</li><li>304 Not Modified 可复用缓存</li></ul></li><li>4xx 客户端错误<ul><li>400 Bad Request</li><li>401 Unauthorized未认证</li><li>403 Forbidden</li><li>404 Not Found</li></ul></li><li>5xx 服务端错误<ul><li>500 Internel Server Error 内部服务器错误，当接收到不认识的5xx时默认用500</li><li>501 Not Implemented</li><li>502 Bad Gateway</li><li>503 Service Unavailable</li><li>504 Gateway Timeout</li></ul></li></ul></li><li>长短连接 <ul><li>Connection: Keep-Alive | Close</li><li>http/1.1默认支持长连接</li><li>如果Connection后面跟header字段则表示对代理服务器要求不做此header转发</li><li>Connection只表示tcp连接的两端，不能表示跨中间的服务器</li></ul></li><li>header<ul><li>X-Forwarded-For 用于传递ip，每走一层都会append一个ip</li><li>X-Real-IP 只记录用户外网ip</li><li>Referer 来源，通常做防盗链</li><li>User-Agent</li><li>From 通常是爬虫添加的后面跟邮件地址告诉server可通过邮件联系</li><li>Allow server支持的method</li><li>Accept* 协商资源表现形式<ul><li>Accept: MIME q=0.8;</li><li>Accept-Language: zh-CN,zh q=0.8</li><li>Accept-Encoding: gzip | br | deflate</li><li>Accept-Range: bytes | none 是否支持range请求</li></ul></li><li>Transer-Encoding: chunked | gzip 不定长包体传输格式</li><li>Content-Disposition: inline | attachment[; filename=xx.xx]</li></ul></li><li>MIME<ul><li>Multipurpose Internet Mail Extensions</li><li>格式：type/subType(;params)</li><li>type<ul><li>text</li><li>image</li><li>audio</li><li>video</li><li>application</li></ul></li><li>params<ul><li>attribute=value</li></ul></li></ul></li><li>Form关键属性<ul><li>action表示uri</li><li>method表示方法<ul><li>GET</li><li>POST</li></ul></li><li>enctype<ul><li>application/x-www-form-urlencoded 默认编码方式 k=v&amp;k=v 需要encode</li><li>multipart/form-data 有boundary做分割，一般用于文件传输</li></ul></li></ul></li><li>Range请求<ul><li>做多线程下载/断点续传/点播视频等</li><li>请求头部标明<ul><li>Range: bytes=0-499[,500-1000[,1001-]]</li><li>Range: bytes=-4 最后3个字节</li><li>If-Range: Etag | httpDate 验证已经下载的部分是否有变动</li></ul></li><li>响应头部标明<ul><li>Content-Range: bytes 0-100/2000 表示共2000长度，返回了前101字节</li><li>Content-Range: bytes 0-100/* 表示不知道总长度但返回了前101字节  </li><li>Content-Range: multipart/byterages; boundary=…</li></ul></li></ul></li><li>cookie<ul><li>Set-Cookie<ul><li>每一个Set-Cookie只能设置一个name=value，如需多个需要多个Set-Cookie</li><li>name=value; expires= httpDate; max-age=X; domain=X; path=/; secure; httpOnly;</li></ul></li><li>Cookie<ul><li>可以把多个Set-Cookie返回的name组合成一个进行请求</li><li>name=value;[ name=value;]</li></ul></li></ul></li><li>同源三要素<ul><li>schema</li><li>hostname</li><li>port</li></ul></li><li>跨域<ul><li>可跨域的组件（满足可扩展可用性）<ul><li>script</li><li>link</li><li>img</li><li>iframe</li><li>video</li><li>audio</li></ul></li><li>攻击与防护<ul><li>csrf <ul><li>cross-site request forgery</li><li>通过referer可做一层防护</li><li>通过csrfToken即服务器响应表单时添加隐藏的token信息已备后续验证也可做防护</li></ul></li><li>xss cross-site scripting</li></ul></li><li>cors<ul><li>cross origin resource sharing</li><li>简单请求三要素<ul><li>GET/HEAD/POST之一</li><li>Accepte/Accept-Language/Content-Type安全header之一</li><li>Content-Type是text/plain|application/x-www-form-urlencoded|multipart/form-data之一</li></ul></li><li>复杂请求<ul><li>简单请求之外的都是复杂请求</li><li>复杂请求必须先走一个OPTIONS请求</li></ul></li><li>请求相关头部<ul><li>Origin</li><li>Access-Control-Request-Method</li><li>Access-Control-Request-Headers</li></ul></li><li>响应相关头部<ul><li>Access-Control-Allow-Origin</li><li>Access-Control-Allow-Methods</li><li>Access-Control-Allow-Headers</li><li>Access-Control-Allow-Credentials</li><li>Access-Control-Max-Age</li></ul></li></ul></li></ul></li><li>缓存<ul><li>优先级<ul><li>s-maxage</li><li>max-age</li><li>Expires</li><li>预估过期时间（浏览器实现实现的”10%算法”）</li></ul></li><li>Cache-Control<ul><li>请求中<ul><li>max-age=t | max-stale=t | min-fresh=t </li><li>no-store | no-cache | no-transform | only-if-cached</li></ul></li><li>响应中<ul><li>must-revalidate | proxy-revalidate</li><li>public | private </li><li>no-cache | no-store | no-transform</li></ul></li></ul></li></ul></li><li>重定向<ul><li>301 http/1.0 永久重定向，可以被缓存，重定向后的请求可以改变method，通常使用get</li><li>302 http/1.0 临时重定向，不可被缓存，重定向后的请求可以改变method，通常使用get</li><li>307 http/1.1 临时重定向，不可被缓存，重定向后的请求不能改变method</li><li>308 http/1.1 永久重定向，可以被缓存，重定向后的请求不能改变method</li></ul></li><li>隧道<ul><li>tunnel通过http连接来传输非http协议格式的数据</li><li>常用于穿越防火墙/传递ssl消息</li><li>通过connect建立连接后变为双向传输，不必遵守http协议</li></ul></li><li>爬虫<ul><li>robots.txt<ul><li>User-Agent 允许哪些机器人</li><li>Disallow 禁止哪些目录</li><li>Crawl-delay 访问间隔防止流量过大</li><li>Allow 允许哪些目录</li><li>Sitemap 站点地图</li></ul></li></ul></li></ul><h2 id="dns"><a href="#dns" class="headerlink" title="dns"></a>dns</h2><ul><li>域名与ip之间的映射数据库</li><li>查询方式<ul><li>迭代查询</li><li>递归查询</li></ul></li><li>query<ul><li>questions<ul><li>QNAME<ul><li>.分割多段，每段字节数打头再跟其ASCII编码</li><li>最终以 00 结尾</li></ul></li><li>QTYPE<ul><li>1 A ipv4地址</li><li>2 NS 权威域名服务器</li><li>5 CNAME 别名</li><li>28 AAAA ipv6地址</li></ul></li><li>QCLASS<ul><li>IN 表示internet</li></ul></li></ul></li></ul></li><li>response<ul><li>NAME</li><li>TTL time to live</li><li>RDLENGTH RDATA length</li><li>RDATA 查询值，如ip或CNAME值</li></ul></li></ul><h1 id="wireshark"><a href="#wireshark" class="headerlink" title="wireshark"></a>wireshark</h1><h2 id="BPF过滤器"><a href="#BPF过滤器" class="headerlink" title="BPF过滤器"></a>BPF过滤器</h2><ul><li>Berkeley Packet Filter</li><li>在设备驱动级别提供抓包接口</li><li>表达式<ul><li>原语<ul><li>Type: host port portrange…</li><li>Dir: dst src…</li><li>proto: tcp udp…</li></ul></li><li>操作符<ul><li>&amp;&amp; and</li><li>|| or</li><li>! not</li></ul></li></ul></li></ul><h2 id="独有的显示过滤器"><a href="#独有的显示过滤器" class="headerlink" title="独有的显示过滤器"></a>独有的显示过滤器</h2><ul><li>view -&gt; internels -&gt; support protocols</li><li>操作符<ul><li>eq ==</li><li>ne !=</li><li>gt &gt;</li><li>ge &gt;=</li><li>lt &lt;</li><li>le &lt;=</li><li>contains</li><li>matches ~</li></ul></li><li>函数<ul><li>upper</li><li>lower</li><li>len</li><li>count</li><li>string</li></ul></li></ul><h1 id="websocket"><a href="#websocket" class="headerlink" title="websocket"></a>websocket</h1><h2 id="基础-1"><a href="#基础-1" class="headerlink" title="基础"></a>基础</h2><ul><li>demo页面：<a href="http://www.websocket.org" target="_blank" rel="noopener">http://www.websocket.org</a></li><li>客户端发送数据要进行掩码处理防止针对代理服务器的缓存污染攻击</li><li>pingpong心跳保持会话</li><li>优点<ul><li>浏览器支持率比较高</li><li>支持服务器推送</li></ul></li><li>不足<ul><li>设计比较简单，很多功能和性能上的问题没有真正解决</li></ul></li></ul><h2 id="握手"><a href="#握手" class="headerlink" title="握手"></a>握手</h2><img src="/2019/08/11/net-protocol-capature-packets/handshake.png" title="websocket握手包头"><h2 id="解密tls"><a href="#解密tls" class="headerlink" title="解密tls"></a>解密tls</h2><ul><li>通过浏览器DEBUG日志获得tls握手阶段生成的密钥</li><li>步骤<ul><li>配置环境变量SSLKEYLOGFILE=path2log使chrome输出DEBUG日志</li><li>wireshark配置解析DEBUG日志(编辑/首选项/protocols/tls)</li></ul></li></ul><h1 id="http2"><a href="#http2" class="headerlink" title="http2"></a>http2</h1><h2 id="基础-2"><a href="#基础-2" class="headerlink" title="基础"></a>基础</h2><ul><li>http1.1的问题<ul><li>高延迟<ul><li>带宽在增加，延迟却没办法降低</li><li>浏览器并发限制</li><li>同一连接串行处理请求</li></ul></li><li>无状态特性带来了巨大的http头部</li><li>不支持服务器推送</li></ul></li><li>h2主要特性<ul><li>传输数据量大幅减小<ul><li>标头压缩</li><li>二进制传输</li></ul></li><li>多路复用并支持优先级</li><li>服务器推送</li><li>必须使用tls</li></ul></li><li>tls握手通讯过程<ul><li>验证身份</li><li>达成安全套件共识</li><li>传递密钥</li><li>加密通讯</li></ul></li><li>h2核心概念<ul><li>连接connection</li><li>数据流stream<ul><li>通过stream实现多路复用</li></ul></li><li>消息message<ul><li>header帧</li><li>data帧</li></ul></li><li>数据帧frame</li></ul></li></ul><h2 id="frame"><a href="#frame" class="headerlink" title="frame"></a>frame</h2><ul><li>帧头部<img src="/2019/08/11/net-protocol-capature-packets/frameHeader.png" title="帧头部"></li><li>作用<ul><li>多路复用(同一stream内的frame必须是有序的，接收端根据streamID并发组装消息)</li><li>客户端建立的流必须是奇数，服务端建立的是偶数</li><li>状态管理的约束(ID不能复用，只能递增，超出最大值后必须断掉tcp连接重新建立)</li></ul></li><li>帧类型type<ul><li>DATA</li><li>HEADERS</li><li>PRIORITY</li><li>RST_STREAM</li><li>SETTINGS</li><li>PUSH_PROMISE</li><li>PINNG</li><li>GOAWAY</li><li>WINDOW_UPDATE</li><li>CONTINUATION</li></ul></li><li>hpack<ul><li>头部压缩算法</li><li>三种压缩方式相结合<ul><li>静态字典</li><li>动态字典</li><li>压缩算法huffman编码</li></ul></li></ul></li></ul><h2 id="服务推送"><a href="#服务推送" class="headerlink" title="服务推送"></a>服务推送</h2><ul><li>每一条推送都基于一个请求</li><li>在请求的响应中可以恢复即将推送的资源</li><li>再开一个stream进行资源的推送，不同的stream可以实现并发</li></ul><h2 id="流控"><a href="#流控" class="headerlink" title="流控"></a>流控</h2><ul><li>应用层和tcp层都可以做</li><li>发送和接口流量控制是可以分开作用的</li><li>只有DATA帧才受流控限制</li><li>流控不能被禁用</li></ul><h2 id="h2现存问题"><a href="#h2现存问题" class="headerlink" title="h2现存问题"></a>h2现存问题</h2><ul><li>tcp+tls建链握手过多<ul><li>必须建立在tls之上</li></ul></li><li>多路复用与tcp队头阻塞问题<ul><li>本质还是在tcp流中是串行的</li><li>串行对头中丢失一个包就会阻塞后面的包</li></ul></li><li>tcp是由操作系统内核实现的，内核更新慢</li></ul><h2 id="http3"><a href="#http3" class="headerlink" title="http3"></a>http3</h2><ul><li>基于quick协议与h2协议共同成为h3</li><li>quick协议基于udp/ip协议之上，h2协议之下</li><li>quick协议实现了<ul><li>多路复用</li><li>tls</li><li>拥塞控制</li><li>丢包重发</li></ul></li><li>优势<ul><li>可以连接迁移</li><li>解决了队头阻塞问题</li><li>1RTT完全就握手完毕</li></ul></li></ul><h1 id="tls"><a href="#tls" class="headerlink" title="tls"></a>tls</h1><h2 id="基础-3"><a href="#基础-3" class="headerlink" title="基础"></a>基础</h2><ul><li>概念<ul><li>ssl secure sockets layer</li><li>tls transport layer security</li></ul></li><li>发展历史<ul><li>ssl3.0</li><li>tls1.0</li><li>tls1.1</li><li>tls1.2</li><li>tls1.3</li></ul></li><li>设计目的<ul><li>身份验证</li><li>保密性</li><li>完整性</li></ul></li><li>主要功能<ul><li>握手</li><li>交换密钥</li><li>告警</li><li>对称加密数据</li><li>记录</li></ul></li><li>tls握手通讯过程<ul><li>验证身份</li><li>达成安全套件共识</li><li>传递密钥</li><li>加密通讯</li></ul></li><li>安全加密套件<ul><li>TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256</li><li>ECDHE 密钥交换算法</li><li>RSA 身份验证算法</li><li>AES 对称加密算法</li><li>128 对称加密强度</li><li>GCM 对称加密模式</li><li>SHA256 签名hash算法</li></ul></li></ul><h2 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h2><ul><li>工作原理<ul><li>XOR运算 速度快</li><li>padding填充 <ul><li>会把明文进行blockCipher分组进行加密</li><li>当分组后最后一个block可能长度不够XOR运算，需要padding</li><li>填充时可以按bit位进行填充也可按byte字节填充</li><li>RFC中常用按byte字节进行填充，填充内容是多少个字节就填充多少个数字，即PKCS7填充算法</li></ul></li><li>工作模式<ul><li>常用GCM工作模式</li><li>Galois/Counter Mode</li></ul></li></ul></li><li>AES<ul><li>advanced encryption standard加密算法</li><li>常用填充算法PKCS7</li><li>常用工作模式GCM</li><li>三种密钥长度<ul><li>AES-128密钥长度16字节，加密轮数10</li><li>AES-192密钥长度24字节，加密轮数12</li><li>AES-256密钥长度32字节，加密轮数14</li></ul></li><li>加密步骤<ul><li>明文按照16字节拆分成若干块，每个块是4*4矩阵</li><li>按填充算法进行最后一块的填充</li><li>每一个明文块用AES加密算法和密钥进行加密</li><li>拼接所有密文块</li></ul></li></ul></li></ul><h2 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h2><ul><li>RSA </li><li>openssl<ul><li>生成私钥 openssl genrsa -out private.pem</li><li>提取公钥 openssl rsa -in private.pem -pubout -out public.pem</li><li>加密文件 openssl rsautl -encrypt -in hello.txt -inkey public.pem -pubin -out hello.en </li><li>解密文件 openssl rsautl -decrypt -in hello.en -inkey private.pem -out hello.de</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;h2 id=&quot;协议栈&quot;&gt;&lt;a href=&quot;#协议栈&quot; class=&quot;headerlink&quot; title=&quot;协议栈&quot;&gt;&lt;/a&gt;协议栈&lt;/h2&gt;&lt;u
      
    
    </summary>
    
    
      <category term="wireshark" scheme="https://prief.github.io/tags/wireshark/"/>
    
      <category term="tcp/ip" scheme="https://prief.github.io/tags/tcp-ip/"/>
    
  </entry>
  
  <entry>
    <title>spring boot &amp; k8s</title>
    <link href="https://prief.github.io/2019/08/10/spring-boot-k8s/"/>
    <id>https://prief.github.io/2019/08/10/spring-boot-k8s/</id>
    <published>2019-08-10T15:01:19.000Z</published>
    <updated>2019-08-17T03:01:46.852Z</updated>
    
    <content type="html"><![CDATA[<p>记录spring boot &amp; k8s学习过程 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;记录spring boot &amp;amp; k8s学习过程 &lt;/p&gt;

      
    
    </summary>
    
    
      <category term="spring" scheme="https://prief.github.io/tags/spring/"/>
    
      <category term="k8s" scheme="https://prief.github.io/tags/k8s/"/>
    
  </entry>
  
</feed>
