<!DOCTYPE HTML>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  
  <title>prief | about share and go on</title>

  
  <meta name="author" content="prief">
  

  

  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  

  <meta property="og:site_name" content="prief">

  
  <meta property="og:image" content="/favicon.ico">
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="prief" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
</head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">prief</a>
    </h1>
    <p class="site-description">about share and go on</p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">Home</a></li>
      
        <li><a href="/tags">Tags</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    
  <article>

  
    
    <h3 class="article-title"><a href="/2020/04/12/rpc021/"><span>rpc021</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2020/04/12/rpc021/" rel="bookmark">
        <time class="entry-date published" datetime="2020-04-12T14:14:35.000Z">
          2020-04-12
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h3 id="rpc"><a href="#rpc" class="headerlink" title="rpc"></a>rpc</h3><ul>
<li>remote procedure call 远程过程调用</li>
<li>允许本地计算机调用远程计算机上的程序，不需要了解底层网络细节，整个过程就像调用本地一样</li>
<li>目的就是解决http超文本传输协议效率低</li>
<li>常见的是java的dubbo和google的grpc</li>
<li>框架涉及面<ul>
<li>网络通信</li>
<li>超时机制</li>
<li>协议</li>
<li>序列化</li>
<li>打解包/编解码</li>
<li>连接池</li>
<li>拦截器</li>
<li>服务发现</li>
<li>负载均衡</li>
<li>分布式链路追踪</li>
<li>监控</li>
<li>日志</li>
<li>认证鉴权</li>
<li>并发处理</li>
<li>性能</li>
<li>组件化</li>
<li>插件体系</li>
</ul>
</li>
<li>框架架构图<img src="/2020/04/12/rpc021/rpc.png" title="框架架构图"></li>
</ul>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2020/04/05/archi-jike/"><span>archi-jike</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2020/04/05/archi-jike/" rel="bookmark">
        <time class="entry-date published" datetime="2020-04-04T23:53:24.000Z">
          2020-04-05
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul>
<li>软件架构是有关软件整体结构与组件的抽象描述，用于指导软件系统各个方面的设计</li>
<li>目标<ul>
<li>高性能</li>
<li>高可用</li>
<li>可扩展</li>
</ul>
</li>
<li>分层<ul>
<li>访问层</li>
<li>网关层</li>
<li>服务层</li>
<li>存储层</li>
<li>监控/限流/降级<h3 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h3></li>
</ul>
</li>
<li>目的<ul>
<li>分而治之</li>
<li>各司其职</li>
</ul>
</li>
<li>常见分层<ul>
<li>计算机OSI7层模型</li>
<li>web系统的mvc/mvvm模型</li>
<li>基于领域模型的分层(电商系统…)</li>
</ul>
</li>
<li>演进<ul>
<li>servletJSP时代<ul>
<li>servlet+tomcat完成web接入</li>
<li>javaBean+JDBC完成数据层接入</li>
<li>JSP完成页面展示</li>
</ul>
</li>
<li>SSH<ul>
<li>strutsMVC完成web接入JSP完成表示层</li>
<li>spring完成业务逻辑/会话管理</li>
<li>hibernate完成数据存储接入和持久化</li>
</ul>
</li>
<li>SSM<ul>
<li>springMVC更适用前后端分离</li>
<li>spring支持注解/配置声明式事务处理</li>
<li>mybatis配置缓存/解耦数据库对象和java对象</li>
</ul>
</li>
<li>SpringBoot<ul>
<li>整合了spring所有框架，提供allInOne服务</li>
<li>提供简单的配置和注解的接入方式</li>
</ul>
</li>
<li>分布式分层</li>
</ul>
</li>
<li>亿级流量平台分层架构<ul>
<li>功能<ul>
<li>水平扩展</li>
<li>负载均衡</li>
<li>高可用</li>
<li>数据一致性</li>
</ul>
</li>
<li>分层(需要每一层都能分布式)<ul>
<li>访问层，用于web接入/反向代理/负载均衡</li>
<li>网关层，用于业务api</li>
<li>服务层，具备服务治理/调度/异步通信等</li>
<li>存储层(存储接入层/存储层)，用于提供透明的存储结构的访问代理和数据落地能力</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="访问层"><a href="#访问层" class="headerlink" title="访问层"></a>访问层</h3><ul>
<li>lvs<ul>
<li>采用ip负载均衡技术和基于内容请求分发技术做的负载均衡</li>
<li>概念<ul>
<li>CIP clientIP</li>
<li>DIP directorIP</li>
<li>RIP realServerIP</li>
</ul>
</li>
<li>模式<ul>
<li>NAT<ul>
<li>networkAddressTranslation网络地址转换</li>
<li>CIP-&gt;DIP-&gt;RIP-&gt;DIP-&gt;CIP(lvs两次SNAT/DNAT)</li>
<li>进出流量都走lvs,部署和配置比较简单，但lvs始终要维护两端的socket连接,可能会成为瓶颈</li>
</ul>
</li>
<li>DR<ul>
<li>directRouting直接路由</li>
<li>CIP-&gt;DIP-&gt;RIP-&gt;CIP(要修改DIP-&gt;RIP时的mac地址)</li>
<li>响应流量不走lvs,减少lvs始终维护两端socket的性能开销,但要求DIP和RIP要在同一机房</li>
<li>通常使用此模式，在同一机房也会有很高的性能</li>
</ul>
</li>
<li>TUN<ul>
<li>tunneling隧道</li>
<li>CIP-&gt;DIP-&gt;RIP-&gt;CIP(在DIP发送到RIP时做了二次封装,RIP拿到包后要二次解析)</li>
<li>响应流量不走lvs,同时DIP和RIP也不一定要在同一机房,但要求RS必须支持隧道模式即要二次解析IP包</li>
</ul>
</li>
</ul>
</li>
<li>调度策略<ul>
<li>轮询/权重轮询</li>
<li>最少连接/权重最少连接</li>
<li>ip_hash/ip_hash_group/url_hash/url_hash_group…</li>
</ul>
</li>
<li>优势<ul>
<li>ip层的负载均衡,没有应用层回调的消耗，性能高</li>
<li>通过DR/TUN模式使响应不走lvs</li>
<li>支持后端心跳检测,自动故障转移恢复</li>
<li>配合主从keepAlive和VIP实现自身高可用</li>
</ul>
</li>
</ul>
</li>
<li>nginx<ul>
<li>功能<ul>
<li>请求解析(http/https)</li>
<li>负载均衡(应用层)</li>
<li>缓存调度</li>
<li>授权认证</li>
<li>接入处理(过滤非法请求)</li>
<li>业务逻辑</li>
<li>响应处理</li>
<li>压缩技术</li>
</ul>
</li>
<li>职责分类<ul>
<li>接入层nginx</li>
<li>应用层nginx(缓存调度/业务逻辑/限流降级)</li>
</ul>
</li>
<li>高性能原因<ul>
<li>master-worker进程模型<ul>
<li>master进程系统调用<ul>
<li>socket()</li>
<li>bind()</li>
<li>listen()</li>
<li>fork()</li>
</ul>
</li>
<li>worker进程系统调用<ul>
<li>accept()</li>
<li>recv()</li>
<li>send()</li>
<li>close()</li>
</ul>
</li>
</ul>
</li>
<li>异步模型<ul>
<li>select(缺点:只能并发1024个请求/低效的遍历性能消耗)</li>
<li>epoll(linux2.6后实现的事件机制,解决了上面2个问题)</li>
</ul>
</li>
<li>流式处理请求workflow,有主子请求</li>
<li>协程机制解决worker上不能有阻塞操作<ul>
<li>协程<ul>
<li>栈/局部变量在用户空间模拟，切换开销小</li>
<li>协程间是协作关系</li>
<li>临界区不需要加锁</li>
<li>遇到阻塞主动放弃切换</li>
</ul>
</li>
<li>线程<ul>
<li>栈/局部变量是内核空间的映射，切换开销大</li>
<li>多线程并发运行是竞争cpu关系</li>
<li>临界区需要同步加锁</li>
<li>遇到阻塞进入等待cpu切换</li>
</ul>
</li>
</ul>
</li>
<li>nginx lua</li>
</ul>
</li>
<li>具体应用<ul>
<li>负载均衡<ul>
<li>upstream</li>
<li>proxy_pass</li>
</ul>
</li>
<li>代理缓存(先要有后端的代理才能使用代理缓存)<ul>
<li>proxy_cache_path PATH levels=1:2 keys_zone=NAME:100m inactive=7d max_size=100g;<ul>
<li>把缓存文件放在PATH中</li>
<li>levels=1:2 缓存文件目录层级和目录名称长度</li>
<li>keys_zone 指定了一个内存空间，并设置大小来缓存key与缓存文件目录的映射关系</li>
<li>inactive=7d 缓存文件7天后失效淘汰</li>
<li>max_size=100g 缓存文件总大小超过100g后释放淘汰</li>
</ul>
</li>
<li>使用<ul>
<li>proxy_cache NAME; # 使用缓存空间</li>
<li>proxy_cache_valid 200 206 302 304 10d; # 后端返回以下响应码时缓存多久</li>
<li>proxy_cache_key $uri; # 一般使用$uri作为缓存的key;</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="网关层"><a href="#网关层" class="headerlink" title="网关层"></a>网关层</h3><ul>
<li>分布式会话管理<ul>
<li>会话机制<ul>
<li>session<ul>
<li>通过判断SID里是否包含用户信息判定用户是否登陆</li>
<li>依赖后端的session容器和前端的cookie，无法解决cookie跨域和禁用的问题</li>
</ul>
</li>
<li>cookie<ul>
<li>后端验证用户信息后将凭证做数字签名，加密后写入cookie的ticket，验证时取出ticket解密判断</li>
<li>不依赖后端session容器但也没有解决cookie跨域和禁用的问题</li>
</ul>
</li>
<li>token<ul>
<li>后端验证用户信息后将凭证做数字签名，加密后写入token返回前端，前端请求时参数或header中携带token</li>
<li>不依赖cookie，但需要请求时携带token</li>
</ul>
</li>
</ul>
</li>
<li>安全问题<ul>
<li>cookie被劫持，xss/csrf安全攻击</li>
<li>token凭证被劫持，伪造</li>
</ul>
</li>
<li>解决方式<ul>
<li>https</li>
<li>风控系统主动失效及过期机制</li>
</ul>
</li>
<li>分布式会话管理<ul>
<li>登陆凭证放入集中的会话管理redis/memcached</li>
<li>对应session的处理机制要重写</li>
</ul>
</li>
</ul>
</li>
<li>接入层控制<ul>
<li>控制内容<ul>
<li>身份验证<ul>
<li>通过会话管理获取用户登陆凭证</li>
<li>通过用户凭证获取用户信息</li>
<li>验证对应的url/资源是否可以被用户访问</li>
</ul>
</li>
<li>流量控制<ul>
<li>对应url流量是否可以被承载否则限流(filter的pre/post进行计数即可实现)</li>
<li>对应服务分级的流量是否被承载</li>
<li>对应整个系统的总流量是否被承载</li>
</ul>
</li>
<li>路由服务<ul>
<li>根据url规则找到对应的服务</li>
<li>判断服务的状态，做服务路由调用</li>
</ul>
</li>
<li>记录调试或统计信息</li>
</ul>
</li>
<li>通过接入层框架的通用的filter功能实现<ul>
<li>javaServletFilter</li>
<li>springMVCHandlerInterceptor</li>
<li>zuulFilter</li>
</ul>
</li>
</ul>
</li>
<li>服务调用及聚合<ul>
<li>如果需要多个后端服务调用则需要在网关层这里做聚合</li>
<li>分类<ul>
<li>重接入<ul>
<li>springMVC+dubbo</li>
<li>优点：可灵活的在controller层处理业务逻辑，聚合服务</li>
<li>缺点：服务的单一性不够，后端服务不便管理</li>
</ul>
</li>
<li>轻接入<ul>
<li>zuul</li>
<li>优点：服务单一，接入控制可以页面配置</li>
<li>缺点：聚合能力不够，需要后端提供</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="核心服务层之服务通信"><a href="#核心服务层之服务通信" class="headerlink" title="核心服务层之服务通信"></a>核心服务层之服务通信</h3><ul>
<li>微服务<ul>
<li>传统服务缺点<ul>
<li>所有服务耦合在一起</li>
<li>隔离型弱，互相影响</li>
<li>部署臃肿</li>
<li>开发维护困难</li>
</ul>
</li>
<li>微服务<ul>
<li>特性<ul>
<li>高内聚,低耦合,专注自己的核心业务</li>
<li>隔离型强,不会相互影响(进程上)</li>
<li>轻量的通信机制</li>
<li>独立开发,单独部署</li>
</ul>
</li>
<li>需要解决的问题<ul>
<li>服务治理(服务注册和发现,负载均衡和智能容错,服务监控和健康管理,限流降级熔断)</li>
<li>数据一致性</li>
<li>调用性能</li>
<li>研发流程调试,部署,测试</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>dubbo服务治理<ul>
<li>来解决微服务服务治理的轻量级开源javaRPC框架</li>
<li>核心能力<ul>
<li>面向接口的远程方法调用</li>
<li>服务自动注册和发现</li>
<li>负载均衡和智能容错</li>
</ul>
</li>
</ul>
</li>
<li>异步消息服务<ul>
<li>分类<ul>
<li>JMS(apacheActiveMQ)</li>
<li>Kafka(流式处理)</li>
<li>RocketMQ(alibaba基于Kafka开发的分布式一致性服务)</li>
</ul>
</li>
<li>JMS<ul>
<li>javaMessageService</li>
<li>特点<ul>
<li>点对点(每个消息都被发送到特定的队列,接收者从队列中顺序消费,队列保留着消息直到被消费或超时)</li>
<li>发布订阅(客户端将消息发到主题,消息队列存放主题,订阅者消费主题)</li>
</ul>
</li>
<li>activeMQ缺点<ul>
<li>以消息为单位,为保证消息稳定性需要落盘,但可能落盘时不连续,磁盘寻值有性能问题</li>
<li>消费时是推模式,对consumer的线程压力非常大</li>
</ul>
</li>
</ul>
</li>
<li>Kafka<ul>
<li>默认支持点对点，但不常用，常用发布订阅</li>
<li>客户端将消息发到主题,消息队列存放主题,订阅者消费主题,消息持久化到队尾,消费通过客户端指针,吞吐量高</li>
<li>比activeMQ优点<ul>
<li>引入broker概念把相同topic的消息连续的落到同一个文件,保证磁盘IO性能</li>
<li>消费时是拉模式,根据consumer性能决定消费速度</li>
<li>引入了nameServer类似zookeeper的组件和队列/失败重试队列来保证消息稳定可靠</li>
</ul>
</li>
</ul>
</li>
<li>RocketMQ<ul>
<li>结合了Kafka和ActiveMQ的优点,把Kafka很多的api封装成类似ActiveMQ简单易用</li>
<li>消息队列维护高可用,并支持事务回溯机制(增加了prepare队列)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="核心服务层之调度-池化"><a href="#核心服务层之调度-池化" class="headerlink" title="核心服务层之调度/池化"></a>核心服务层之调度/池化</h3><ul>
<li>任务调度<ul>
<li>应用场景<ul>
<li>业务跑批轮询等待处理</li>
<li>失败的异常重试</li>
<li>定时任务处理</li>
</ul>
</li>
<li>单机实现方式<ul>
<li>Timer定时器机制<ul>
<li>java自带，比较简单</li>
<li>所有任务都在同一个线程中串行执行，同一时间只能执行一个任务，不适合多线程并发多任务</li>
</ul>
</li>
<li>ScheduledExecutor<ul>
<li>内置了线程池，解决Timer单线程的问题</li>
<li>任务数不能超过线程池数，否则也会相互影响</li>
</ul>
</li>
<li>Quartz<ul>
<li>包含任务JobDetail类和调度Trigger类</li>
<li>定时检测到任务后Job会在线程池中申请线程执行</li>
</ul>
</li>
</ul>
</li>
<li>分布式调度方式及实现<ul>
<li>Quartz分布式版本<ul>
<li>部署机器的时间一致</li>
<li>部署的代码一致</li>
<li>需要中间层同步竞争锁(数据库)</li>
</ul>
</li>
<li>Elasticsearch-Job分片分布式<ul>
<li>借鉴了竞争锁的机制,不过使用zookeeper实现</li>
<li>自己实现了任务是否分片，解决大job问题</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>池化技术<ul>
<li>通过复用减少系统消耗，提升系统性能</li>
<li>分类<ul>
<li>对象池<ul>
<li>利用复用对象减少创建对象/垃圾回收的开销</li>
<li>例如线程池通过复用线程提升性能</li>
</ul>
</li>
<li>连接池<ul>
<li>数据库连接池/redis连接池/http连接池</li>
<li>通过复用tcp连接减少创建和释放连接的时间</li>
</ul>
</li>
</ul>
</li>
<li>实战<ul>
<li>java线程池<ul>
<li>核心/最小线程数大小(任务进来后首选核心线程)</li>
<li>等待队列长度(核心线程都busy时新进的任务进等待队列)</li>
<li>最大线程数大小(等待队列也满了又有新进的任务则开启新线程,等待队列出对执行)</li>
<li>拒绝策略(达到最大线程后又有新进的任务则会按拒绝策略执行,分为被动等待或直接报错)</li>
<li>idle等待时间(弹性线程空闲等待时间后会回收)</li>
</ul>
</li>
<li>连接池(数据库/redis/httpClient)<ul>
<li>连接状态<ul>
<li>init</li>
<li>connect</li>
<li>busy</li>
<li>close</li>
</ul>
</li>
<li>核心连接数</li>
<li>最大连接数</li>
<li>连接等待时间(tcp/ip建连时间)</li>
<li>数据读取时间</li>
<li>idle等待时间(弹性连接空闲等待时间后会释放)</li>
<li>validate<ul>
<li>获取连接时</li>
<li>使用连接时(常用)</li>
<li>释放连接时</li>
</ul>
</li>
</ul>
</li>
<li>tomcat线程/连接池<ul>
<li>客户端连接池</li>
<li>io线程池</li>
<li>worker线程池</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="核心服务层之缓存-隔离-队列"><a href="#核心服务层之缓存-隔离-队列" class="headerlink" title="核心服务层之缓存/隔离/队列"></a>核心服务层之缓存/隔离/队列</h3><ul>
<li>缓存<ul>
<li>设计原则<ul>
<li>存储设备读写速度最快(cpu/内存)</li>
<li>数据离应用最近(业务服务器/局域网/机房)</li>
<li>数据离用户最近(app/CDN/nginx缓存/api网关/核心业务redis)</li>
</ul>
</li>
<li>分类<ul>
<li>CDN缓存</li>
<li>反向代理缓存 nginxProxyCache</li>
<li>分布式缓存 redis</li>
<li>本地应用缓存 JVM Guava</li>
</ul>
</li>
</ul>
</li>
<li>隔离<ul>
<li>硬件隔离(虚拟机)</li>
<li>操作系统隔离(容器虚拟化)</li>
<li>进程隔离(系统拆分)</li>
<li>线程隔离(线程池独立)</li>
<li>读写隔离</li>
<li>动静隔离</li>
<li>冷热隔离(热点账户/热点数据)</li>
</ul>
</li>
<li>队列<ul>
<li>先进先出的线性表</li>
<li>用途<ul>
<li>异步处理</li>
<li>系统解耦</li>
<li>流量削峰<ul>
<li>排队有时候会比并发效率更高</li>
<li>排队可以控制并发流量开关/大小</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="数据存储层"><a href="#数据存储层" class="headerlink" title="数据存储层"></a>数据存储层</h3><ul>
<li>数据存储<ul>
<li>分类<ul>
<li>传统IT<ul>
<li>excel提供简单的关系存储</li>
<li>磁盘提供文件存储</li>
<li>sql数据库提供关系型存储</li>
</ul>
</li>
<li>互联网行业<ul>
<li>分布式存储需要无限可扩展的网络文件系统</li>
<li>关系型数据库需要提供事务一致性的保证</li>
<li>非关系型数据库需要提供更高性能的简化存储</li>
<li>磁盘和内存需要性能和稳定中间权衡</li>
</ul>
</li>
</ul>
</li>
<li>数据结构<ul>
<li>结构化数据(表,有完备的模式)</li>
<li>非结构化数据(音视频文件等)</li>
<li>半结构化数据(xml表示简历格式)</li>
</ul>
</li>
<li>数据库结构<ul>
<li>关系型数据库</li>
<li>非关系型数据库</li>
</ul>
</li>
<li>选型<ul>
<li>非结构化数据选择网络文件系统/网络磁盘</li>
<li>结构化数据根据是否需要SQL和关系事务的支持<ul>
<li>关系型数据库</li>
<li>非关系型数据库(磁盘非关系/内存非关系)</li>
</ul>
</li>
<li>半结构化数据<ul>
<li>首先使用XML或JSON等可扩展的结构化数据进行描述</li>
<li>然后根据是否落地选择非关系型数据库</li>
</ul>
</li>
</ul>
</li>
<li>常用<ul>
<li>NAS <ul>
<li>network attached storage网络附属存储</li>
<li>网络文件系统,基底层设备,提供文件磁盘</li>
<li>有cpu/内存/网络接入端口/磁盘插槽</li>
</ul>
</li>
<li>OSS<ul>
<li>object storage service</li>
<li>基于bucket管理网络文件</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>关系型与非关系型<ul>
<li>关系型数据库mysql<ul>
<li>关系型存储格式,如表</li>
<li>非主键字段依赖索引提高查询速度,查询需要快照和锁机制</li>
<li>事务保障效率高<ul>
<li>set autocommit=0;</li>
<li>begin;</li>
<li>SQL;</li>
<li>commit;</li>
</ul>
</li>
<li>可以使用join进行复杂查询</li>
</ul>
</li>
<li>非关系型数据库mongoDB<ul>
<li>kv存储格式</li>
<li>通常使用k查询,对应关系型的主键,比索引更快,大多使用单线程存储,无需锁</li>
<li>没有事务的概念</li>
<li>对复杂查询的能力较弱但场景也比较少</li>
<li>mongoDB<ul>
<li>是非关系型数据库中功能最丰富,最像关系型数据库的非关系型数据库</li>
<li>数据结构非常松散,类似JSON的BSON格式</li>
<li>db.NAME.find().pretty()/insert()/update()/remove()/createIndex()/sort()/limit()/skip()</li>
</ul>
</li>
<li>redis<ul>
<li>用作数据库/高速缓存/消息队列代理</li>
<li>支持字符串/哈希表/列表/集合/有序集合/位图等数据类型</li>
<li>内置复制/LRU淘汰回收/事务及不同级别的磁盘持久化功能</li>
<li>通过Redis Sentinel提供高可用</li>
<li>通过Redis Cluster提供自动分区</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>代理访问层<ul>
<li>代理对象分类<ul>
<li>nginx反向代理</li>
<li>mycat代理mysql</li>
<li>twemproxy代理redis/redis4自带的redisCluster也可支持代理</li>
</ul>
</li>
<li>代理作用<ul>
<li>集中收口</li>
<li>负载均衡</li>
<li>故障转移</li>
<li>路由策略</li>
<li>缓存策略</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="监控-限流-降级"><a href="#监控-限流-降级" class="headerlink" title="监控/限流/降级"></a>监控/限流/降级</h3><ul>
<li>监控<ul>
<li>指标<ul>
<li>硬件(zabbix监控)<ul>
<li>CpuIdleTime</li>
<li>FreeMemory</li>
<li>IOWait</li>
<li>NetworkFree</li>
</ul>
</li>
<li>软件(cat heartbeat监控)<ul>
<li>CpuLoadAverage</li>
<li>ParNewCount</li>
<li>ParNewTime</li>
<li>OldGCCount</li>
<li>OldGCTime</li>
</ul>
</li>
<li>接口(cat transaction监控)<ul>
<li>url/dubbo failure times</li>
<li>9X线(95%Line/99.9%Line/99.99%Line)</li>
</ul>
</li>
<li>异常(cat exception监控)<ul>
<li>ExceptionTimesAndContent</li>
</ul>
</li>
<li>大盘(cat 大盘监控)<ul>
<li>基线成功率</li>
<li>基线失败率</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>限流<ul>
<li>原因<ul>
<li>流量远比能力大</li>
<li>永远不知道对方会怎么样</li>
<li>永远不知道自己会怎么样</li>
</ul>
</li>
<li>维度<ul>
<li>url(外部接口)</li>
<li>dubbo接口(内部接口)</li>
<li>sql操作数</li>
</ul>
</li>
<li>内容<ul>
<li>TPS/QPS</li>
<li>限制并发数</li>
<li>限制总数</li>
</ul>
</li>
<li>算法原理<ul>
<li>限制并发数(服务内以接口为单位设置并发总数锁,超过并发总数返回异常,达到限制并发的功能)</li>
<li>令牌桶算法(以桶模拟对应的令牌池,定时器会根据TPS重置桶,达到限制TPS的功能)</li>
<li>漏桶算法(以固定的速度流出流量,可以应对一定程度的突发流量,达到削峰填谷的功能)</li>
</ul>
</li>
<li>实战<ul>
<li>Guava的ratelimiter实现令牌桶</li>
</ul>
</li>
</ul>
</li>
<li>降级<ul>
<li>保护系统正常运行,也要保证用户体验</li>
<li>策略<ul>
<li>关闭接口并设置默认返回</li>
<li>降级逻辑</li>
<li>主动降级</li>
</ul>
</li>
</ul>
</li>
</ul>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2020/04/01/k8s/"><span>k8s</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2020/04/01/k8s/" rel="bookmark">
        <time class="entry-date published" datetime="2020-04-01T06:53:14.000Z">
          2020-04-01
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h3 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h3><ul>
<li>可扩展<ul>
<li>CNI Container Network Interface</li>
<li>CSI Container Storage Interface</li>
<li>CRI Container Runtime Interface</li>
</ul>
</li>
<li>整体架构<ul>
<li>C/S<ul>
<li>kubectl作为CLI操作server的master</li>
<li>master调度编排node</li>
<li>生产环境的master要部署多个以保证高可用</li>
</ul>
</li>
<li>master<ul>
<li>api-server</li>
<li>controller-manager</li>
<li>scheduler</li>
<li>etcd</li>
</ul>
</li>
<li>node<ul>
<li>kubelet</li>
<li>kube-proxy</li>
<li>containerRuntime(docker)</li>
<li>pod</li>
</ul>
</li>
</ul>
</li>
<li>快速部署<ul>
<li>KIND(k8s in docker)</li>
<li>Minikube<ul>
<li>BIOS开启虚拟化</li>
<li>OS安装虚拟机virtualBox</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="kubeadm生产可用部署"><a href="#kubeadm生产可用部署" class="headerlink" title="kubeadm生产可用部署"></a>kubeadm生产可用部署</h3><ul>
<li>禁用swap<ul>
<li>cat /proc/swap</li>
<li>swapoff -a #关闭swap</li>
<li>lsblk #查看设备属性，是否有swap</li>
<li>vi /etc/fstab #注释和swap相关的设备</li>
<li>free #查看是否还有swap</li>
</ul>
</li>
<li>查看机器uuid和mac<ul>
<li>cat /sys/class/dmi/id/product_uuid</li>
<li>ip a</li>
<li>确保全集群唯一</li>
</ul>
</li>
<li>查看端口是否被占用<ul>
<li>yum install -y net-tools</li>
<li>netstat -tnlp | grep -E ‘6443|23[79,80]|1025[0,1,2]’</li>
</ul>
</li>
<li>安装组件<ul>
<li>kubeadm</li>
<li>kubelet</li>
<li>kubectl</li>
</ul>
</li>
<li>配置kubelet由systemd管理<ul>
<li>/etc/systemd/system/kubelet.service</li>
<li>/etc/systemd/system/kubelet.service.d/kubadm.conf</li>
<li>systemctl enable kubelet</li>
</ul>
</li>
<li>安装前置依赖<ul>
<li>CRI管理软件包cri-tools<ul>
<li>crictl</li>
<li>critest</li>
</ul>
</li>
<li>socat<ul>
<li>实现端口转发</li>
<li>yum install -y socat</li>
</ul>
</li>
</ul>
</li>
<li>初始化<ul>
<li>kubeadm config images pull</li>
<li>或k8s.gcr.io改为registry.aliyuncs.com/google_containers，docker pull下来后再改tag</li>
<li>kubeadm init</li>
<li>kubeadm join</li>
</ul>
</li>
<li>配置kubectl<ul>
<li>mkdir -p $HOME/.kube</li>
<li>cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</li>
<li>chown $(id -u):$(id -g) $HOME/.kube/config</li>
</ul>
</li>
<li>验证<ul>
<li>kubectl cluster-info</li>
<li>kubectl get nodes</li>
</ul>
</li>
<li>配置网络<ul>
<li>sysctl net.bridge.bridge-nf-call-iptables=1</li>
<li>flannel需要kubeadm init时传递 –pod-network-cidr=10.244.0.0/16</li>
<li>重置kubeadm reset</li>
<li>kubectl apply -f config.yaml</li>
<li>kubectl get pods –all-namespaces</li>
</ul>
</li>
</ul>
<h3 id="kubectl"><a href="#kubectl" class="headerlink" title="kubectl"></a>kubectl</h3><ul>
<li>kubectl options</li>
<li>kubectl [flags] [options]</li>
<li>$HOME/.kube/config<ul>
<li>集群api地址</li>
<li>用于认证的证书地址</li>
</ul>
</li>
<li>kubectl get nodes -o yaml</li>
<li>kubectl get all</li>
<li>kubectl api-resources</li>
<li>kubectl explain </li>
<li>kubectl run NAME –image=image</li>
<li>kubectl expose deploy/redis –port 6379 –protocol=TCP –target-port=6379 –name=redis-server –type=ClusterIP｜NodePort</li>
<li>kubectl port-forward  svc/redis-server 6379:6379 #把内部ClusterIP的svc暴露外部访问</li>
<li>kubectl scale deploy/redis –replicas=3</li>
</ul>
<h3 id="核心对象"><a href="#核心对象" class="headerlink" title="核心对象"></a>核心对象</h3><ul>
<li>Pod</li>
<li>Deployment</li>
<li>ReplicaSet</li>
<li>Service<ul>
<li>ClusterIP 默认的service类型，仅集群内可访问的虚拟IP</li>
<li>NodePort 在node上绑定固定port(port范围在service-node-port-range配置，默认30000-32767)可以通过nodeIP:nodePort访问服务</li>
<li>LoadBalancer 通过云供应商CloudProvider创建一个外部负载均衡器，自动创建所需的nodePort或ClusterIP</li>
<li>ExternalName 通过将服务由DNS CNAME转发到指定的域名，需要kube-dns支持</li>
</ul>
</li>
</ul>
<h3 id="认证与授权"><a href="#认证与授权" class="headerlink" title="认证与授权"></a>认证与授权</h3><ul>
<li>api安全保证<ul>
<li>Authentication 识别用户身份认证</li>
<li>Authorization 控制用户对资源访问的授权</li>
<li>AdmissionControl 资源管理的准入控制</li>
</ul>
</li>
<li>跳过安全保证<ul>
<li>kubectl proxy可以直接通过http访问服务</li>
<li>直接访问kube-apiserver上启动服务时配置的insecure-port默认8080</li>
</ul>
</li>
<li>k8s用户<ul>
<li>一般用户<ul>
<li>只能通过外部服务管理</li>
<li>无法通过api添加到集群</li>
</ul>
</li>
<li>serviceAccount<ul>
<li>由k8sApi管理的用户，与特定的namespace绑定</li>
<li>会自动挂到pod容器中的/var/run/secrets/kubernetes.io/serviceaccount/目录中，其中包含namespace,token等</li>
</ul>
</li>
</ul>
</li>
<li>k8sApi操作<ul>
<li>与serviceAccount相关</li>
<li>匿名请求<ul>
<li>kube-apiserver的–anonymous-auth参数控制是否开启，默认开启</li>
<li>匿名用户默认的用户名 system:anonymous</li>
<li>匿名用户默认的所属组 system:unauthenticated</li>
</ul>
</li>
</ul>
</li>
<li>认证机制<ul>
<li>X509客户端证书<ul>
<li>默认/etc/kubernetes/pki/ca.crt</li>
<li>认证时使用证书subject的CN(common name)域作为用户名，O(organization)域作为组名</li>
</ul>
</li>
<li>引导token<ul>
<li>kubeadm init后会显示token</li>
<li>非kubeadm需要设置 enable-bootstrap-token-auth=true</li>
</ul>
</li>
<li>静态token文件<ul>
<li>启动kube-apiserver时配置–token-auth-file=FILE</li>
<li>请求时加上 Authorization: Bearer TOKEN请求头</li>
</ul>
</li>
<li>静态密码文件<ul>
<li>启动kube-apiserver时配置–basic-auth-file=FILe</li>
<li>请求时加上 Authorization: Basic BASE64ENCODED(USER:PASS)</li>
</ul>
</li>
<li>serviceAccountToken</li>
<li>OpenID:提供了OAuth2的认证支持,云厂商也支持</li>
<li>认证代理:配合身份验证代理进行使用,比如提供通用的授权网关</li>
<li>webhook:提供webhook配合远端服务器使用</li>
</ul>
</li>
<li>授权机制<ul>
<li>支持多种授权机制<ul>
<li>ABAC(attribute-based access control) 基于属性的访问控制</li>
<li>RBAC(role-based access control) 基于角色的访问控制，类似mongoDB</li>
<li>Node 特殊的授权机制，专门用于kubelet发出的api请求做授权验证</li>
<li>Webhook 使用外部服务进行</li>
<li>AlwaysAllow 允许全部，这个是默认配置</li>
<li>AlwaysDeny 禁止全部，通常用于测试</li>
</ul>
</li>
<li>默认的授权都是拒绝</li>
<li>当某种授权拒绝或通过后便会返回，不再请求其他授权机制</li>
<li>当所有授权机制都未通过便返回403</li>
</ul>
</li>
<li>角色<ul>
<li>分类<ul>
<li>Role 一组权限的集合，但被限制在namespace内</li>
<li>ClusterRole 对于集群级别的资源是不被namespace限制的，并且还有一些非资源类的请求</li>
</ul>
</li>
<li>绑定<ul>
<li>rolebinding</li>
<li>clusterrolebinding</li>
</ul>
</li>
</ul>
</li>
<li>查看kubectl用户权限<ul>
<li>kubectl config current-context</li>
<li>kubectl config view users -o yaml</li>
<li>kubectl config view users –raw -o jsonpath=’{ .users[?(@.name == “kubernetes-admin”)].user.client-certificate-data}’ |base64 -d  #显示证书内容</li>
<li>kubectl config view users –raw -o jsonpath=’{ .users[?(@.name == “kubernetes-admin”)].user.client-certificate-data}’ |base64 -d |openssl x509 -text -noout #显示证书</li>
</ul>
</li>
<li>实践：创建权限可控的用户<ul>
<li>创建ns<ul>
<li>kubectl create namespace work</li>
</ul>
</li>
<li>创建用户<ul>
<li>mkdir work &amp;&amp; cd work</li>
<li>openssl genrsa -out backend.key 2048 #创建私钥</li>
<li>openssl req -new -key backend.key -out backend.csr -subj “/CN=backend/O=dev” #生成csr</li>
<li>openssl x509 -req -in backend.csr -CA /etc/kubernetes/pki/ca.crt -CAkey /etc/kubernetes/pki/ca.key -CAcreateserial -out backend.crt -days 365 #CA签名</li>
<li>openssl x509 -in backend.crt -text -noout #查看证书文件，观察subject的CN和O</li>
</ul>
</li>
<li>添加context<ul>
<li>kubectl config set-credentials backend –client-certificate=/root/work/backend.crt –client-key=/root/work/backend.key #添加用户</li>
<li>kubectl config set-context backend-context –cluter=kubernetes –namespace=work –user=backend #创建context</li>
</ul>
</li>
<li>测试访问<ul>
<li>kubectl –context=backend-context get pods -n work -v 5</li>
</ul>
</li>
<li>创建role和rolebinding<ul>
<li>kubectl create -f backend-role.yaml</li>
<li>kubectl get roles -n work -o yaml</li>
<li>kubectl create -f backend-rolebinding.yaml</li>
<li>kubectl get rolebinding -n work -o yaml</li>
</ul>
</li>
<li>测试用户权限<ul>
<li>kubectl –context=backend-context get pods -n work -v 5</li>
<li>kubectl –context=backend-context get deploy -n work</li>
<li>kubectl –context=backend-context get ns</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># backend-role.yaml</span><br><span class="line">kind: Role</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">metadata:</span><br><span class="line">  namespace: work</span><br><span class="line">  name: backend-role</span><br><span class="line">rules:</span><br><span class="line">- apiGroups: [&quot;&quot;]</span><br><span class="line">  resources: [&quot;pods&quot;]</span><br><span class="line">  verbs: [&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># backend-rolebinding.yaml</span><br><span class="line">kind: RoleBinding</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">metadata:</span><br><span class="line">  name: backend-rolebinding          </span><br><span class="line">  namespace: work</span><br><span class="line">subjects:      </span><br><span class="line">- kind: User</span><br><span class="line">  name: backend</span><br><span class="line">  apiGroup: &quot;&quot;     </span><br><span class="line">roleRef:    </span><br><span class="line">  kind: Role </span><br><span class="line">  name: backend-role</span><br><span class="line">  apiGroup: &quot;&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>k8s内置调试/验证机制<ul>
<li>kubectl auth can-i list pods -n work –as=”backend”</li>
<li>kubectl auth can-i list deploy -n work –as=”backend”</li>
<li>也可以使用~/.kube/config中的配置进行调试</li>
</ul>
</li>
</ul>
<h3 id="实战发布"><a href="#实战发布" class="headerlink" title="实战发布"></a>实战发布</h3><ul>
<li>vi Dockerfile</li>
<li>vi .dockerignore</li>
<li>docker build -t repo/name:tag .</li>
<li>docker login / $HOME/.docker/config.json</li>
<li>docker push repo/name:tag</li>
<li>docker-compose发布<ul>
<li>vi docker-compose.yaml</li>
<li>docker-compose up</li>
<li>docker-compose ps</li>
</ul>
</li>
<li>k8s发布<ul>
<li>交互方式<ul>
<li>命令式 kubectl run redis –image=’’</li>
<li>命令式对象配置 kubectl create -f </li>
<li>声明式对象配置 kubectl apply -f</li>
</ul>
</li>
<li>vi namespace.yaml &amp;&amp; kubectl apply -f namespace.yaml</li>
<li>vi redis-deployment.yaml &amp;&amp; kubectl apply -f redis-deployment.yaml</li>
<li>kubectl -n work get all</li>
<li>kubectl -n work exec -it HASH bash &amp;&amp; redis-cli</li>
<li>vi redis-service.yaml &amp;&amp; kubectl apply -f redis-service.yaml</li>
<li>kubectl -n work get svc</li>
<li>vi backend-deployment.yaml &amp;&amp; kubectl apply -f backend-deployment.yaml</li>
<li>vi backend-svc.yaml &amp;&amp; kubectl apply -f backend-svc.yaml</li>
<li>vi fe-deployment.yaml &amp;&amp; kubectl apply -f fe-deployment.yaml</li>
<li>vi fe-svc.yaml &amp;&amp; kubectl apply -f fe-svc.yaml</li>
</ul>
</li>
</ul>
<h3 id="helm"><a href="#helm" class="headerlink" title="helm"></a>helm</h3><ul>
<li>helm是k8s的包管理器，类比yum/apt/homebrew/pip</li>
<li>简化包分发/安装/版本管理等操作流程</li>
<li>CS架构<ul>
<li>客户端helm</li>
<li>服务端tiller</li>
</ul>
</li>
<li>helm<ul>
<li>helm version</li>
<li>默认会读取$HOME/.kube/config 中的集群地址</li>
</ul>
</li>
<li>tiller<ul>
<li>直接执行tiller默认启动44134(和helm通信)和44135(用于探活)端口的服务</li>
<li>使用客户端连接tiller时要设置HELM_HOST环境变量(44134服务)</li>
<li>确保$HOME/.kube/config正确配置</li>
</ul>
</li>
<li>默认安装<ul>
<li>helm init [–tiller-image 国内tiller镜像]</li>
<li>会在k8s集群中部署tiller和初始化helm的默认目录$HELM_HOME默认$HOME/.helm</li>
<li>默认会生成kube-system命名空间下的tiller-deploy</li>
</ul>
</li>
<li>核心概念<ul>
<li>chart<ul>
<li>helm所管理的包，类似yum的rpm</li>
<li>包含应用要部署到集群上必须的所有资源</li>
</ul>
</li>
<li>release<ul>
<li>chart在集群部署后的实例</li>
<li>chart每次部署都会产生一次release</li>
</ul>
</li>
<li>repository<ul>
<li>存储chart的仓库</li>
<li>默认情况下helm初始化时有2个仓库:stable和local</li>
</ul>
</li>
<li>config<ul>
<li>部署时可以自定义的配置</li>
<li>真正执行部署时会把config和chart进行合并</li>
</ul>
</li>
</ul>
</li>
<li>工作原理<ul>
<li>helm通过gRPC将chart发送至tiller</li>
<li>tiller通过内置的k8s客户端库与api-server交互，默认采用ClusterIP的service部署chart，通过socat端口转发数据</li>
<li>生成release用于管理</li>
</ul>
</li>
<li>实践<ul>
<li>helm create name</li>
<li>tree -a name<ul>
<li>Chart.yaml</li>
<li>charts</li>
<li>.helmignore</li>
<li>templates<ul>
<li>Notes.txt #在helm install完成后会回显，用于使用说明</li>
</ul>
</li>
<li>values.yaml</li>
</ul>
</li>
<li>helm package name </li>
<li>helm install name|path-to-name-version.tgz</li>
</ul>
</li>
</ul>
<h3 id="kube-apiserver"><a href="#kube-apiserver" class="headerlink" title="kube-apiserver"></a>kube-apiserver</h3><ul>
<li>整个集群的统一入口</li>
<li>默认6443端口，可通过–secure-port配置</li>
<li>也可配置–insecure-port，通过这个端口访问无需认证，生产环境应该配置为0以禁用此功能</li>
<li>kubectl version -v 8 #8是指logLevel</li>
<li>curl -k <a href="https://172.17.0.99:6443/version" target="_blank" rel="noopener">https://172.17.0.99:6443/version</a></li>
<li>kubectl proxy &amp; # 使用KUBECONFIG中的配置在本地和集群之间创建一个代理</li>
<li>核心功能<ul>
<li>认证</li>
<li>授权</li>
<li>准入控制(默认开启以下插件)<ul>
<li>NamespaceLifecycle<ul>
<li>保证正在终止的namespace不允许创建对象</li>
<li>不允许请求不存在的namespace</li>
<li>保证default和kube-system的namespace不被删除</li>
</ul>
</li>
<li>LimitRanger 为pod设置默认请求资源的限制</li>
<li>ServiceAccount 可按预设规则创建sa</li>
<li>DefaultStorageClass 为PVC设置默认StorageClass</li>
<li>DefaultTolerationSeconds 设置pod默认的forgiveness toleration为5分钟</li>
<li>ResourceQuota 限制pod请求配额</li>
<li>AllwaysPullImages 总是拉取镜像</li>
<li>AllwaysAdmit 总是接受所有请求</li>
</ul>
</li>
<li>CRUD处理</li>
</ul>
</li>
</ul>
<h3 id="etcd"><a href="#etcd" class="headerlink" title="etcd"></a>etcd</h3><ul>
<li>概述<ul>
<li>分布式，高可用，强一致的键值存储，还有监听机制</li>
<li>go语言编写</li>
<li>Raft协议作为一致性算法，需要部署奇数个节点3，5，7</li>
<li>常用于分布式系统中的服务注册发现或存储系统的关键数据</li>
</ul>
</li>
<li>操作<ul>
<li>kubectl -n kube-system get pods ｜ grep etcd</li>
<li>kubectl -n kube-system exec -it NAME sh</li>
<li>ETCDCTL_API=3 etcdctl –key=/etc/kubernetes/pki/etcd/server.key  –cert=/etc/kubernetes/pki/etcd/server.crt  –cacert=/etc/kubernetes/pki/etcd/ca.crt member list</li>
<li>ETCDCTL_API=3 etcdctl –key=/etc/kubernetes/pki/etcd/server.key  –cert=/etc/kubernetes/pki/etcd/server.crt  –cacert=/etc/kubernetes/pki/etcd/ca.crt get /registry –prefix –keys-only #集群元信息基本都是在/registry下</li>
<li>ETCDCTL_API=3 etcdctl –key=/etc/kubernetes/pki/etcd/server.key  –cert=/etc/kubernetes/pki/etcd/server.crt  –cacert=/etc/kubernetes/pki/etcd/ca.crt get /registry/namespaces –prefix –keys-only #查看ns</li>
<li>kubectl create  ns NAME #创建ns并再次查看</li>
</ul>
</li>
</ul>
<h3 id="controller-manager"><a href="#controller-manager" class="headerlink" title="controller-manager"></a>controller-manager</h3><ul>
<li>实际包含2部分<ul>
<li>kube-controller-manager 嵌入了k8s核心控制循环的守护进程</li>
<li>cloud-controller-manager 为各云厂商提供抽象封装便于使用自己的provide</li>
</ul>
</li>
<li>作用<ul>
<li>通过apiserver提供的信息持续监控集群状态，并尝试将集群调整至预期状态</li>
<li>通过默认的10252端口提供健康检查的/healthz和监控的/metrics接口</li>
</ul>
</li>
</ul>
<h3 id="kube-scheduler"><a href="#kube-scheduler" class="headerlink" title="kube-scheduler"></a>kube-scheduler</h3><ul>
<li>集群调度器，将预期的pod资源调度到最佳的node上</li>
<li>是一个策略丰富，拓扑感知的调度程序，显著影响可用性，性能和容量</li>
<li>处理阶段<ul>
<li>computing predicates 解决pod能否调度到node上的问题(pod亲和性/是否可调度等)</li>
<li>prioritizing 解决上个阶段得到的nodes中哪个是最优的，得到一个优先级列表</li>
<li>selecting host 最终选择pod调度到哪台node上</li>
</ul>
</li>
</ul>
<h3 id="kubelet"><a href="#kubelet" class="headerlink" title="kubelet"></a>kubelet</h3><ul>
<li>负责node和pod的相关管理任务</li>
<li>作用<ul>
<li>node管理<ul>
<li>向master注册node并上报机器信息</li>
<li>可配置node上的maxPods数，健康检查机制，认证授权机制，驱逐策略等</li>
<li>清理磁盘等工作</li>
</ul>
</li>
<li>pod管理<ul>
<li>接收scheduler的调度并确保pod按预期工作</li>
<li>确保pod的健康检查(livenessProbe和readinessProbe)</li>
<li>确保资源监控(cAdvisor)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="kube-proxy"><a href="#kube-proxy" class="headerlink" title="kube-proxy"></a>kube-proxy</h3><ul>
<li>运行于node上的网络代理组件，提供了TCP/UDP的连接转发的支持</li>
<li>查看svc后端具体pod的服务可以查看endpoints对象</li>
<li>工作模式<ul>
<li>userspace 效率不高不推荐</li>
<li>iptables 默认，问题是给机器增加很多规则</li>
<li>ipvs 为了解决iptables的性能问题而引入，采用增量方式更新</li>
</ul>
</li>
</ul>
<h3 id="containerRuntime-docker"><a href="#containerRuntime-docker" class="headerlink" title="containerRuntime(docker)"></a>containerRuntime(docker)</h3><ul>
<li>k8s中的CRI即可支持kubelet使用不同的runtime，而不需要重新编译</li>
<li>当前最广泛的使用就是docker</li>
</ul>
<h3 id="troubleshoot"><a href="#troubleshoot" class="headerlink" title="troubleshoot"></a>troubleshoot</h3><ul>
<li>kubectl describe</li>
<li>kubectl get events</li>
<li>kubectl get endpoints #svc是通过endpoints来工作的，这里可以看到pod的端口等</li>
<li>修复<ul>
<li>版本控制yaml文件变更后重新apply</li>
<li>kubectl edit #不推荐使用，不会保留历史</li>
</ul>
</li>
</ul>
<h3 id="dashboard"><a href="#dashboard" class="headerlink" title="dashboard"></a>dashboard</h3><ul>
<li>kubectl apply -f dashboard.yaml</li>
<li>访问<ul>
<li>默认的部署方式svc使用了ClusterIP无法正常访问</li>
<li>kubectl -n kube-system port-forward pod/NAME 8443 # 利用socat进行端口转发</li>
<li>kubectl -n kube-system get serviceaccount -l k8s-app=kubernetes-dashboard -o yaml # 查找secrets</li>
<li>kubectl -n kube-system describe secrets NAME # 通过secrets获取token</li>
</ul>
</li>
<li>参考dashboard服务可以基于k8s开发云平台</li>
</ul>
<h3 id="coreDNS"><a href="#coreDNS" class="headerlink" title="coreDNS"></a>coreDNS</h3><ul>
<li>是一个独立的DNS项目，可集成k8s，也可单独使用</li>
<li>扩展性很强，很多功能都是通过插件完成<ul>
<li>内置插件</li>
<li>丰富的三方插件</li>
</ul>
</li>
<li>验证<ul>
<li>kubectl run alpine -it –rm –restart=’Never’ –image=’alpine’ sh</li>
<li>apk add –no-cache bind-tools</li>
<li>dig @PODIP SVCNAME.NS.svc.cluster.local +noall +answer</li>
</ul>
</li>
<li>特性<ul>
<li>coreDNS的解析是全局的，跨ns的，但不代表网络互通</li>
<li>域名有特定的格式 SVCNAME.NS.svc.cluster.local</li>
<li>使用configMap方式进行的配置，如果更改了配置需要重启pod才能生效 kubectl -n kube-system get cm coredns -o yaml</li>
</ul>
</li>
</ul>
<h3 id="ingress"><a href="#ingress" class="headerlink" title="ingress"></a>ingress</h3><ul>
<li>kubectl explain ingress</li>
<li>是一组允许外部请求进入集群的路由规则的集合，可以给svc提供集群外访问的url/ssl终止/负载均衡等</li>
<li>起到了智能路由的角色，外部流量到达ingress，再由它按制定好的规则分发到不同的后端</li>
<li>ingress与loadBalancer类型的svc区别<ul>
<li>ingress不是一种svc类型</li>
<li>ingress可以由多种控制器(实现方式)<ul>
<li>nginxIngressController是使用cm存储nginx的配置实现的(支持会话保持和动态配置)</li>
<li>google的GLBC</li>
<li>第三方的实现<ul>
<li>基于envoy的contour</li>
<li>F5的F5 BIG-IPController</li>
<li>基于haproxy的haproxy-ingress</li>
<li>基于istio的traffic</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>使用<ul>
<li>创建ns</li>
<li>创建cm，主要是给controller使用</li>
<li>创建Role/RoleBinding</li>
<li>部署nginxIngressController</li>
<li>检查 kubectl -n ingress-nginx get all</li>
<li>将nginxIngressController暴露至集群外(这里选择nodePort方式创建svc)</li>
<li>测试 curl NODE:PORT</li>
<li>部署ingress</li>
<li>测试 <ul>
<li>kubectl -n work get ingress</li>
<li>访问DOMAIN:暴露ingress时创建的svc的端口<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br></pre></td><td class="code"><pre><span class="line"># ns</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Namespace</span><br><span class="line">metadata:</span><br><span class="line">  name: ingress-nginx</span><br><span class="line">  labels:</span><br><span class="line">    app.kubernetes.io/name: ingress-nginx</span><br><span class="line">    app.kubernetes.io/part-of: ingress-nginx</span><br><span class="line"></span><br><span class="line"># cm</span><br><span class="line">kind: ConfigMap</span><br><span class="line">apiVersion: v1</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx-configuration</span><br><span class="line">  namespace: ingress-nginx</span><br><span class="line">  labels:</span><br><span class="line">    app.kubernetes.io/name: ingress-nginx</span><br><span class="line">    app.kubernetes.io/part-of: ingress-nginx</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">kind: ConfigMap</span><br><span class="line">apiVersion: v1</span><br><span class="line">metadata:</span><br><span class="line">  name: tcp-services</span><br><span class="line">  namespace: ingress-nginx</span><br><span class="line">  labels:</span><br><span class="line">    app.kubernetes.io/name: ingress-nginx</span><br><span class="line">    app.kubernetes.io/part-of: ingress-nginx</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">kind: ConfigMap</span><br><span class="line">apiVersion: v1</span><br><span class="line">metadata:</span><br><span class="line">  name: udp-services</span><br><span class="line">  namespace: ingress-nginx</span><br><span class="line">  labels:</span><br><span class="line">    app.kubernetes.io/name: ingress-nginx</span><br><span class="line">    app.kubernetes.io/part-of: ingress-nginx</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"># Role/Rolebinding</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: ServiceAccount</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx-ingress-serviceaccount</span><br><span class="line">  namespace: ingress-nginx</span><br><span class="line">  labels:</span><br><span class="line">    app.kubernetes.io/name: ingress-nginx</span><br><span class="line">    app.kubernetes.io/part-of: ingress-nginx</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1beta1</span><br><span class="line">kind: ClusterRole</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx-ingress-clusterrole</span><br><span class="line">  labels:</span><br><span class="line">    app.kubernetes.io/name: ingress-nginx</span><br><span class="line">    app.kubernetes.io/part-of: ingress-nginx</span><br><span class="line">rules:</span><br><span class="line">  - apiGroups:</span><br><span class="line">      - &quot;&quot;</span><br><span class="line">    resources:</span><br><span class="line">      - configmaps</span><br><span class="line">      - endpoints</span><br><span class="line">      - nodes</span><br><span class="line">      - pods</span><br><span class="line">      - secrets</span><br><span class="line">    verbs:</span><br><span class="line">      - list</span><br><span class="line">      - watch</span><br><span class="line">  - apiGroups:</span><br><span class="line">      - &quot;&quot;</span><br><span class="line">    resources:</span><br><span class="line">      - nodes</span><br><span class="line">    verbs:</span><br><span class="line">      - get</span><br><span class="line">  - apiGroups:</span><br><span class="line">      - &quot;&quot;</span><br><span class="line">    resources:</span><br><span class="line">      - services</span><br><span class="line">    verbs:</span><br><span class="line">      - get</span><br><span class="line">      - list</span><br><span class="line">      - watch</span><br><span class="line">  - apiGroups:</span><br><span class="line">      - &quot;extensions&quot;</span><br><span class="line">    resources:</span><br><span class="line">      - ingresses</span><br><span class="line">    verbs:</span><br><span class="line">      - get</span><br><span class="line">      - list</span><br><span class="line">      - watch</span><br><span class="line">  - apiGroups:</span><br><span class="line">      - &quot;&quot;</span><br><span class="line">    resources:</span><br><span class="line">      - events</span><br><span class="line">    verbs:</span><br><span class="line">      - create</span><br><span class="line">      - patch</span><br><span class="line">  - apiGroups:</span><br><span class="line">      - &quot;extensions&quot;</span><br><span class="line">    resources:</span><br><span class="line">      - ingresses/status</span><br><span class="line">    verbs:</span><br><span class="line">      - update</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1beta1</span><br><span class="line">kind: Role</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx-ingress-role</span><br><span class="line">  namespace: ingress-nginx</span><br><span class="line">  labels:</span><br><span class="line">    app.kubernetes.io/name: ingress-nginx</span><br><span class="line">    app.kubernetes.io/part-of: ingress-nginx</span><br><span class="line">rules:</span><br><span class="line">  - apiGroups:</span><br><span class="line">      - &quot;&quot;</span><br><span class="line">    resources:</span><br><span class="line">      - configmaps</span><br><span class="line">      - pods</span><br><span class="line">      - secrets</span><br><span class="line">      - namespaces</span><br><span class="line">    verbs:</span><br><span class="line">      - get</span><br><span class="line">  - apiGroups:</span><br><span class="line">      - &quot;&quot;</span><br><span class="line">    resources:</span><br><span class="line">      - configmaps</span><br><span class="line">    resourceNames:</span><br><span class="line">      - &quot;ingress-controller-leader-nginx&quot;</span><br><span class="line">    verbs:</span><br><span class="line">      - get</span><br><span class="line">      - update</span><br><span class="line">  - apiGroups:</span><br><span class="line">      - &quot;&quot;</span><br><span class="line">    resources:</span><br><span class="line">      - configmaps</span><br><span class="line">    verbs:</span><br><span class="line">      - create</span><br><span class="line">  - apiGroups:</span><br><span class="line">      - &quot;&quot;</span><br><span class="line">    resources:</span><br><span class="line">      - endpoints</span><br><span class="line">    verbs:</span><br><span class="line">      - get</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1beta1</span><br><span class="line">kind: RoleBinding</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx-ingress-role-nisa-binding</span><br><span class="line">  namespace: ingress-nginx</span><br><span class="line">  labels:</span><br><span class="line">    app.kubernetes.io/name: ingress-nginx</span><br><span class="line">    app.kubernetes.io/part-of: ingress-nginx</span><br><span class="line">roleRef:</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br><span class="line">  kind: Role</span><br><span class="line">  name: nginx-ingress-role</span><br><span class="line">subjects:</span><br><span class="line">  - kind: ServiceAccount</span><br><span class="line">    name: nginx-ingress-serviceaccount</span><br><span class="line">    namespace: ingress-nginx</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1beta1</span><br><span class="line">kind: ClusterRoleBinding</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx-ingress-clusterrole-nisa-binding</span><br><span class="line">  labels:</span><br><span class="line">    app.kubernetes.io/name: ingress-nginx</span><br><span class="line">    app.kubernetes.io/part-of: ingress-nginx</span><br><span class="line">roleRef:</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br><span class="line">  kind: ClusterRole</span><br><span class="line">  name: nginx-ingress-clusterrole</span><br><span class="line">subjects:</span><br><span class="line">  - kind: ServiceAccount</span><br><span class="line">    name: nginx-ingress-serviceaccount</span><br><span class="line">    namespace: ingress-nginx</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"># nginxIngressController</span><br><span class="line">apiVersion: extensions/v1beta1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx-ingress-controller</span><br><span class="line">  namespace: ingress-nginx</span><br><span class="line">  labels:</span><br><span class="line">    app.kubernetes.io/name: ingress-nginx</span><br><span class="line">    app.kubernetes.io/part-of: ingress-nginx</span><br><span class="line">spec:</span><br><span class="line">  replicas: 1</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app.kubernetes.io/name: ingress-nginx</span><br><span class="line">      app.kubernetes.io/part-of: ingress-nginx</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app.kubernetes.io/name: ingress-nginx</span><br><span class="line">        app.kubernetes.io/part-of: ingress-nginx</span><br><span class="line">      annotations:</span><br><span class="line">        prometheus.io/port: &quot;10254&quot;</span><br><span class="line">        prometheus.io/scrape: &quot;true&quot;</span><br><span class="line">    spec:</span><br><span class="line">      serviceAccountName: nginx-ingress-serviceaccount</span><br><span class="line">      containers:</span><br><span class="line">        - name: nginx-ingress-controller</span><br><span class="line">          image: taobeier/nginx-ingress-controller:0.21.0</span><br><span class="line">          args:</span><br><span class="line">            - /nginx-ingress-controller</span><br><span class="line">            - --configmap=$(POD_NAMESPACE)/nginx-configuration</span><br><span class="line">            - --tcp-services-configmap=$(POD_NAMESPACE)/tcp-services</span><br><span class="line">            - --udp-services-configmap=$(POD_NAMESPACE)/udp-services</span><br><span class="line">            - --publish-service=$(POD_NAMESPACE)/ingress-nginx</span><br><span class="line">            - --annotations-prefix=nginx.ingress.kubernetes.io</span><br><span class="line">          securityContext:</span><br><span class="line">            capabilities:</span><br><span class="line">              drop:</span><br><span class="line">                - ALL</span><br><span class="line">              add:</span><br><span class="line">                - NET_BIND_SERVICE</span><br><span class="line">            # www-data -&gt; 33</span><br><span class="line">            runAsUser: 33</span><br><span class="line">          env:</span><br><span class="line">            - name: POD_NAME</span><br><span class="line">              valueFrom:</span><br><span class="line">                fieldRef:</span><br><span class="line">                  fieldPath: metadata.name</span><br><span class="line">            - name: POD_NAMESPACE</span><br><span class="line">              valueFrom:</span><br><span class="line">                fieldRef:</span><br><span class="line">                  fieldPath: metadata.namespace</span><br><span class="line">          ports:</span><br><span class="line">            - name: http</span><br><span class="line">              containerPort: 80</span><br><span class="line">            - name: https</span><br><span class="line">              containerPort: 443</span><br><span class="line">          livenessProbe:</span><br><span class="line">            failureThreshold: 3</span><br><span class="line">            httpGet:</span><br><span class="line">              path: /healthz</span><br><span class="line">              port: 10254</span><br><span class="line">              scheme: HTTP</span><br><span class="line">            initialDelaySeconds: 10</span><br><span class="line">            periodSeconds: 10</span><br><span class="line">            successThreshold: 1</span><br><span class="line">            timeoutSeconds: 1</span><br><span class="line">          readinessProbe:</span><br><span class="line">            failureThreshold: 3</span><br><span class="line">            httpGet:</span><br><span class="line">              path: /healthz</span><br><span class="line">              port: 10254</span><br><span class="line">              scheme: HTTP</span><br><span class="line">            periodSeconds: 10</span><br><span class="line">            successThreshold: 1</span><br><span class="line">            timeoutSeconds: 1</span><br><span class="line"></span><br><span class="line"># 暴露至集群外</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: ingress-nginx</span><br><span class="line">  namespace: ingress-nginx</span><br><span class="line">  labels:</span><br><span class="line">    app.kubernetes.io/name: ingress-nginx</span><br><span class="line">    app.kubernetes.io/part-of: ingress-nginx</span><br><span class="line">spec:</span><br><span class="line">  type: NodePort</span><br><span class="line">  ports:</span><br><span class="line">    - name: http</span><br><span class="line">      port: 80</span><br><span class="line">      targetPort: 80</span><br><span class="line">      protocol: TCP</span><br><span class="line">    - name: https</span><br><span class="line">      port: 443</span><br><span class="line">      targetPort: 443</span><br><span class="line">      protocol: TCP</span><br><span class="line">  selector:</span><br><span class="line">    app.kubernetes.io/name: ingress-nginx</span><br><span class="line">    app.kubernetes.io/part-of: ingress-nginx</span><br><span class="line"></span><br><span class="line"># ingress</span><br><span class="line">apiVersion: extensions/v1beta1</span><br><span class="line">kind: Ingress</span><br><span class="line">metadata:</span><br><span class="line">  name: name</span><br><span class="line">  namespace: work</span><br><span class="line">  annotations:</span><br><span class="line">    nginx.ingress.kubernetes.io/ssl-redirect: &quot;false&quot;</span><br><span class="line">spec:</span><br><span class="line">  rules:</span><br><span class="line">  - host: DOMAIN</span><br><span class="line">    http:</span><br><span class="line">      paths:</span><br><span class="line">      - path: /</span><br><span class="line">        backend:</span><br><span class="line">          serviceName: SVCNAME</span><br><span class="line">          servicePort: 80</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h3><ul>
<li>监控点<ul>
<li>node情况</li>
<li>k8s集群自身状态</li>
<li>部署在集群内的应用的状态</li>
</ul>
</li>
<li>prometheus<ul>
<li>非常灵活易于扩展</li>
<li>通过各种exporter暴露数据</li>
<li>由prometheus server定时拉取数据然后存储</li>
<li>自带简单的前端界面可以使用promQL进行查询</li>
</ul>
</li>
<li>安装<ul>
<li>推荐prometheusOperator</li>
<li>具体过程<ul>
<li>创建ns</li>
<li>创建role/rolebinding</li>
<li>创建prometheus的配置文件cm</li>
<li>创建部署文件deploy</li>
<li>执行完毕后查看情况 kubectl -n monitoring get all</li>
<li>使用svc将服务暴露/也可使用ingress</li>
<li>安装nodeExporter(daemonSet)</li>
</ul>
</li>
</ul>
</li>
</ul>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2020/02/28/fe/"><span>fe</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2020/02/28/fe/" rel="bookmark">
        <time class="entry-date published" datetime="2020-02-28T05:18:52.000Z">
          2020-02-28
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h3 id="fe"><a href="#fe" class="headerlink" title="fe"></a>fe</h3><h4 id="js"><a href="#js" class="headerlink" title="js"></a>js</h4><ul>
<li>原始类型<ul>
<li>Boolean</li>
<li>String</li>
<li>Number</li>
<li>Undefined</li>
<li>Null</li>
<li>Symbol</li>
</ul>
</li>
<li>类型判断<ul>
<li>typeof<ul>
<li>undefined</li>
<li>boolean</li>
<li>string</li>
<li>number</li>
<li>function</li>
<li>object</li>
</ul>
</li>
<li>instanceof<ul>
<li>数组</li>
<li>自定义类</li>
</ul>
</li>
</ul>
</li>
<li>类型传递<ul>
<li>值类型按值传递<ul>
<li>Boolean</li>
<li>String</li>
<li>Number</li>
<li>Undefined</li>
<li>Null</li>
</ul>
</li>
<li>引用类型按共享传递<ul>
<li>Object</li>
<li>Function</li>
<li>Array</li>
<li>Date</li>
</ul>
</li>
</ul>
</li>
<li>原型和原型链<ul>
<li>引用类型都有对象的特性，可自由扩展属性</li>
<li>引用类型都有一个<strong>proto</strong>属性指向原型对象</li>
<li>所有的函数都有prototype属性指向原型对象</li>
<li>引用类型的<strong>proto</strong>指向它构造函数的prototype</li>
<li>当试图得到一个对象的某个属性时如果本身没有则去<strong>proto</strong>上寻找形成原型链</li>
</ul>
</li>
<li>作用域和作用域链<ul>
<li>全局作用域</li>
<li>函数作用域</li>
<li>ES6后增加块级作用域</li>
<li>当前作用域中没有的变量称为自由变量，自由变量向父级作用域寻值，形成作用域链</li>
</ul>
</li>
</ul>
<h4 id="css"><a href="#css" class="headerlink" title="css"></a>css</h4><ul>
<li>选择器权重和优先级<ul>
<li>!important</li>
<li>内联样式</li>
<li>ID选择器</li>
<li>类、伪类、属性选择器</li>
<li>元素选择器</li>
</ul>
</li>
<li>盒子模型<ul>
<li>margin</li>
<li>border</li>
<li>padding</li>
<li>content</li>
<li>分类<ul>
<li>border-box</li>
<li>content-box</li>
</ul>
</li>
</ul>
</li>
<li>position<ul>
<li>static</li>
<li>relative</li>
<li>absolute</li>
<li>fixed</li>
</ul>
</li>
<li>flex<ul>
<li>container<ul>
<li>flex-direction</li>
<li>justify-content</li>
<li>align-items</li>
</ul>
</li>
<li>item</li>
</ul>
</li>
<li>重绘和回流<ul>
<li>重绘<ul>
<li>简单的进行样式的变化，如颜色、背景等，不影响几何信息</li>
<li>开销小</li>
</ul>
</li>
<li>回流（重排）<ul>
<li>DOM中的尺寸大小几何信息，位置信息发生变化导致重新渲染</li>
<li>开销大</li>
<li>getComputedStyle/currentStyle获取即时属性值的操作也会触发回流</li>
</ul>
</li>
<li>避免<ul>
<li>缓存DOM对象</li>
<li>避免逐条修改样式，使用类名合并</li>
<li>将DOM离线后操作不会有性能问题，操作完毕后上线display:none/block;</li>
<li>现代浏览器会维护一个flush队列，在不得已的时候会执行队列</li>
</ul>
</li>
</ul>
</li>
<li>1px线实现方式<ul>
<li>渐变</li>
<li>缩放</li>
<li>图片(base64/svg)</li>
</ul>
</li>
<li>图片保真<ul>
<li>统一使用最高倍图，但浪费带宽</li>
<li>srcset属性</li>
</ul>
</li>
<li>字体适配<ul>
<li>默认最小限制<ul>
<li>PC上是12px</li>
<li>手机上是8px</li>
</ul>
</li>
<li>不建议使用奇数数值，容易在低端手机上出现锯齿</li>
<li>尽量使用默认系统字体</li>
<li>font-family取值<ul>
<li>具体字体名称</li>
<li>通用类别<ul>
<li>serif 衬线字体族</li>
<li>sans-serif 非衬线字体族</li>
<li>monospace 等宽字体</li>
<li>cursive 草书字体</li>
<li>fantasy 艺术字体</li>
<li>systme-ui 系统默认字体</li>
<li>emoji 兼容表情符号</li>
<li>math 数学表达式</li>
<li>fangsong 仿宋</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><ul>
<li>程序<ul>
<li>数据</li>
<li>算法</li>
</ul>
</li>
<li>数据结构<ul>
<li>简单数据结构<ul>
<li>有序数据结构：栈、队列、链表，省空间，存储空间小</li>
<li>无序数据结构：字典、集合、散列集，省时间，读取时间快</li>
</ul>
</li>
<li>高级数据结构<ul>
<li>树、堆</li>
<li>图</li>
</ul>
</li>
</ul>
</li>
<li>常见算法<ul>
<li>递归</li>
<li>排序</li>
<li>枚举</li>
</ul>
</li>
<li>算法复杂度<ul>
<li>时间复杂度（好估算、好评估）<ul>
<li>常数阶O(1) #每行一次性的语句就是常数阶</li>
<li>线性阶O(n)</li>
<li>平方阶O(n^2)</li>
<li>立方阶O(n^3)</li>
<li>k次方阶O(n^k)</li>
<li>指数阶O(2^n)</li>
<li>对数阶O(logN)</li>
<li>线性对数阶O(nlogN)</li>
</ul>
</li>
<li>空间复杂度</li>
<li>分析技巧<ul>
<li>几重循环，一般就是1层循环就是O(n)，两重循环就是O(n^2)</li>
<li>如果有二分，则为O(logN)</li>
<li>每行一次性的语句则为1</li>
<li>所有行的复杂度相加后除去常数即得复杂度</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="浏览器相关"><a href="#浏览器相关" class="headerlink" title="浏览器相关"></a>浏览器相关</h4><ul>
<li>加载过程<ul>
<li>DNS解析</li>
<li>TCP连接</li>
<li>HTTP请求</li>
<li>HTTP响应</li>
<li>客户端渲染<ul>
<li>根据html生成DOM</li>
<li>根据css生成CSSOM</li>
<li>DOM和CSSOM整合生成RenderTree</li>
<li>布局合成 、绘制渲染</li>
<li>遇到script会阻塞渲染，因为js执行和浏览器渲染共用一个线程</li>
</ul>
</li>
</ul>
</li>
<li>性能优化<ul>
<li>减少页面体积，提升网络加载<ul>
<li>静态资源压缩、合并</li>
<li>静态资源缓存</li>
<li>使用CDN</li>
</ul>
</li>
<li>优化页面渲染<ul>
<li>css放前、js放后</li>
<li>懒加载</li>
<li>减少DOM操作</li>
<li>事件节流</li>
<li>SSR</li>
</ul>
</li>
</ul>
</li>
<li>web安全<ul>
<li>SQL注入</li>
<li>XSS</li>
<li>CSRF</li>
</ul>
</li>
</ul>
<h4 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h4><ul>
<li><p>DNS解析</p>
<ul>
<li>浏览器DNS缓存</li>
<li>DNS prefetch</li>
</ul>
</li>
<li><p>TCP连接</p>
<ul>
<li>长连接</li>
<li>预连接</li>
<li>接入SPDY协议</li>
</ul>
</li>
<li><p>HTTP请求</p>
<ul>
<li>减少次数（loader中的exclude、三方库DllPlugin/DllReferencePlugin）</li>
<li>减少体积（webpack-bundle-analyzer、代码压缩混淆、gzip、tree-shaking、按需加载）</li>
<li>CDN<ul>
<li>content delivery network</li>
<li>2大功能<ul>
<li>缓存</li>
<li>回源</li>
</ul>
</li>
<li>CDN域名和业务服务域名一定要分开，避免cookie无用传输</li>
</ul>
</li>
<li>Gzip<ul>
<li>gzip的内核就是Deflate</li>
<li>通常能减小70%的体积</li>
<li>原理就是把内容中重复的字符串临时替换，使整个文件变小，所以重复率越高，收益越好</li>
<li>nginx等代理文件中可以配置index.js/index.js.gz 以减少cpu临时压缩的消耗</li>
</ul>
</li>
<li>图片优化<ul>
<li>JPEG/JPG 有损压缩、体积小、色彩丰富，常用轮播图，不支持透明</li>
<li>PNG 无损压缩、质量高、支持透明，常用单色小图logo，体积大<ul>
<li>PNG-8  二进制的位数8，最多支持256种颜色</li>
<li>PNG-24 二进制的位数24，最多支持1600万种颜色</li>
</ul>
</li>
<li>SVG<ul>
<li>文本文件</li>
<li>体积小、不失真、可压缩</li>
<li>对图像的处理不是基于像素，而是基于对图像的描述</li>
<li>可以放到HTML的DOM中，也可以单独保存.svg文件</li>
<li>渲染成本比较高，性能要求比较高</li>
</ul>
</li>
<li>Base64<ul>
<li>文本文件</li>
<li>依赖编码，小图标解决方案</li>
<li>编码后，体积会增大1/3</li>
</ul>
</li>
<li>WebP<ul>
<li>年轻的全能选手</li>
<li>支持有损和无损压缩</li>
<li>支持透明、支持动态图、支持丰富的色彩、体积比较小</li>
<li>兼容性比较差，编码时比jpg需要更多计算资源</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>渲染</p>
<ul>
<li>SSR<ul>
<li>SEO</li>
<li>首屏白屏</li>
</ul>
</li>
<li>CSS</li>
<li>JSji</li>
<li>DOM</li>
<li>懒加载</li>
<li>事件节流和防抖</li>
<li>回流和重绘</li>
</ul>
</li>
<li><p>浏览器引擎</p>
<ul>
<li>渲染引擎（内核）<ul>
<li>功能部件<ul>
<li>html解释器，将html输出DOM</li>
<li>css解释器，将css输出CSSOM</li>
<li>布局绘制，合成renderTree</li>
<li>网络</li>
<li>存储</li>
<li>图形、图片解码器</li>
<li>音视频</li>
</ul>
</li>
<li>常见分类<ul>
<li>Trident（IE）</li>
<li>Gecko（Firefox）</li>
<li>Blink（Chrome、Opera）是webkit的一个分支</li>
<li>Webkit（Safari）</li>
</ul>
</li>
<li>优化<ul>
<li>css<ul>
<li>css解释器对每条规则都按从右到左的顺序去匹配，因此要减少选择器嵌套</li>
<li>避免使用通配符，只对需要用到的元素进行选择</li>
<li>css是阻塞渲染的资源，需要尽早加载，尽早渲染，把css往前放</li>
</ul>
</li>
<li>js<ul>
<li>默认的js也会阻塞DOM和CSSOM，因为可能会操作DOM</li>
<li>async模式加载js不会阻塞浏览器，异步加载js，加载完毕后立即执行</li>
<li>defer模式加载js不会阻塞浏览器，异步加载js，加载完毕后延迟到DOMContentLoaded后执行</li>
</ul>
</li>
<li>DOM<ul>
<li>对DOM的修改引发了DOM几何尺寸的变化，浏览器都要重新计算几何属性，再将结果绘制出来，即回流重排</li>
<li>对DOM的修改没有引发几何尺寸的变化，不需要重新计算几何属性，跳过重排直接执行重绘</li>
<li>减少DOM的访问和操作</li>
<li>必要的DOM操作可以使用DocumentFragment，不会有性能问题</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>js引擎<ul>
<li>异步队列<ul>
<li>micro-task<ul>
<li>process.nextTick</li>
<li>promise</li>
<li>MutationObserver</li>
</ul>
</li>
<li>macro-task<ul>
<li>setTimeout</li>
<li>setInteral</li>
<li>setImmediate</li>
<li>IO操作</li>
</ul>
</li>
</ul>
</li>
<li>执行过程<ul>
<li>将一个macro-task执行并出队</li>
<li>将一对micro-task执行并出对</li>
<li>执行渲染，更新界面</li>
<li>处理worker相关的任务</li>
<li>循环，当我们需要在异步任务中实现DOM修改时，把它包装成micro-task是明智的选择</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>浏览器缓存</p>
<ul>
<li><p>MemoryCache</p>
<ul>
<li>本着节约内存的原则，一般较小的资源有几率入内存</li>
</ul>
</li>
<li><p>ServiceWorkerCache 离线缓存</p>
<ul>
<li>脱离主线程之外的独立线程</li>
<li>不能操作DOM，只能做些js的计算，数据的请求</li>
<li>serviceWorker生命周期<ul>
<li>install</li>
<li>active</li>
<li>working</li>
</ul>
</li>
</ul>
</li>
<li><p>HTTPCache</p>
<ul>
<li>强缓存（200）<ul>
<li>expires（http1.0,依赖本地时间）</li>
<li>cache-control(http1.1,完全替代expires，优先级高)<ul>
<li>max-age=31536000(有效时间长度，单位秒)</li>
<li>s-maxage优先级高于max-age，只在代理服务器上有效</li>
<li>public可以被客户端和代理服务器缓存，private只能被客户端缓存，默认private</li>
<li>no-cache 忽略所有客户端缓存，与服务器协商缓存</li>
<li>no-store 忽略所有缓存，包括协商缓存，直接请求资源</li>
</ul>
</li>
</ul>
</li>
<li>协商缓存（304）<ul>
<li>Last-Modified/If-Modified-Since（时间戳）<ul>
<li>只是更新了文件的元信息，比如touch了文件一下，也会造成更新</li>
<li>时间粒度只能到秒，如果1秒内完成了内容的变更，却不会更新</li>
</ul>
</li>
<li>ETag/If-None-Match<ul>
<li>解决上述2个问题</li>
<li>基于文件内容为资源编码的唯一字符串标示</li>
<li>因为ETag的生成要耗费服务器资源，所以是上面的补充，不能完全替代，优先级高于上面<img src="/2020/02/28/fe/http协商缓存响应头设置流程.png" title="http协商缓存响应头设置流程">
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>PushCache </p>
<ul>
<li>http2的特性</li>
<li>是缓存的最后一道防线，在上面3种缓存都未命中的情况下才会询问PushCache</li>
<li>不同的页面共享了一个http2连接，就共享同一个PushCache</li>
<li>会话级的缓存，session关闭，缓存失效</li>
</ul>
</li>
</ul>
</li>
<li><p>本地存储</p>
<ul>
<li>cookie<ul>
<li>状态维持，解决http无状态的问题</li>
<li>体积限制，最大4k</li>
<li>流量消耗</li>
</ul>
</li>
<li>storage<ul>
<li>localStorage 永久有效</li>
<li>sessionStorage 会话级有效</li>
</ul>
</li>
<li>IndexedDB<ul>
<li>非关系型数据库<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">var db;</span><br><span class="line">// 参数1位数据库名，参数2为版本号</span><br><span class="line">const request = window.indexedDB.open(&quot;name&quot;, 1)</span><br><span class="line">// 使用IndexedDB失败时的监听函数</span><br><span class="line">request.onerror = function(event) &#123;</span><br><span class="line">  console.log(&apos;无法使用IndexedDB&apos;)</span><br><span class="line">&#125;</span><br><span class="line">// 成功</span><br><span class="line">request.onsuccess  = function(event)&#123;</span><br><span class="line">  // 此处就可以获取到db实例</span><br><span class="line">  db = event.target.result</span><br><span class="line">  console.log(&quot;你打开了IndexedDB&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// onupgradeneeded事件会在初始化数据库/版本发生更新时被调用，我们在它的监听函数中创建object store</span><br><span class="line">request.onupgradeneeded = function(event)&#123;</span><br><span class="line">  let objectStore</span><br><span class="line">  // 如果同名表未被创建过，则新建test表</span><br><span class="line">  if (!db.objectStoreNames.contains(&apos;test&apos;)) &#123;</span><br><span class="line">    objectStore = db.createObjectStore(&apos;test&apos;, &#123; keyPath: &apos;id&apos; &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">  // 创建事务，指定表格名称和读写权限</span><br><span class="line">  const transaction = db.transaction([&quot;test&quot;],&quot;readwrite&quot;)</span><br><span class="line">  // 拿到Object Store对象</span><br><span class="line">  const objectStore = transaction.objectStore(&quot;test&quot;)</span><br><span class="line">  // 向表格写入数据</span><br><span class="line">  objectStore.add(&#123;id: 1, name: &apos;test1&apos;&#125;)</span><br><span class="line"></span><br><span class="line">  // 操作成功时的监听函数</span><br><span class="line">  transaction.oncomplete = function(event) &#123;</span><br><span class="line">    console.log(&quot;操作成功&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">  // 操作失败时的监听函数</span><br><span class="line">  transaction.onerror = function(event) &#123;</span><br><span class="line">    console.log(&quot;这里有一个Error&quot;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// lazyload</span><br><span class="line">// 获取所有的图片标签</span><br><span class="line">const imgs = document.getElementsByTagName(&apos;img&apos;)</span><br><span class="line">// 获取可视区域的高度</span><br><span class="line">const viewHeight = window.innerHeight || document.documentElement.clientHeight</span><br><span class="line">// num用于统计当前显示到了哪一张图片，避免每次都从第一张图片开始检查是否露出</span><br><span class="line">let num = 0</span><br><span class="line">function lazyload()&#123;</span><br><span class="line">    for(let i=num; i&lt;imgs.length; i++) &#123;</span><br><span class="line">        // 用可视区域高度减去元素顶部距离可视区域顶部的高度</span><br><span class="line">        let distance = viewHeight - imgs[i].getBoundingClientRect().top</span><br><span class="line">        // 如果可视区域高度大于等于元素顶部距离可视区域顶部的高度，说明元素露出</span><br><span class="line">        if(distance &gt;= 0 )&#123;</span><br><span class="line">            // 给元素写入真实的src，展示图片</span><br><span class="line">            imgs[i].src = imgs[i].getAttribute(&apos;data-src&apos;)</span><br><span class="line">            // 前i张图片已经加载完毕，下次从第i+1张开始检查是否露出</span><br><span class="line">            num = i + 1</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 监听Scroll事件</span><br><span class="line">window.addEventListener(&apos;scroll&apos;, lazyload, false);</span><br><span class="line"></span><br><span class="line">// fn是我们需要包装的事件回调, delay是时间间隔的阈值</span><br><span class="line">function throttle(fn, delay) &#123;</span><br><span class="line">  // last为上一次触发回调的时间, timer是定时器</span><br><span class="line">  let last = 0, timer = null</span><br><span class="line">  // 将throttle处理结果当作函数返回</span><br><span class="line">  </span><br><span class="line">  return function () &#123; </span><br><span class="line">    // 保留调用时的this上下文</span><br><span class="line">    let context = this</span><br><span class="line">    // 保留调用时传入的参数</span><br><span class="line">    let args = arguments</span><br><span class="line">    // 记录本次触发回调的时间</span><br><span class="line">    let now = +new Date()</span><br><span class="line">    </span><br><span class="line">    // 判断上次触发的时间和本次触发的时间差是否小于时间间隔的阈值</span><br><span class="line">    if (now - last &lt; delay) &#123;</span><br><span class="line">    // 如果时间间隔小于我们设定的时间间隔阈值，则为本次触发操作设立一个新的定时器</span><br><span class="line">       clearTimeout(timer)</span><br><span class="line">       timer = setTimeout(function () &#123;</span><br><span class="line">          last = now</span><br><span class="line">          fn.apply(context, args)</span><br><span class="line">        &#125;, delay)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 如果时间间隔超出了我们设定的时间间隔阈值，那就不等了，无论如何要反馈给用户一次响应</span><br><span class="line">        last = now</span><br><span class="line">        fn.apply(context, args)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 用新的throttle包装scroll的回调</span><br><span class="line">const better_scroll = throttle(() =&gt; console.log(&apos;触发了滚动事件&apos;), 1000)</span><br><span class="line">document.addEventListener(&apos;scroll&apos;, better_scroll)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// throttle</span><br><span class="line">// fn是我们需要包装的事件回调, interval是时间间隔的阈值</span><br><span class="line">function throttle(fn, interval) &#123;</span><br><span class="line">  // last为上一次触发回调的时间</span><br><span class="line">  let last = 0</span><br><span class="line">  </span><br><span class="line">  // 将throttle处理结果当作函数返回</span><br><span class="line">  return function () &#123;</span><br><span class="line">      // 保留调用时的this上下文</span><br><span class="line">      let context = this</span><br><span class="line">      // 保留调用时传入的参数</span><br><span class="line">      let args = arguments</span><br><span class="line">      // 记录本次触发回调的时间</span><br><span class="line">      let now = +new Date()</span><br><span class="line">      </span><br><span class="line">      // 判断上次触发的时间和本次触发的时间差是否小于时间间隔的阈值</span><br><span class="line">      if (now - last &gt;= interval) &#123;</span><br><span class="line">      // 如果时间间隔大于我们设定的时间间隔阈值，则执行回调</span><br><span class="line">          last = now;</span><br><span class="line">          fn.apply(context, args);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 用throttle来包装scroll的回调</span><br><span class="line">const better_scroll = throttle(() =&gt; console.log(&apos;触发了滚动事件&apos;), 1000)</span><br><span class="line">document.addEventListener(&apos;scroll&apos;, better_scroll)</span><br><span class="line"></span><br><span class="line">// fn是我们需要包装的事件回调, delay是每次推迟执行的等待时间</span><br><span class="line">function debounce(fn, delay) &#123;</span><br><span class="line">  // 定时器</span><br><span class="line">  let timer = null</span><br><span class="line">  </span><br><span class="line">  // 将debounce处理结果当作函数返回</span><br><span class="line">  return function () &#123;</span><br><span class="line">    // 保留调用时的this上下文</span><br><span class="line">    let context = this</span><br><span class="line">    // 保留调用时传入的参数</span><br><span class="line">    let args = arguments</span><br><span class="line"></span><br><span class="line">    // 每次事件被触发时，都去清除之前的旧定时器</span><br><span class="line">    if(timer) &#123;</span><br><span class="line">        clearTimeout(timer)</span><br><span class="line">    &#125;</span><br><span class="line">    // 设立新定时器</span><br><span class="line">    timer = setTimeout(function () &#123;</span><br><span class="line">      fn.apply(context, args)</span><br><span class="line">    &#125;, delay)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 用debounce来包装scroll的回调</span><br><span class="line">const better_scroll = debounce(() =&gt; console.log(&apos;触发了滚动事件&apos;), 1000)</span><br><span class="line">document.addEventListener(&apos;scroll&apos;, better_scroll)</span><br></pre></td></tr></table></figure>

<ul>
<li>性能监测<ul>
<li>可视化工具<ul>
<li>Performance</li>
<li>LightHouse</li>
</ul>
</li>
<li>性能api<ul>
<li>performance</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="技能分层"><a href="#技能分层" class="headerlink" title="技能分层"></a>技能分层</h4><ul>
<li><p>基础页面开发（pc网页）</p>
<ul>
<li>设计稿审查<ul>
<li>确定设计稿的开发友好性（是否有还原成本高和无法实现的地方）</li>
<li>特殊元素是否有合理的边界处理（如文案超出外层容器怎么办）</li>
<li>确定页面的框架结构（layout）</li>
<li>识别可复用的组件（跨页面可复用/当前页面可复用）</li>
</ul>
</li>
<li>编写页面骨骼框架<ul>
<li>盒模型统一 box-sizing:border-box;</li>
<li>布局<ul>
<li>普通文档流</li>
<li>浮动布局</li>
<li>绝对布局</li>
<li>弹性布局</li>
<li>网格布局</li>
</ul>
</li>
</ul>
</li>
<li>填充网页内容</li>
<li>润色<ul>
<li>BEM <ul>
<li>基于组件的css命名规范</li>
<li>block模块，模块名字的单词之间用-连接</li>
<li>element元素，模块中的子元素，用__连接模块名</li>
<li>modifier修饰符，元素的其他形态，用–连接</li>
<li>B-B__E–M</li>
</ul>
</li>
</ul>
</li>
<li>兼容性测试<ul>
<li>html兼容性</li>
<li>css兼容性</li>
<li>js兼容性</li>
</ul>
</li>
</ul>
</li>
<li><p>响应式页面开发（移动端网页） </p>
<ul>
<li>目标<ul>
<li>为不同的浏览器窗口使用不同的样式代码</li>
<li>页面元素的尺寸能够依据浏览器窗口变化而平滑变化</li>
</ul>
</li>
<li>步骤<ul>
<li>添加vierport的meta标签</li>
<li>使用mediaQuery <ul>
<li>@media(min|max-width|height orientation)</li>
<li>两种方式<ul>
<li>style代码里@media (){}</li>
<li><link media="(min-width: 769px)" href="min-769.css"></li>
</ul>
</li>
<li>样式断点，参考bulma框架<ul>
<li>mobile</li>
<li>tablet 769</li>
<li>desktop 1024</li>
<li>widescreen 1216</li>
<li>fullhd 1408</li>
</ul>
</li>
</ul>
</li>
<li>使用viewport单位和rem 解决元素的尺寸能响应变化<ul>
<li>使用vw作为唯一单位<ul>
<li>sass函数将设计稿尺寸的像素单位转换为vw单位</li>
<li>所有尺寸全部转换为vw包括文字</li>
<li>1px使用transform的scale实现</li>
<li>vw缺点就是会无限放大或缩小</li>
</ul>
</li>
<li>vw + rem<ul>
<li>根元素的字体大小为vw，同时限制最大值/最小值并配合body最大宽/最小宽实现断点</li>
<li>其他元素统一使用rem单位<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// iPhone 6尺寸作为设计稿基准</span><br><span class="line">$vw_base: 375; </span><br><span class="line">@function vw($px) &#123;</span><br><span class="line">    @return ($px / $vm_base) * 100vw;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.mod_grid &#123;</span><br><span class="line">    position: relative;</span><br><span class="line">    &amp;::after &#123;</span><br><span class="line">        // 实现1物理像素的下边框线</span><br><span class="line">        content: &apos;&apos;;</span><br><span class="line">        position: absolute;</span><br><span class="line">        z-index: 1;</span><br><span class="line">        pointer-events: none;</span><br><span class="line">        background-color: #ddd;</span><br><span class="line">        height: 1px;</span><br><span class="line">        left: 0;</span><br><span class="line">        right: 0;</span><br><span class="line">        top: 0;</span><br><span class="line">        @media only screen and (-webkit-min-device-pixel-ratio: 2) &#123;</span><br><span class="line">            -webkit-transform: scaleY(0.5);</span><br><span class="line">            -webkit-transform-origin: 50% 0%;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// vw+rem</span><br><span class="line">// rem 单位换算：定为 75px 只是方便运算，750px-75px、640-64px、1080px-108px，如此类推</span><br><span class="line">$vw_fontsize: 75; // iPhone 6尺寸的根元素大小基准值</span><br><span class="line">@function rem($px) &#123;</span><br><span class="line">     @return ($px / $vw_fontsize ) * 1rem;</span><br><span class="line">&#125;</span><br><span class="line">// 根元素大小使用 vw 单位</span><br><span class="line">$vw_design: 750;</span><br><span class="line">html &#123;</span><br><span class="line">    font-size: ($vw_fontsize / ($vw_design / 2)) * 100vw; </span><br><span class="line">    // 同时，通过Media Queries 限制根元素最大最小值</span><br><span class="line">    @media screen and (max-width: 320px) &#123;</span><br><span class="line">        font-size: 64px;</span><br><span class="line">    &#125;</span><br><span class="line">    @media screen and (min-width: 540px) &#123;</span><br><span class="line">        font-size: 108px;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// body 也增加最大最小宽度限制，避免默认100%宽度的 block 元素跟随 body 而过大过小</span><br><span class="line">body &#123;</span><br><span class="line">    max-width: 540px;</span><br><span class="line">    min-width: 320px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>滑屏应用开发（活动营销页面）</p>
<ul>
<li>swiper</li>
<li>自己实现<ul>
<li>手势动作判断</li>
<li>执行相应动画</li>
</ul>
</li>
</ul>
</li>
<li><p>动效开发（活动营销页面）</p>
<ul>
<li>transition 补间动画 </li>
<li>animation 逐帧动画+补间动画</li>
<li>gif</li>
<li>js控制关键帧sprite的background-position</li>
<li>canvas库（createJS，pixi.js）</li>
<li>svg+SMIL<ul>
<li>声明视窗 <svg width="100" height="100"/></li>
<li>绘制路径 <path d="指令数据" style="填充描边"></path></li>
<li>绘制图形 <circle cx cy r style></circle></li>
<li>添加动画 <animatemotion></animatemotion></li>
<li>SMIL synchronizedMultimediaIntegrationLanguage同步多媒体集成语言，主要用作交互</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="软技能"><a href="#软技能" class="headerlink" title="软技能"></a>软技能</h4><ul>
<li>健身</li>
<li>理财</li>
<li>韧性</li>
<li>责任心</li>
<li>持续学习能力</li>
<li>团队合作能力</li>
<li>交流沟通能力</li>
</ul>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2020/02/22/web-sec/"><span>web-sec</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2020/02/22/web-sec/" rel="bookmark">
        <time class="entry-date published" datetime="2020-02-22T04:36:13.000Z">
          2020-02-22
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="安全问题"><a href="#安全问题" class="headerlink" title="安全问题"></a>安全问题</h3><ul>
<li>服务端<ul>
<li>SQL注入</li>
<li>命令注入</li>
<li>文件上传</li>
<li>暴力破解</li>
</ul>
</li>
<li>客户端<ul>
<li>XSS</li>
<li>CSRF</li>
<li>点击劫持</li>
<li>URL跳转</li>
<li>钓鱼 仿冒官网进行信息获取</li>
<li>暗链 植入灰黑产业的链接，用户不可见，但可以提高排名</li>
<li>webshell 通过网页部署后门程序，执行非法命令</li>
</ul>
</li>
</ul>
<h3 id="web基础"><a href="#web基础" class="headerlink" title="web基础"></a>web基础</h3><ul>
<li>URL规范<ul>
<li>schema://</li>
<li>username:password@</li>
<li>hostname:port/</li>
<li>path?</li>
<li>querystring#</li>
<li>anchor</li>
</ul>
</li>
<li>HTTP报文<ul>
<li>头行</li>
<li>头部</li>
<li>空行</li>
<li>主体</li>
</ul>
</li>
<li>SQL<ul>
<li>order by FIELD/index ASC/DESC，默认升序</li>
<li>select * from t1 union select * from t2 默认合并重复</li>
<li>select * from t1 union all select * from t2 不合并重复</li>
<li>注释 <ul>
<li><h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1></li>
<li>– 内容 </li>
<li>/* 内容 */</li>
</ul>
</li>
<li>内置命令<ul>
<li>source file #导入sql文件</li>
<li>select current_user #显示当前用户</li>
<li>select load_file(PATH) #显示文件内容</li>
</ul>
</li>
</ul>
</li>
<li>PHP<ul>
<li>脚本范围 <?php 内容 ?></li>
<li>注释<ul>
<li>// 内容</li>
<li><h1 id="内容-1"><a href="#内容-1" class="headerlink" title="内容"></a>内容</h1></li>
<li>/* 内容 */</li>
</ul>
</li>
<li>echo 可以用，一次可以输入多个变量</li>
<li>print 一次只能输出一个变量，有返回值</li>
<li>$var表示变量，区分大小写</li>
<li>引入外部php文件<ul>
<li>include 当脚本错误时，只是警告，继续执行</li>
<li>require 当脚本错误时，停止脚本执行</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="安全漏洞"><a href="#安全漏洞" class="headerlink" title="安全漏洞"></a>安全漏洞</h2><h3 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h3><ul>
<li>cross site scripting 跨站脚本攻击</li>
<li>分类<br>XSS类型 ｜ 存储型 ｜ 反射型 ｜ DOM型</li>
<li>– ｜ — ｜ — ｜—<br>触发过程 ｜ 黑客构造XSS后用户访问XSS页面 ｜ 用户访问XSS页面 ｜ 用户访问XSS页面<br>数据存储 ｜ 数据库 ｜ URL ｜ URL的hash中<br>谁来输出 ｜ 后端WEB程序 ｜ 后端WEB程序 ｜ 前端JS<br>输出位置 ｜ HTTP响应 ｜ HTTP响应 ｜ 动态构造的DOM</li>
</ul>
<h3 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h3><ul>
<li>cross site request forgery 跨站请求伪造</li>
<li>在用户登陆的情况下以不知情的方式执行非法操作</li>
</ul>
<h3 id="点击劫持"><a href="#点击劫持" class="headerlink" title="点击劫持"></a>点击劫持</h3><ul>
<li>通过覆盖不可见的iframe引导用户点击操作的恶意行为</li>
<li>也称UI覆盖攻击</li>
</ul>
<h3 id="URL跳转漏洞"><a href="#URL跳转漏洞" class="headerlink" title="URL跳转漏洞"></a>URL跳转漏洞</h3><ul>
<li>借助未验证的URL跳转，把非法的URL嫁接到安全的URL后引导用户到非法网站</li>
<li>如img.alipay.com/sys/html/wait.html?goto=恶意网址</li>
<li>现在的短网址更隐蔽</li>
<li>方式<ul>
<li>header头的location</li>
<li>meta标签的refresh,url</li>
<li>js的location.href </li>
</ul>
</li>
</ul>
<h3 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h3><ul>
<li>SQL injection</li>
<li>万能密码<ul>
<li>利用’ –进行字符串的闭合和注释进行攻击</li>
<li>本质就是SQL注入的利用方式</li>
</ul>
</li>
<li>原理<ul>
<li>数据当作了代码来执行</li>
<li>本质就是数据和代码未分离</li>
</ul>
</li>
</ul>
<h3 id="命令注入"><a href="#命令注入" class="headerlink" title="命令注入"></a>命令注入</h3><ul>
<li>必要条件<ul>
<li>调用可执行系统命令的函数(system/eval…)</li>
<li>函数或函数的参数可控</li>
<li>拼接命令注入</li>
</ul>
</li>
</ul>
<h3 id="文件操作漏洞"><a href="#文件操作漏洞" class="headerlink" title="文件操作漏洞"></a>文件操作漏洞</h3><ul>
<li>上传漏洞<ul>
<li>正常的有上传头像、附件的上传功能</li>
<li>上传webShell</li>
<li>上传木马</li>
</ul>
</li>
<li>下载漏洞<ul>
<li>下载系统任意文件</li>
<li>下载程序代码</li>
</ul>
</li>
</ul>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2020/02/17/vue/"><span>vue</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2020/02/17/vue/" rel="bookmark">
        <time class="entry-date published" datetime="2020-02-17T04:10:54.000Z">
          2020-02-17
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="cli"><a href="#cli" class="headerlink" title="cli"></a>cli</h2><ul>
<li>features<ul>
<li>babel</li>
<li>ts</li>
<li>pwa</li>
<li>router</li>
<li>vuex</li>
<li>cssPreProcessor</li>
<li>linter/formatter</li>
<li>unitTesting</li>
<li>e2eTesting</li>
</ul>
</li>
<li>dir<ul>
<li>node_modules</li>
<li>public<ul>
<li>favicon.ico</li>
<li>index.html</li>
</ul>
</li>
<li>src<ul>
<li>assets</li>
<li>components</li>
<li>router</li>
<li>store</li>
<li>views</li>
<li>main.js</li>
<li>App.vue</li>
</ul>
</li>
<li>tests<ul>
<li>unit</li>
<li>e2e</li>
</ul>
</li>
<li>.gitignore</li>
<li>.postcssrc.js</li>
<li>.eslintrc.js</li>
<li>.browserslistrc        </li>
<li>babel.config.js</li>
<li>package.json</li>
<li>package-lock.json</li>
<li>README.md</li>
</ul>
</li>
<li>ext<ul>
<li>npm/yarm</li>
<li>webpack</li>
<li>环境配置</li>
<li>接口配置</li>
<li>单页应用</li>
<li>多页应用</li>
<li>实用工具</li>
<li>开发技巧</li>
</ul>
</li>
</ul>
<h2 id="browserlist"><a href="#browserlist" class="headerlink" title="browserlist"></a>browserlist</h2><ul>
<li>目标浏览器列表，给所有插件共享如autoprefixer等 </li>
<li>可以写单独的.browserslistrc文件也可写在package.json.browserslist中</li>
<li>最终的数据来源于CanIUse</li>
<li>可以在项目中运行npx browserslist进行查看</li>
</ul>
<h2 id="env环境"><a href="#env环境" class="headerlink" title="env环境"></a>env环境</h2><ul>
<li>环境<ul>
<li>公共配置</li>
<li>开发环境配置</li>
<li>测试环境配置</li>
<li>生产环境配置</li>
</ul>
</li>
<li>推荐使用js文件进行config配置，可以支持动态参数/变量等</li>
</ul>
<h2 id="单页应用配置"><a href="#单页应用配置" class="headerlink" title="单页应用配置"></a>单页应用配置</h2><ul>
<li>路由配置<ul>
<li>如果路由存在二级目录，需要添加base属性值否则默认/</li>
<li>默认路由模式为hash，可修改history</li>
<li>路由组件可以进行懒加载 component:()=&gt;import(/* webpackChunkName: “name” */ “path2vue”)</li>
</ul>
</li>
<li>vuex配置<ul>
<li>通过 actions 异步提交 mutations 去 修改 state 的值并通过 getter 获取</li>
<li>大型项目目录<ul>
<li>index.js #组装模块并导出store<ul>
<li>state</li>
<li>mutations</li>
<li>actions</li>
<li>getters</li>
<li>modules</li>
</ul>
</li>
<li>actions.js #根级别的action</li>
<li>mutations.js #跟级别的mutation</li>
<li>modules<ul>
<li>moduleA.js A模块<ul>
<li>state</li>
<li>mutations</li>
<li>actions</li>
<li>getters</li>
</ul>
</li>
<li>moduleB.js B模块</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>接口配置<ul>
<li>目录<ul>
<li>src<ul>
<li>services<ul>
<li>index.js #接口封装</li>
<li>moduleA.js #模块A接口</li>
<li>moduleB.js #模块B接口</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>devServer配置proxy<ul>
<li>moduleX.js中一般不配置host</li>
<li>devServer.proxy.PATTERN.target代理目标地址</li>
</ul>
</li>
</ul>
</li>
<li>公共设施配置<ul>
<li>封装公共的方法等</li>
<li>目录<ul>
<li>src<ul>
<li>common<ul>
<li>index.js #公共配置入口，统一向外暴露</li>
<li>validate.js #表单验证</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>多页应用配置<ul>
<li>entries</li>
<li>htmlWebpackPlugin</li>
<li>上面2个分开的配置也可以统一使用pages配置</li>
<li>多页间路由跳转必须使用location的原生方法，可以封装到Vue原型链上</li>
<li>多页间路由跳转需要注意historyApi前后端配置</li>
<li>模版配置时需要注意inject的值防止重复注入</li>
<li>模块配置可以通过htmlWebpackPlugin.options添加自定义配置</li>
</ul>
</li>
<li>webpack配置<ul>
<li>alias解决复杂路径问题，css/html中需要~</li>
<li>CompressionWebpackPlugin进行压缩如gzip</li>
</ul>
</li>
</ul>
<h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><ul>
<li><p>基础</p>
<ul>
<li>过多的if/switch判断可以用对象代替</li>
<li>路由跳转使用name而不是path，方便维护</li>
<li>key值推荐使用数组中不会变化且唯一的值</li>
<li>使用computed代替watch</li>
<li>统一管理缓存变量，增加types.js把字符串变量化</li>
<li>避免for/in遍历数组，防止数组原型被修改</li>
</ul>
</li>
<li><p>api</p>
<ul>
<li>Vue.config.performance=true;开启性能监控，配合VuePerformanceDevtool插件分析</li>
<li>捕获异常<ul>
<li>try/catch</li>
<li>window.onerror</li>
<li>Vue.config.errorHandler=(err,vm,info)=&gt;{}</li>
<li>watch:{obj:{handler(){},deep:b,immediate:b}}</li>
</ul>
</li>
</ul>
</li>
<li><p>可复用</p>
<ul>
<li>步骤<ul>
<li>出现重复代码</li>
<li>封装成一个变量</li>
<li>封装函数</li>
<li>封装组件</li>
<li>封装插件</li>
</ul>
</li>
<li>组件<ul>
<li>封装<ul>
<li>全部封装</li>
<li>插槽封装</li>
</ul>
</li>
<li>分类<ul>
<li>容器组件，主要处理组件逻辑</li>
<li>展示组件，主要处理组件样式</li>
</ul>
</li>
</ul>
</li>
<li>插件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/* toast.js */</span><br><span class="line">import ToastComponent from &apos;./toast.vue&apos; // 引入组件</span><br><span class="line"></span><br><span class="line">let $vm</span><br><span class="line"></span><br><span class="line">export default &#123;    </span><br><span class="line">    install(Vue, options) &#123;</span><br><span class="line">        </span><br><span class="line">        // 判断实例是否存在</span><br><span class="line">        if (!$vm) &#123;            </span><br><span class="line">            const ToastPlugin = Vue.extend(ToastComponent); // 创建一个“扩展实例构造器”</span><br><span class="line">            </span><br><span class="line">            // 创建 $vm 实例</span><br><span class="line">            $vm = new ToastPlugin(&#123;                </span><br><span class="line">                el: document.createElement(&apos;div&apos;)  // 声明挂载元素          </span><br><span class="line">            &#125;);            </span><br><span class="line">            </span><br><span class="line">            document.body.appendChild($vm.$el); // 把 toast 组件的 DOM 添加到 body 里</span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        // 给 toast 设置自定义文案和时间</span><br><span class="line">        let toast = (text, duration) =&gt; &#123;</span><br><span class="line">            $vm.text = text;</span><br><span class="line">            $vm.duration = duration;</span><br><span class="line">            </span><br><span class="line">            // 在指定 duration 之后让 toast 消失</span><br><span class="line">            setTimeout(() =&gt; &#123;</span><br><span class="line">                $vm.isShow = false;  </span><br><span class="line">            &#125;, $vm.duration);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 判断 Vue.$toast 是否存在</span><br><span class="line">        if (!Vue.$toast) &#123;            </span><br><span class="line">            Vue.$toast = toast;        </span><br><span class="line">        &#125;        </span><br><span class="line">        </span><br><span class="line">        Vue.prototype.$toast = Vue.$toast; // 全局添加 $toast 事件</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 入口文件注册</span><br><span class="line">import Toast from &apos;@/widgets/toast/toast.js&apos;</span><br><span class="line"></span><br><span class="line">Vue.use(Toast); // 注册 Toast</span><br><span class="line"></span><br><span class="line"># 使用</span><br><span class="line">this.$toast(&apos;Hello World&apos;, 2000);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>开发工具</p>
<ul>
<li>vueDevtool</li>
<li>vuePerformanceDevtool</li>
<li>pageSpeedInsights</li>
<li>JSONViewer</li>
<li>webpack-bundle-analyser</li>
<li>safari调试ios页面</li>
<li>chrome://inspect调试安卓页面</li>
</ul>
</li>
</ul>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2020/02/12/ldap/"><span>ldap</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2020/02/12/ldap/" rel="bookmark">
        <time class="entry-date published" datetime="2020-02-12T04:12:40.000Z">
          2020-02-12
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="ldap"><a href="#ldap" class="headerlink" title="ldap"></a>ldap</h2><ul>
<li>lightweight directory access protocol</li>
<li>运行在TCP/IP上的目录访问协议，本质上是一个为只读访问而优化的非关系数据库</li>
<li>ldap中的信息按照目录信息数组织结构</li>
<li>树中的一个节点称之为条目Entry，包含了节点的属性和属性值</li>
<li>ldap服务的实现<ul>
<li>windows的AD</li>
<li>openldap</li>
</ul>
</li>
</ul>
<h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><ul>
<li>Entry/Object 条目或对象，ldap中的每个单元都认为是条目</li>
<li>DN 条目名称</li>
<li>OU 组织名称</li>
<li>DC 域组件，一般多个，如dc=baidu,dc=com</li>
<li>CN 通用名称，如人名或对象名</li>
</ul>
<h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 安装OpenLDAP</span><br><span class="line">mkdir -p ~/openldap/&#123;config,database&#125;</span><br><span class="line">docker pull osixia/openldap:1.2.2</span><br><span class="line">docker run -d --name ldap-service --hostname ldap-service -p 389:389 -p 689:689 -v ~/openldap/database:/var/lib/ldap -v ~/openldap/config:/etc/ldap/slapd.d --env LDAP_ORGANISATION=&quot;test.com&quot; --env LDAP_DOMAIN=&quot;test.com&quot; --env LDAP_ADMIN_PASSWORD=&quot;password&quot; --env LDAP_TLS=false --detach osixia/openldap:1.2.2</span><br><span class="line"></span><br><span class="line"># 图形管理工具</span><br><span class="line">docker pull osixia/phpldapadmin:0.7.2</span><br><span class="line">docker run --name phpldapadmin-service -p 6443:443 -p 6680:80 --hostname phpldapadmin-service --link ldap-service:test.com --env PHPLDAPADMIN_LDAP_HOSTS=test.com --env PHPLDAPADMIN_HTTPS=false --detach osixia/phpldapadmin:0.7.2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 访问 http://localhost:6680</span><br><span class="line"># 账号 cn=admin,dc=test,dc=com</span><br><span class="line"># 密码 password</span><br></pre></td></tr></table></figure>

<h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><ul>
<li>增加用户组</li>
<li>增加用户</li>
<li>更新用户属性</li>
<li>对接gitlab/jira系统</li>
</ul>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2019/12/08/refe/"><span>refe</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2019/12/08/refe/" rel="bookmark">
        <time class="entry-date published" datetime="2019-12-08T01:52:17.000Z">
          2019-12-08
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h2><ul>
<li>学习<ul>
<li>0基础的可以学习《js高级程序设计》《精通css》，MDN网站等</li>
<li>进阶学习方法<ul>
<li>建立知识架构<ul>
<li>逻辑性和完备性</li>
<li>任何语言都是用规定的文法表达特定的语义最终操作运行时的过程</li>
</ul>
</li>
<li>追本溯源</li>
</ul>
</li>
</ul>
</li>
<li>js知识架构<ul>
<li>文法<ul>
<li>词法</li>
<li>语法</li>
</ul>
</li>
<li>语义</li>
<li>运行时（程序=数据结构+算法）<ul>
<li>数据结构<ul>
<li>类型(7种基本类型和7种语言类型)</li>
<li>实例(内置对象等)</li>
</ul>
</li>
<li>算法（执行过程）<ul>
<li>程序与模块</li>
<li>事件循环</li>
<li>微任务</li>
<li>函数/语句的执行</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>html/css知识架构<ul>
<li>html<ul>
<li>元素(功能)<ul>
<li>文档元信息(meta/link/style/base)</li>
<li>语义相关内容(section/nav)</li>
<li>链接(文档内/外链接)</li>
<li>替换型元素(img/audio/video)</li>
<li>表单(input/button)</li>
<li>表格(table/thead)</li>
<li>总集</li>
</ul>
</li>
<li>语言<ul>
<li>实体</li>
<li>命名空间</li>
<li>补充标准ARIA</li>
</ul>
</li>
<li>补充标准</li>
</ul>
</li>
<li>css<ul>
<li>语言<ul>
<li>@rule</li>
<li>选择器</li>
<li>单位</li>
</ul>
</li>
<li>功能<ul>
<li>布局(正常流/弹性布局)</li>
<li>绘制(颜色和形状/文字等)</li>
<li>交互(动画和其他交互)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>浏览器实现原理和api<ul>
<li>实现原理<ul>
<li>解析</li>
<li>构建DOM</li>
<li>计算CSS</li>
<li>渲染、合成和绘制</li>
</ul>
</li>
<li>api<ul>
<li>DOM</li>
<li>CSSOM</li>
<li>事件</li>
<li>api总集和</li>
</ul>
</li>
</ul>
</li>
<li>前端工程实践<ul>
<li>性能</li>
<li>工具链</li>
<li>持续集成</li>
<li>搭建系统</li>
<li>架构和基础库<h2 id="js"><a href="#js" class="headerlink" title="js"></a>js</h2><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3></li>
</ul>
</li>
<li>7种语言类型<ul>
<li>Undefined<ul>
<li>undefined</li>
</ul>
</li>
<li>Null<ul>
<li>null</li>
</ul>
</li>
<li>String<ul>
<li>最大长度2^53-1，是指字符串的UTF16编码长度</li>
<li>通常使用utf8和utf16</li>
<li>unicode码点通常U+?表示，0-65536码点称为基本字符区域BMP</li>
</ul>
</li>
<li>Number<ul>
<li>有精度限制，符合双精度浮点数规则</li>
<li>NaN占用了一个数字</li>
<li>Infinity无穷大</li>
<li>-Infinity负无穷大</li>
<li>区分是+0还是-0的方式就是检测1/x是Infinity还是-Infinity</li>
<li>比较浮点数可以通过两个数的差的绝对值是否小于最小精度值</li>
<li>Math.abs(0.1 + 0.2 - 0.3) &lt;= Number.EPSILON</li>
</ul>
</li>
<li>Boolean<ul>
<li>true</li>
<li>false</li>
</ul>
</li>
<li>Object<ul>
<li>.运算符提供了装箱操作，在基础类型上构造临时对象</li>
</ul>
</li>
<li>Symbol<ul>
<li>一切非字符串的对象key的集合，ES6中整个对象系统被Symbol重塑</li>
<li>Symbol可以有字符串类型的描述，但即使描述相同Symbol也不相等</li>
<li>var mySymbol = Symbol(‘label’), 使用new调用会报错</li>
</ul>
</li>
</ul>
</li>
<li>类型转换<ul>
<li>StringToNumber<ul>
<li>支持二进制/八进制/十进制/十六进制</li>
<li>支持正负号和科学计数法</li>
<li>parseInt建议传入第二个进制参数，parseFloat只支持十进制</li>
</ul>
</li>
<li>装箱转换<ul>
<li>基本类型转换成对应的对象</li>
<li>Object()显示装箱，函数的call方法可以强迫产生装箱</li>
<li>装箱机制会频繁产生临时对象，性能要求高时应避免装箱操作</li>
<li>var symbolObject = (function(){return this;}).call(Symbol(“a”))</li>
<li>typeof symbolObject 为 object</li>
<li>symbolObject.constructor 为 Symbol</li>
<li>symbolObject instanceof Symbol也为true</li>
</ul>
</li>
<li>拆箱转换<ul>
<li>ToPrimitive()是对象类型到基本类型的转换</li>
<li>根据运算上下文尝试调用valueOf()和toString()进行拆箱</li>
<li>如果都不存在，或返回的不是基本类型则会产生类型错误TypeError</li>
<li>ES6可以显示指定o[Symbol.toPrimitive]=()=&gt;{return ‘’}</li>
<li>ES6显示指定后toString()和valueOf()都不会被调用了</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="html-css"><a href="#html-css" class="headerlink" title="html/css"></a>html/css</h2><h2 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h2><h2 id="综合应用"><a href="#综合应用" class="headerlink" title="综合应用"></a>综合应用</h2>
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2019/11/16/pm/"><span>pm</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2019/11/16/pm/" rel="bookmark">
        <time class="entry-date published" datetime="2019-11-16T07:43:34.000Z">
          2019-11-16
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="常识篇"><a href="#常识篇" class="headerlink" title="常识篇"></a>常识篇</h2><h3 id="转型三大误区"><a href="#转型三大误区" class="headerlink" title="转型三大误区"></a>转型三大误区</h3><ul>
<li>凡事事必躬亲<ul>
<li>成功施加影响三个层次<ul>
<li>让人知道要做 Awareness</li>
<li>有动力做 Desire</li>
<li>有能力做 Ability(短期借调/内部转岗/外部引入)</li>
</ul>
</li>
<li>为什么要做/为什么现在做/获取认同和激发动力/选择授权对象</li>
</ul>
</li>
<li>追在屁股后面监工<ul>
<li>明确目标</li>
<li>建立机制</li>
<li>形成秩序(流程和规则)</li>
</ul>
</li>
<li>拿着锤子看哪里都是钉子<ul>
<li>从项目和团队真实痛点出发</li>
</ul>
</li>
</ul>
<h3 id="十大领域五大过程组"><a href="#十大领域五大过程组" class="headerlink" title="十大领域五大过程组"></a>十大领域五大过程组</h3><ul>
<li>国际三大项目管理研究体系<ul>
<li>PMI 美国项目管理协会</li>
<li>IPMA 欧洲的国际项目管理协会</li>
<li>PRINCE2 英国</li>
</ul>
</li>
<li>项目<ul>
<li>项目是为创造独特的产品、服务或成果而进行的临时性工作</li>
<li>项目管理是将各种知识、技能、工具、技术应用于项目活动，满足项目的要求，是变理想为现实，化抽象为具体的一门科学和艺术</li>
<li>PMI把项目管理分为<ul>
<li>十大知识领域</li>
<li>五大过程组49个子过程</li>
</ul>
</li>
</ul>
</li>
<li>十大知识领域<ul>
<li>整合管理 1个整体领域</li>
<li>范围管理 4个核心领域</li>
<li>进度管理 4个核心领域</li>
<li>成本管理 4个核心领域</li>
<li>质量管理 4个核心领域</li>
<li>资源管理 5个辅助领域</li>
<li>沟通管理 5个辅助领域</li>
<li>干系人管理 5个辅助领域</li>
<li>风险管理 5个辅助领域</li>
<li>采购管理 5个辅助领域<img src="/2019/11/16/pm/10大领域管理.png" title="10大领域管理"></li>
</ul>
</li>
<li>五大过程组(PDCA戴明环Plan/Do/Check/Act)
<ul>
<li>启动过程组(千里之行始于足下)<ul>
<li>识别干系人</li>
<li>制定项目章程</li>
</ul>
</li>
<li>规划过程组(运筹帷幄决胜千里) </li>
<li>执行过程组(言出必行行之必果)</li>
<li>监控过程组(审时度势沉着应变)</li>
<li>收尾过程组(慎终如始则无败事)</li>
</ul>
</li>
<li>网易项目管理<img src="/2019/11/16/pm/网易项目管理纲领.png" title="网易项目管理纲领"> 
 

</li>
</ul>
<h2 id="硬技能篇"><a href="#硬技能篇" class="headerlink" title="硬技能篇"></a>硬技能篇</h2><h3 id="启动：识别项目四类干系人"><a href="#启动：识别项目四类干系人" class="headerlink" title="启动：识别项目四类干系人"></a>启动：识别项目四类干系人</h3><ul>
<li>干系人识别 
 </li>
<li>高利益高权利<ul>
<li>代表就是项目发起人sponsor </li>
</ul>
</li>
<li>低利益高权力<ul>
<li>代表是职能经理 </li>
</ul>
</li>
<li>高利益低权利<ul>
<li>代表项目组成员 </li>
</ul>
</li>
<li>低利益低权利<ul>
<li>代表外围支持人员</li>
</ul>
</li>
</ul>
<h3 id="规划：排除计划中的“延期地雷”"><a href="#规划：排除计划中的“延期地雷”" class="headerlink" title="规划：排除计划中的“延期地雷”"></a>规划：排除计划中的“延期地雷”</h3><ul>
<li>计划是市场需求或发起人的期望和团队生产力之间的平衡结果</li>
<li>计划是用来对焦的，做计划就是集体对焦的过程</li>
<li>雷区<ul>
<li>不够具体<ul>
<li>做计划的第一个标准动作WBS(work breakdown structure)工作分解</li>
<li>WBS就是把项目工作按阶段可交付成果分解成较小的易于管理的组成部分</li>
<li>明确分成多少阶段多少块内容，涉及哪些角色和环节，将工作项拆解到3个工作日内，具体到人</li>
</ul>
</li>
<li>不够全面<ul>
<li>做计划的第二个标准动作识别依赖并画出关键路径，从目标的角度进行统筹思考</li>
</ul>
</li>
<li>不够准确<ul>
<li>做计划第三个标准动作定义完成标准</li>
<li>完成标准就是某时间点需要完成的事项列表或是达到某些指标</li>
</ul>
</li>
<li>没有共识<ul>
<li>做计划的第四个标准动作达成共识并公开透明</li>
<li>召开全员规划会，对齐信息达成共识，发邮件给干系人正式告知</li>
</ul>
</li>
<li>不够即时<ul>
<li>做计划的第五个标准动作及时调整变更</li>
<li>公开告知所有项目组成员</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="执行：打造品质要从头开始闭环"><a href="#执行：打造品质要从头开始闭环" class="headerlink" title="执行：打造品质要从头开始闭环"></a>执行：打造品质要从头开始闭环</h3><ul>
<li>闭环验证方法<ul>
<li>方案评审(OARP决策机制)<ul>
<li>Owner 负责人，负责给出方案，组织各方讨论并推进做出决策</li>
<li>Approver 批准者</li>
<li>Reviewer 审核者</li>
<li>Participant 参与者 
 </li>
</ul>
</li>
<li>BugBash(bug大扫除)<ul>
<li>时间：在阶段性活动后，需要1-2个小时</li>
<li>地点：集合到一起，活动更有氛围</li>
<li>参与者：研发、测试、产品、设计、运营等</li>
<li>现场安排：反馈问题可视化，现场氛围营造</li>
<li>活动结束：公示结果，现场奖励，明确改进计划并周知</li>
</ul>
</li>
<li>冒烟用例评审<ul>
<li>冒烟测试用例是开发和测试之间最基础的合约，是测试的准入标准</li>
<li>可通过记录冒烟测试通过率来共同提高质量</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="监控：进展巧汇报，用数据说话"><a href="#监控：进展巧汇报，用数据说话" class="headerlink" title="监控：进展巧汇报，用数据说话"></a>监控：进展巧汇报，用数据说话</h3><ul>
<li><p>紧急汇报：直面问题有章法</p>
<ul>
<li>紧急报告基本元素 <ul>
<li>事件描述</li>
<li>影响后果</li>
<li>跟进分析</li>
<li>响应措施(包含负责人及时间表)</li>
<li>所需支持</li>
</ul>
</li>
</ul>
</li>
<li><p>常规汇报：项目周报三个问题</p>
<ul>
<li>项目整体进展状态？</li>
<li>风险是否可控？</li>
<li>目标达成有没有问题  
</li>
</ul>
</li>
<li><p>数据汇报：善用透明的力量</p>
<ul>
<li>数据指标</li>
<li>jira图表<ul>
<li>发布倒计时</li>
<li>工作量燃尽图</li>
<li>剩余工作量</li>
<li>工作状态分布</li>
</ul>
</li>
<li>数据透明给团队，利用团队的力量</li>
</ul>
</li>
</ul>
<h3 id="收尾：项目复盘，持续改进"><a href="#收尾：项目复盘，持续改进" class="headerlink" title="收尾：项目复盘，持续改进"></a>收尾：项目复盘，持续改进</h3><ul>
<li>设定开放的基调，认清目的，避免追责</li>
<li>会前准备，梳理整个版本的历程</li>
<li>复盘流程<ul>
<li>现场回顾总结(目标/进度/变更/质量等)</li>
<li>每个人总结做的好/不好的3个点</li>
<li>白板前review</li>
<li>集体投票</li>
<li>总结并讨论改进方案  </li>
</ul>
</li>
<li>打造团队持续改进能力<ul>
<li></li>
</ul>
</li>
</ul>
<h2 id="软实力篇"><a href="#软实力篇" class="headerlink" title="软实力篇"></a>软实力篇</h2>
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2019/10/01/flutter/"><span>flutter</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2019/10/01/flutter/" rel="bookmark">
        <time class="entry-date published" datetime="2019-10-01T08:24:22.000Z">
          2019-10-01
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="flutter开发起步"><a href="#flutter开发起步" class="headerlink" title="flutter开发起步"></a>flutter开发起步</h1><h2 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h2><ul>
<li>底层渲染逻辑skia<ul>
<li>利用自己的渲染引擎skia，不依赖OS的组件</li>
<li>保证了高度一致性</li>
</ul>
</li>
<li>上层开发语言dart<ul>
<li>Dart同时支持JIT/AOT</li>
<li>开发期调试效率高，发布期执行性能好<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2></li>
</ul>
</li>
<li>跨平台</li>
<li>高保真(自己的渲染引擎skia完成了渲染的闭环，不用js扩展调用原生)</li>
<li>高性能</li>
</ul>
<h2 id="分层架构"><a href="#分层架构" class="headerlink" title="分层架构"></a>分层架构</h2><ul>
<li>embedder<ul>
<li>操作系统适配层</li>
<li>实现了渲染设置，线程设置，平台插件适配等</li>
</ul>
</li>
<li>engine<ul>
<li>skia和text提供了调用底层渲染和排版的能力</li>
<li>dart提供了运行时调用dart和渲染引擎的能力</li>
</ul>
</li>
<li>framework<ul>
<li>dart实现的UI SDK包含动画、图形绘制、手势识别等<img src="/2019/10/01/flutter/flutterArch.png" title="flutter">

</li>
</ul>
</li>
</ul>
<h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><ul>
<li>Widget以树的形式组织成控件树</li>
<li>flutter通过每个控件创建不同类型的渲染对象组成渲染对象树</li>
<li>渲染对象树通过4个阶段完成展示<ul>
<li>布局 采用深度优先机制遍历渲染对象树，决定对象的位置和尺寸(支持布局边界和父约束)</li>
<li>绘制 按位置和尺寸绘制到不同的图层，采用深度优先机制遍历(支持重绘边界)</li>
<li>合成 将所有图层根据位置，尺寸，层级，大小，透明度等规则计算出最终显示效果简化渲染树</li>
<li>渲染 几何图层数据交给skia引擎加工成二维图像数据最终给GPU进行渲染<img src="/2019/10/01/flutter/flutter.jpg" title="flutter技术点">

</li>
</ul>
</li>
</ul>
<h2 id="跨平台方案"><a href="#跨平台方案" class="headerlink" title="跨平台方案"></a>跨平台方案</h2><ul>
<li><p>三个时代</p>
<ul>
<li>web容器时代(cordova,ionic,微信小程序都使用webview+jsBridge)</li>
<li>泛web容器时代(reactNative,weex,快应用都把渲染交给原生)</li>
<li>自绘引擎时代(flutter,客户端只提供一块画布即可)<img src="/2019/10/01/flutter/hybrid.png" title="技术选型对比">
</li>
</ul>
</li>
<li><p>图像显示基本原理</p>
<ul>
<li>CPU负责图像数据的计算</li>
<li>GPU负责图像数据的渲染，渲染后放入帧缓冲区，视频控制器根据垂直同步信号VSync以60t/s刷新给显示器</li>
<li>显示器负责图像显示</li>
</ul>
</li>
<li><p>skia</p>
<ul>
<li>c++开发的高性能2D图像绘制引擎</li>
</ul>
</li>
</ul>
<h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><ul>
<li>android<ul>
<li>AS</li>
<li>AVD(Nexus6P)</li>
</ul>
</li>
<li>ios<ul>
<li>Xcode</li>
<li>open -a Simulator</li>
</ul>
</li>
<li>flutter<ul>
<li>export PUB_HOSTED_URL=<a href="https://pub.flutter-io.cn" target="_blank" rel="noopener">https://pub.flutter-io.cn</a></li>
<li>export FLUTTER_STORAGE_BASE_URL=<a href="https://storage.flutter-io.cn" target="_blank" rel="noopener">https://storage.flutter-io.cn</a></li>
<li>export FLUTTER_HOME=/Users/dh/dev/flutter</li>
<li>export PATH=$PATH:$FLUTTER_HOME/bin</li>
<li>flutter emulators [–launch apple_ios_simulator]</li>
<li>flutter doctor</li>
</ul>
</li>
<li>doctor问题解决方案<ul>
<li>ios<ul>
<li>gem sources –add <a href="https://gems.ruby-china.com/" target="_blank" rel="noopener">https://gems.ruby-china.com/</a> –remove <a href="https://rubygems.org/" target="_blank" rel="noopener">https://rubygems.org/</a></li>
<li>gem sources -l</li>
<li>gem update –system</li>
<li>sudo gem install cocoapods</li>
<li>pod setup</li>
<li>brew update</li>
<li>brew install –HEAD usbmuxd #usb通信抽象为tcp通信，与设备进行多路socket守护进程</li>
<li>brew link usbmuxd</li>
<li>brew install –HEAD libimobiledevice # 与设备进行通信的跨平台协议库</li>
<li>brew install ideviceinstaller # 在ios设备上管理app的工具</li>
<li>signing</li>
</ul>
</li>
<li>android<ul>
<li>flutter doctor –android-licenses</li>
<li>flutter plugin</li>
</ul>
</li>
<li>vscode<ul>
<li>flutter extension</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="工程结构"><a href="#工程结构" class="headerlink" title="工程结构"></a>工程结构</h2><ul>
<li>android 安卓子工程</li>
<li>build 构建产物</li>
<li>ios ios子工程</li>
<li>lib/main.dart flutter工程入口文件</li>
<li>test 测试目录</li>
<li>flutter_app_demo.iml 工程配置文件</li>
<li>pubspec.lock 记录当前项目实际依赖信息的文件</li>
<li>pubspec.yaml 管理第三方库和资源的配置文件</li>
</ul>
<h1 id="Dart基础"><a href="#Dart基础" class="headerlink" title="Dart基础"></a>Dart基础</h1><h2 id="特性-1"><a href="#特性-1" class="headerlink" title="特性"></a>特性</h2><ul>
<li>同时支持JIT/AOT编译模式<ul>
<li>JIT just in time即时编译，适合开发环境</li>
<li>AOT ahead of time运行前编译，适合生产环境</li>
</ul>
</li>
<li>内存分配和垃圾回收机制<ul>
<li>内存线性增长，创建对象时只在堆上移动指针</li>
<li>并发是通过Isolate实现，使dart实现了无锁的内存分配</li>
<li>避免了抢占式调度和共享内存</li>
<li>垃圾回收采用多生代算法，只操作少量的活跃对象，忽略死亡对象</li>
</ul>
</li>
<li>单线程模型<ul>
<li>dart中没有线程，只有Isolate隔离区，isolate不共享内存</li>
<li>通过事件循环在事件队列上传递消息</li>
</ul>
</li>
<li>无需单独的声明式布局语言</li>
</ul>
<h2 id="语言基础"><a href="#语言基础" class="headerlink" title="语言基础"></a>语言基础</h2><ul>
<li>dart概述<ul>
<li>是类型安全的语言，不会隐式转换类型</li>
<li>所有的类型都是对象类型，都继承自顶层的Object</li>
</ul>
</li>
<li>main()作为程序的入口 </li>
<li>变量与类型<ul>
<li>var声明变量表示变量类型自动推断</li>
<li>未初始化的变量的值都是null</li>
</ul>
</li>
<li>基本类型<ul>
<li>String<ul>
<li>UTF-16的字符串组成</li>
<li>支持单引号、双引号</li>
<li>支持${expression}或$var</li>
<li>三个单引号或双引号来表示多行字符串</li>
</ul>
</li>
<li>num<ul>
<li>64位int，代表整数类型</li>
<li>64位double，代表浮点类型</li>
</ul>
</li>
<li>bool<ul>
<li>true</li>
<li>false</li>
</ul>
</li>
<li>List<ul>
<li>类型约束List<int>/ list = <int>[]</int></int></li>
<li>类型判断 list is List<int></int></li>
</ul>
</li>
<li>Map<ul>
<li>类型约束Map&lt;String,String&gt;/ map = &lt;String,String&gt;{}</li>
<li>类型判断 map is Map&lt;String,String&gt;</li>
</ul>
</li>
</ul>
</li>
<li>常量<ul>
<li>const 表示在编译期间即能确定的值</li>
<li>final 表示在运行时确定的值，一旦确定后就不可改变</li>
</ul>
</li>
<li>函数<ul>
<li>类型Function</li>
<li>支持箭头函数</li>
<li>函数的重载即提供同名但参数不同的函数，dart认为会导致混乱所以不支持</li>
<li>但dart支持更高效的可选命名参数{}和可选参数[],也支持参数默认值</li>
</ul>
</li>
<li>类<ul>
<li>实例变量/方法</li>
<li>类变量/方法 static关键字</li>
<li>变量/方法名称前面加上_即可作为private使用，否则就是public，_是库访问级别</li>
<li>构造函数语法糖就是类中调用同类名相同的方法</li>
<li>命名构造函数即类可以有多个构造函数</li>
<li>实例化时可以省略new关键字</li>
<li>dart支持初始化列表，即支持多个构造函数，构造函数可以重定向:到另一个构造函数</li>
</ul>
</li>
<li>复用<ul>
<li>继承父类 extends</li>
<li>接口实现 implements</li>
<li>混入 with 解决dart缺少对多重继承的支持问题还能避免多重继承导致的菱形歧义</li>
</ul>
</li>
<li>运算符(用于简化处理变量实例缺失即null的情况)<ul>
<li>?. p?.printInfo()表示p为null时跳过，不为null时再调用，避免抛错</li>
<li>??= a??=value 如果a为null则赋值value，否则跳过</li>
<li>?? a ?? b 如果a不为null则返回a，否则返回b</li>
<li>dart提供了类似C++的运算符覆写机制，使用户可以自定义运算符，使用operator关键字和运算符一起使用来表示类成员运算符函数</li>
</ul>
</li>
</ul>
<h1 id="flutter基础"><a href="#flutter基础" class="headerlink" title="flutter基础"></a>flutter基础</h1><h2 id="widget"><a href="#widget" class="headerlink" title="widget"></a>widget</h2><ul>
<li>描述<ul>
<li>是flutter功能的抽象描述</li>
<li>是视图的配置信息</li>
<li>是数据的映射</li>
<li>一切皆widget(view/viewController/Activity/Application/Layout等)</li>
<li>由父到子、自顶向下方式构建，父widget控制子widget的样式</li>
<li>widget是不可变的，更新则意味着销毁和重建</li>
</ul>
</li>
<li>分类<ul>
<li>statelessWidget Model在build后不变，父widget通过初始化参数完全控制UI</li>
<li>statefulWidget build后还要关心和响应数据变化来进行重绘，setState就会触发</li>
</ul>
</li>
<li>渲染过程<ul>
<li>widget树 对视图的一种结构化描述数据，widget是不可变的需要很多的重建</li>
<li>element树 是widget的一个实例化对象，element.renderObject承载了视图构建的上下文数据，element是可变的，把真正需要修改的部分同步到renderObject中</li>
<li>renderObject树 主要负责视图渲染的对象<ul>
<li>布局 在renderObject中完成，采用深度优先机制遍历，确定位置和尺寸</li>
<li>绘制 在renderObject中完成，采用深度优先机制遍历，确定图层</li>
<li>合成 交给skia引擎</li>
<li>渲染 交给skia引擎，在VSync信号同步时直接从渲染树合成Bitmap，交给GPU</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><ul>
<li>app的生命周期<ul>
<li>WidgetsBindingObserver类实现钩子，此类中有很多函数</li>
<li>didChangeAppLifecycleState<ul>
<li>resumed 可见的，可以响应用户交互</li>
<li>inactive 非活动状态，不能响应用户交互(上下两个状态切换时的中间状态)</li>
<li>paused 不可见并不能响应用户交互但后台继续活动</li>
</ul>
</li>
<li>addPostFrameCallback<ul>
<li>单次frame绘制回调，只会回调1次</li>
</ul>
</li>
<li>addPersistentFrameCallback<ul>
<li>实时frame绘制回调，每次frame绘制完成后都回调</li>
<li>适合做FPS监测</li>
</ul>
</li>
</ul>
</li>
<li>视图的生命周期，通过state体现<ul>
<li>创建<ul>
<li>构造方法，调用createState创建state，构造方法决定了最初呈现效果在state生命周期只会被调用1次</li>
<li>initState，在state生命周期只会被调用1次</li>
<li>didChangeDependencies</li>
<li>build，构建视图返回一个widget</li>
</ul>
</li>
<li>更新<ul>
<li>setState</li>
<li>didChangeDependencies</li>
<li>didUpdateWidget</li>
</ul>
</li>
<li>销毁<ul>
<li>deactivate</li>
<li>dispose<img src="/2019/10/01/flutter/lifecycle1.png" title="生命周期1">
<img src="/2019/10/01/flutter/lifecycle2.png" title="生命周期2">

</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="常用widget"><a href="#常用widget" class="headerlink" title="常用widget"></a>常用widget</h2><ul>
<li>Text<ul>
<li>Text</li>
<li>Text.rich</li>
</ul>
</li>
<li>TextSpan</li>
<li>Image<ul>
<li>Image.asset(“images/logo.png”)加载本地资源图片</li>
<li>Image.file(new File(“/path/to/file”))本地图片</li>
<li>Image.network(“<a href="http://xxx/xx.xx&quot;)加载网络图片" target="_blank" rel="noopener">http://xxx/xx.xx&quot;)加载网络图片</a></li>
</ul>
</li>
<li>FadeInImage 提供了图片占位，加载动画效果</li>
<li>CachedNetworkImage 还可以把图片缓存到fs中，更强大</li>
<li>FloatingActionButton 圆形按钮</li>
<li>FlatButton 扁平化的按钮，默认背景透明，有交互效果</li>
<li>RaisedButton 凸起的按钮，默认带有灰色背景，有交互效果</li>
<li>ListView<ul>
<li>ListView 适用于少量子元素，需要提前创建子widget，性能较差</li>
<li>ListView.builder 适用于子widget比较多的情况懒加载widget</li>
<li>ListView.separated 可设置分割线样式</li>
</ul>
</li>
<li>CustomScrollView<ul>
<li>处理多个需要自定义滚动效果的widget</li>
<li>彼此独立的可滚动的widget统称为sliver</li>
</ul>
</li>
<li>ScrollController 滚动信息的监听</li>
<li>ScrollNotification 获取滚动事件的通知，将ListView纳入子widget</li>
<li>布局类widget<ul>
<li>单子widget<ul>
<li>Container</li>
<li>Padding</li>
<li>Center</li>
</ul>
</li>
<li>多子widget<ul>
<li>Row</li>
<li>Column</li>
<li>Expanded 处理容器的剩余空间</li>
</ul>
</li>
<li>层叠widget<ul>
<li>Stack 提供了层叠布局的容器</li>
<li>Positioned 提供了设置子widget位置的能力</li>
</ul>
</li>
</ul>
</li>
<li>自定义widget<ul>
<li>组合</li>
<li>自绘<ul>
<li>CustomPaint是用以承接自绘控件的容器，并不负责真正的绘制</li>
<li>绘制使用画布Canvas和画笔Paint及绘制逻辑CustomPainter控制</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="主题定制"><a href="#主题定制" class="headerlink" title="主题定制"></a>主题定制</h2><ul>
<li>主题一般包括颜色、图片、字体、字号等资源和配置</li>
<li>实现<ul>
<li>ios中通常将配置信息预写到plist中通过单例来控制</li>
<li>android中通常将配置信息写到style属性值的xml中，通过activity的setTheme切换</li>
<li>前端通过切换css即可实现</li>
</ul>
</li>
<li>Theme(data:ThemeData(),child:MyWidget())</li>
<li>Theme(data:Theme.of(context).copyWith(),child:MyWidget())</li>
<li>flutter使用ThemeData统一管理<ul>
<li>app全局范围 MaterialApp.theme</li>
<li>widget局部范围 Theme.data<ul>
<li>不想继承任何全局配置可直接新建一个ThemeData实例</li>
<li>想继承可使用Theme.of(context).copyWith()</li>
</ul>
</li>
<li>Theme.of(context)向上查找widget树，返回最近的Theme</li>
<li>defaultTargetPlatform 可判断当前运行的平台</li>
</ul>
</li>
</ul>
<h2 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h2><ul>
<li>原生<ul>
<li>ios使用Images.xcassets管理图片，其他资源直接拖进项目即可</li>
<li>android使用drawable+分辨率命名的文件夹管理图片，res/layout放布局，res/values放资源描述文件，assets放原始文件</li>
</ul>
</li>
<li>flutter<ul>
<li>assets可管理任意类型的资源</li>
<li>pubspec.yaml中配置指向对应目录即可<ul>
<li>可以单独指向某个文件</li>
<li>也可以指向一个目录，目录制定并不会递归，所以需显示递归指定子目录</li>
</ul>
</li>
<li>资源引用<ul>
<li>Image.asset()引用图片<ul>
<li>遵循基于像素密度的管理方式1.0x、2.0x、3.0x</li>
<li>flutter根据设备分辨率加载比例最接近的图片资源实现自动降级</li>
<li>资源目录应该将1.0x、2.0x、3.0x图片资源分开管理</li>
<li>assets/bg.jpg</li>
<li>assets/2.0x/bg.jpg</li>
<li>assets/3.0x/bg.jpg</li>
<li>pubspec.yaml中仅声明1.0x资源即可 flutter.assets: assets/bg.jpg</li>
</ul>
</li>
<li>rootBundle.loadString()加载字符串文件资源</li>
<li>rootBundle.load()加载二进制文件资源</li>
<li>fonts:[{family: name,fonts:[{asset:assets/fonts/name.ttf},{asset:assets/fonts/name-Italic.ttf,style:italic},{asset:assets/fonts/name-Bold.ttf,weight:700}]}]</li>
</ul>
</li>
</ul>
</li>
<li>flutter框架前的原生配置<ul>
<li>更换app图标<ul>
<li>ios ios/Runner/Assets.xcassets/AppIcon.appiconset</li>
<li>android android/app/src/main/res/mipmap</li>
</ul>
</li>
<li>更换app启动图<ul>
<li>ios ios/Runner/Assets.xcassets/LaunchImage.imageset</li>
<li>android android/app/src/main/res/drawable/launch_background.xml</li>
</ul>
</li>
</ul>
</li>
<li>第三方组件库<ul>
<li>pubspec.yaml<ul>
<li>类似于ios中的Podfile/android中的build.gradle/前端的package.json</li>
<li>pub<ul>
<li>dart的包管理工具，类似于ios中的cocoaPods/android中的maven/前端npm</li>
<li>dart的包实际上就是一个包含了pubspec.yaml的目录</li>
</ul>
</li>
</ul>
</li>
<li>推荐包使用区间进行版本的管理，dart/flutter的sdk运行环境使用固定版本号</li>
<li>包依赖可以直接获取pub资源，也可以使用本地路径或git地址</li>
<li>所有依赖确定并下载完毕后会生成.packages文件记录包映射信息，此文件需要忽略</li>
<li>最后pub会生成pubspec.lock文件记录包的来源和版本号，此文件需要git</li>
</ul>
</li>
</ul>
<h2 id="用户交互事件"><a href="#用户交互事件" class="headerlink" title="用户交互事件"></a>用户交互事件</h2><ul>
<li>原始的指针事件(PointerEvent)<ul>
<li>原生常见的触摸事件</li>
<li>事件会从最内层冒泡到根节点，无法取消冒泡或停止分发，只能hitTestBehavior</li>
<li>ListenerWidget可以监听子widget的原始指针事件</li>
</ul>
</li>
<li>手势识别(GestureDetector)<ul>
<li>多个原始指针事件的组合操作，是指针事件的语义化封装</li>
<li>GestureDetector可以处理各种高级触摸行为，可监听多个手势但最终只有一个生效</li>
<li>不同手势通过flutter内部的arena进行PK，最终决定是什么手势</li>
<li>父组件也需要处理子组件手势时需要RawGestureDetector和GestureFactory自定义</li>
</ul>
</li>
</ul>
<h2 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h2><ul>
<li>组件通信标准方式是通过属性传值</li>
<li>跨组件通信三种方案<ul>
<li>InheritedWidget</li>
<li>Notification</li>
<li>EventBus</li>
</ul>
</li>
<li>InheritedWidget<ul>
<li>从上到下传递</li>
<li>Theme是典型案例，父子建立观察者关系，上层属性修改后，子也会更新，默认只读</li>
</ul>
</li>
<li>Notification<ul>
<li>从下到上传递</li>
<li>NotificationListener进行监听</li>
</ul>
</li>
<li>EventBus<ul>
<li>上面两种依赖父子widget关系树</li>
<li>eventBus遵循了发布/订阅模式</li>
<li>全局作用，但容易引起冲突，组件移除要清理事件</li>
</ul>
</li>
</ul>
<h2 id="路由与导航"><a href="#路由与导航" class="headerlink" title="路由与导航"></a>路由与导航</h2><ul>
<li>Route <ul>
<li>是页面的抽象，主要负责接收参数，创建页面，响应navigator的打开和关闭</li>
</ul>
</li>
<li>Navigator<ul>
<li>维护一个路由栈管理Route，可打开/关闭/替换</li>
</ul>
</li>
<li>路由管理<ul>
<li>基本路由<ul>
<li>无需提前注册，页面切换时需要自己构造页面实例</li>
<li>Navigator.push(context,MaterialPageRouter(builder:()=&gt;{}))</li>
</ul>
</li>
<li>命名路由<ul>
<li>需要提前注册，页面切换时根据注册的标示符打开</li>
<li>Navigator.pushNamed(context,”name”)</li>
<li>Navigator.of(context).pushNamed(“name”,arguments:”args”);</li>
</ul>
</li>
</ul>
</li>
<li>其他<ul>
<li>默认路由 UnknownRoute</li>
<li>路由页面打开参数<ul>
<li>RouteSettings </li>
<li>args = ModalRoute.of(context).settings.arguments as String;</li>
</ul>
</li>
<li>路由页面返回参数<ul>
<li>push页面时要设置目标页面关闭时的监听函数以获取返回参数Navigator.pushNamed(context,”name”).then(args =&gt; print args);</li>
<li>目标页面关闭路由时要传递相关返回参数 Navigator.pop(context,”args”);</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="flutter进阶"><a href="#flutter进阶" class="headerlink" title="flutter进阶"></a>flutter进阶</h1><h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><ul>
<li>Animation<ul>
<li>flutter动画库的核心类</li>
<li>flutter的动画状态和渲染是分离的</li>
<li>fultter动画的生成器</li>
</ul>
</li>
<li>AnimationController<ul>
<li>flutter动画的控制器</li>
<li>管理Animation，可设置动画的时长、启动动画、暂停、反转等</li>
<li>controller.forward()启动动画</li>
<li>controller.repeat()重复动画</li>
<li>controller.dispose()释放资源</li>
</ul>
</li>
<li>Listener<ul>
<li>flutter动画的监听器</li>
<li>是Animation的回调函数，可监听动画的进度变化</li>
<li>监听变化后重新触发刷新实现动画</li>
<li>实践中尽量避免直接使用提高性能</li>
</ul>
</li>
<li>AnimatedWidget<ul>
<li>将Animation状态与其子widget视觉样式绑定，省去了状态监听和刷新UI</li>
<li>使用时要继承此widget并接收Animation对象作为初始化参数,build方法中读值初始化</li>
</ul>
</li>
<li>AnimatedBuilder<ul>
<li>自动监听Animation对象变化根据需要刷新UI</li>
<li>尺寸变化由builder(context,child)函数管理</li>
<li>此类实现了动画与渲染的职责分离</li>
</ul>
</li>
<li>跨页面共享的动画<ul>
<li>共享元素变换 SharedElementTransition</li>
<li>Hero(tag:”name”,child:Widget)</li>
</ul>
</li>
</ul>
<h2 id="单线程模型"><a href="#单线程模型" class="headerlink" title="单线程模型"></a>单线程模型</h2><ul>
<li>EventLoop机制<ul>
<li>MicrotaskQueue微任务队列<ul>
<li>表示短时间就会完成的异步任务</li>
<li>微任务在事件循环中的优先级最高，只要有任务就一直霸占着事件循环</li>
<li>scheduleMicroTask()</li>
<li>一般不需要此队列</li>
</ul>
</li>
<li>EventQueue事件队列<ul>
<li>优先级比较低，比较常用</li>
<li>dart为EventQueue任务提供了Future封装</li>
<li>Future提供了链式调用能力，可在异步完成后依次执行</li>
<li>then与Future函数体共用一个事件循环</li>
<li>Future执行完毕了又给引用添加了一个then方法或Future函数体为null时会把then方法体放入微任务队列，尽快执行<img src="/2019/10/01/flutter/eventLoop.png" title="事件循环">
<img src="/2019/10/01/flutter/eventLoop.gif" title="事件循环"></li>
</ul>
</li>
</ul>
</li>
<li>异步处理<ul>
<li>async/await</li>
</ul>
</li>
<li>并发编程<ul>
<li>dart是基于单线程模型，但也提供了基于Isolate的多线程机制提高多核cpu利用率</li>
<li>Isolate都有自己的EventLoop和Queue，资源隔离做的很好</li>
<li>Isolate之间不共享任何资源，只能依靠消息机制SendPort通信，避免了资源抢占需要加锁的问题</li>
<li>Isolate.spawn(fnName,args)</li>
<li>主/并发Isolate之间通信靠ReceivePort.listen()和sendPort.send()</li>
<li>为了方便使用抽象了支持并发计算的compute函数</li>
</ul>
</li>
</ul>
<h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><ul>
<li>网络请求流程<ul>
<li>构造client，设置通用请求行为（超时）</li>
<li>构造URI，设置请求header/body</li>
<li>发起请求，等待响应</li>
<li>解析响应的内容</li>
</ul>
</li>
<li>flutter实现方式<ul>
<li>dart:io里的HttpClient</li>
<li>dart原生的http请求库</li>
<li>第三方库dio(支持拦截器/请求合并等高级能力)</li>
</ul>
</li>
<li>JSON解析<ul>
<li>flutter不支持运行时反射，所以不能自动解析JSON只能手动解析</li>
<li>dart:convert库中内置的JSON解码器把JSON字符串解析成对象</li>
<li>字符串传给JSON.decode()返回一个Map再传给自定义解析类</li>
<li>如果JSON数据格式比较复杂或量比较大推荐使用compute函数将解析放到新Isolate完成</li>
</ul>
</li>
</ul>
<h2 id="持久化存储"><a href="#持久化存储" class="headerlink" title="持久化存储"></a>持久化存储</h2><ul>
<li>文件<ul>
<li>目录<ul>
<li>临时目录Temporary(ios的NSTemporaryDirectory和andriod的getCacheDir)</li>
<li>文档目录Documents(ios的NSDocumentDirectory和andriod的AppData目录)</li>
</ul>
</li>
<li>编码<ul>
<li>非常耗时需要在异步环境中编码</li>
<li>防止异常需要try/catch</li>
</ul>
</li>
</ul>
</li>
<li>SharedPreferences<ul>
<li>以原生方式为简单的键值对数据提供存储（string/int/double/bool）</li>
<li>ios中使用NSUserDefaults</li>
<li>android中使用SharedPreferences</li>
</ul>
</li>
<li>数据库sqlite<ul>
<li>设定数据库存储地址时使用join方法自动处理路径分隔符</li>
<li>创建数据库时传入的version与onCreate方法的回调中的version一致</li>
<li>在app版本升级过程中需要对数据库存储字段改动需要onUpgrade方法处理</li>
<li>数据库只会创建1次即onCreate在app卸载前只会执行1次</li>
</ul>
</li>
</ul>
<h2 id="dart层兼容原生"><a href="#dart层兼容原生" class="headerlink" title="dart层兼容原生"></a>dart层兼容原生</h2><ul>
<li>方法通道MethodChannel 解决原生能力复用问题<ul>
<li>基于方法通道(MethodChannel)机制可以把原生代码接口形式暴露给Dart</li>
<li>构造方法通道时需要指定一个唯一的字符串标识符，然后在这个通道上发起方法调用</li>
<li>const mc = MethodChannel(‘com.ceair/utils’);</li>
<li>try { await mc.invokeMethod(‘methodName’) } catch(e){}</li>
<li>方法通道调用过程中涉及的跨平台数据格式flutter会使用StandardMessageCodec进行序列化</li>
<li>方法通道是非线程安全的，所以原生和flutter都需要在主线程操作否则可能会有奇怪的bug</li>
</ul>
</li>
<li>平台视图PlatformView 解决原生视图复用问题<ul>
<li>允许flutter里嵌入原生的视图并加入flutter渲染树中实现混合视图</li>
<li>flutter通过原生视图的封装类(UIKitView和AndroidView)传入视图标识符发起请求</li>
<li>原生代码交给PlatformViewFactory实现</li>
<li>原生代码把视图标识符和工厂进行关联注册让flutter可直接找到工厂</li>
</ul>
</li>
</ul>
<h2 id="原生工程混编flutter"><a href="#原生工程混编flutter" class="headerlink" title="原生工程混编flutter"></a>原生工程混编flutter</h2><ul>
<li>混编原理 <ul>
<li>android原生提供一个FLutterView</li>
<li>ios原生提供一个FlutterViewController</li>
</ul>
</li>
<li>混编方式<ul>
<li>原生工程作为flutter工程的子工程，flutter统一管理（开发效率低）</li>
<li>flutter工程作为原生工程共用的子模块，原生工程不变的三端分离模式（推荐使用）<ul>
<li>抽离flutter工程，将不同平台的构建产物依照标准组件化形式管理</li>
<li>android项目把flutter模块打包成aar，通过build.gradle进行依赖管理</li>
<li>ios项目把flutter模块打包成pod，通过Podfle进行依赖管理</li>
</ul>
</li>
</ul>
</li>
<li>flutter模块<ul>
<li>flutter create -t module flutter_library</li>
</ul>
</li>
<li>android模块集成<ul>
<li>依赖1 flutter库和引擎 Flutter.jar</li>
<li>依赖2 flutter工程产物 isolate_snapshot_instr/vm_snapshot_data/FLutter_assets…</li>
<li>集成1 flutter build apk –[debug|release]</li>
<li>集成2 把上一步的产物flutter-debug.aar放到安卓工程app/libs目录下</li>
<li>集成3 build.gradle中添加对aar的依赖后sync一下</li>
<li>集成4 MainActivity.java中进行调用</li>
</ul>
</li>
<li>ios模块集成<ul>
<li>依赖1 flutter库和引擎 Flutter.framework</li>
<li>依赖2 flutter工程产物 App.framework</li>
<li>集成1 flutter build ios –[debug|release]</li>
<li>集成2 把上一步的产物拷贝到原生项目根目录下的FlutterEngine目录并创建FlutterEngine.podspec</li>
<li>集成3 pod lib lint</li>
<li>集成4 Podfile中集成后需要pod install</li>
<li>集成5 AppDelegate.m中进行调用</li>
</ul>
</li>
</ul>
<h2 id="混合导航栈"><a href="#混合导航栈" class="headerlink" title="混合导航栈"></a>混合导航栈</h2><ul>
<li>原生采用单容器单页面机制(一个ViewController/Activity对应一个页面)</li>
<li>Flutter采用单容器多页面机制(一个ViewController/Activity对应多个flutter页面)</li>
<li>原生跳转到flutter<ul>
<li>ios初始化flutter容器(FlutterViewController)并设置初始路由页面即可</li>
<li>android需要把View包装到Activity的contentView中并设置初始化路由</li>
</ul>
</li>
<li>flutter跳转到原生<ul>
<li>flutter打开新的原生页面(通过方法通道进行实现)</li>
<li>flutter回退到旧的原生页面(需要关闭flutter容器也是通过方法通道进行实现)</li>
</ul>
</li>
<li>性能问题<ul>
<li>由于flutter容器初始化成本比较高，每启动一个实例都要创建一个新的engine和Isolate</li>
<li>尽量避免flutter跳到原生后又跳到flutter，尽量在flutter完成业务的闭环</li>
<li>业界解决方案<ul>
<li>今日头条修改flutterEngine源码，使多engine在底层共享Isolate</li>
<li>闲鱼的共享FlutterView，通过hack方法由原生层驱动flutter层渲染内容</li>
<li>上面2种解决方案都有自己的不足，所以尽量减少此应用场景<img src="/2019/10/01/flutter/hybridNav.png" title="混合导航栈">

</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="状态管理"><a href="#状态管理" class="headerlink" title="状态管理"></a>状态管理</h2><ul>
<li>Provider<ul>
<li>官方推荐框架，是InheritWidget的语法糖</li>
<li>提供了依赖注入的功能，允许widget树灵活处理数据</li>
<li>可读写的ChangeNotifierProvider/MultiProvider和只读的Provider</li>
<li>Provider.of()可获取资源，但页面其他Widget也会刷新</li>
<li>ConsumerN可通过Builder(context,model,child)只更新依赖的widget提高性能</li>
</ul>
</li>
<li>使用<ul>
<li>pubspec.yaml中添加Provider依赖</li>
<li>封装: 定义需要共享的数据模型，通过混入ChangeNotifier管理听众，模型中调用notifyListeners()通知听众刷新</li>
<li>注入: 把模型放到widget的父级或更高ChangeNotifierProvider.value(value:SharedModel(),child:Widget())</li>
<li>读写: Provider.of()/ConsumerN()</li>
</ul>
</li>
</ul>
<h2 id="原生推送"><a href="#原生推送" class="headerlink" title="原生推送"></a>原生推送</h2><ul>
<li>ios<ul>
<li>使用APNS苹果推送通知服务</li>
<li>为了保证api统一，ios上也使用封装了APNs的第三方服务</li>
</ul>
</li>
<li>android<ul>
<li>类似Firebase云消息传递机制FCM(FirebaseCloudMessage)实现推送托管</li>
<li>大陆通常使用三方推送(极光/友盟)适配</li>
<li>第三方服务不能享受系统底层的优化，使用自建的长链接通道</li>
<li>但也是共享所有接入第三方推送的app的推送通道，只要有一个存活就可推送</li>
</ul>
</li>
<li>推送流程<ul>
<li>业务服务器调用APNS/FCM</li>
<li>消息到达用户终端设备</li>
<li>设备解析后把消息转给所属应用</li>
</ul>
</li>
<li>极光接入流程<ul>
<li>初始化SDK setup(调用原生接口)</li>
<li>获取地址id registrationID(调用原生接口)</li>
<li>注册消息通知 setOpenNotificationHandler(原生回调dart)</li>
<li>单例模式实现整个应用共享</li>
<li>android<ul>
<li>JCommonService是一个后台Service，极光共享长链接通道核心</li>
<li>JPushMessageReceiver是一个BroadcastReceiver可获取推送消息</li>
<li>AndroidManifest.xml中声明上面2个的注册</li>
<li>收到消息回调后首先启动MainActivity，等待Flutter初始化完成后再回调flutter推送消息</li>
</ul>
</li>
<li>ios<ul>
<li>podspec文件引入极光SDKjpush</li>
<li>用户点击了推送消息，防止是从后台唤醒，要确保flutter初始化好后再回调flutter推送消息</li>
</ul>
</li>
<li>提供应用推送证书，关联极光应用配置<ul>
<li>android注册appkey后根据包名进行注册并在build.gradle中绑定manifestPlaceholders</li>
<li>ios首先要申请推送证书(.p12证书或APNsAuthKey)并在平台配置绑定后工程开启push</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="国际化"><a href="#国际化" class="headerlink" title="国际化"></a>国际化</h2><ul>
<li>本质是语言和地区的差异性配置</li>
<li>资源<ul>
<li>字符串文本</li>
<li>货币单位</li>
<li>时间格式</li>
<li>背景图资源</li>
</ul>
</li>
<li>步骤<ul>
<li>实现LocalizationsDelegate，将所有需要转换的资源声明为其属性</li>
<li>手动翻译适配</li>
<li>app初始化时，将代理类设置为应用程序的翻译回调</li>
<li>官方的方案可以先放弃，借鉴Flutter i18n插件</li>
</ul>
</li>
<li>Flutteri18n<ul>
<li>as中安装此插件</li>
<li>pubspec.yaml中声明flutter_localizations sdk: flutter依赖</li>
<li>res/values/strings_en.arb文件是JSON格式的配置，存放标识符和翻译的键值对</li>
<li>修改上面的arb文件会自动生成lib/generated/i18n.dart(支持静态映射和动态传参)</li>
<li>初始化时2个重要参数localizationsDelegates翻译回调和supportedLocales所支持的语言配置</li>
<li>配置翻译回调时需要GlobalMaterialLocalizations.delegate与GlobalWidgetsLocalizations.delegate是官方widgets本身的翻译回调</li>
<li>S.of(context)直接获取arb文件中翻译的文案</li>
<li>翻译的代码只能在获取到context的前提下才能生效即MaterialApp的子widget，通过MaterialApp的onGenerateTitle回调设置title的国际化</li>
<li>ios程序有一套自建的语言环境管理机制，默认是英文，为了支持国际化需要额外配置Localization</li>
<li>原生工程配置<ul>
<li>在flutter框架启动前的配置需要在原生中配置</li>
<li>android中应用名称在AndroidManifest.xml中application的android:label属性</li>
<li>并且要在android/app/src/main/res中为要支持的语言创建values目录和strings.xml</li>
<li>ios工程中的应用名称是在Info.plist文件中，需要一个字符串资源引用的文件InfoPlist.strings并在Localizations中添加多语言</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="适配屏幕分辨率"><a href="#适配屏幕分辨率" class="headerlink" title="适配屏幕分辨率"></a>适配屏幕分辨率</h2><ul>
<li>适配屏幕旋转<ul>
<li>竖屏模式/横屏模式2套布局方案</li>
<li>OrientationBuilder的builder函数可以回调屏幕状态orientation</li>
<li>MediaQuery.of(context).orientation可以在OrientationBuilder外获取状态</li>
<li>SystemChrome.setPreferredOrientations([DeviceOrientation.portraitUp]);关闭横屏</li>
</ul>
</li>
<li>适配分辨率<ul>
<li>将屏幕空间划分为多个窗格即用原生类似的Fragment/ChildViewController概念抽象独立区块视觉功能</li>
<li>多窗格布局可以在平板电脑和横屏模式上，实现更好的视觉平衡效果</li>
<li>页面的实现和区块的实现是相互独立的，所以可以实现区块的复用</li>
<li>MediaQuery.of(context).size.width可获取屏幕宽度</li>
</ul>
</li>
</ul>
<h2 id="编译模式"><a href="#编译模式" class="headerlink" title="编译模式"></a>编译模式</h2><ul>
<li>运行模式<ul>
<li>Debug JIT</li>
<li>Release AOT</li>
<li>Profile Release+Profile(Observatory) flutter run –profile</li>
</ul>
</li>
<li>编译模式<ul>
<li>JIT <ul>
<li>JustInTime运行时编译</li>
<li>动态编译/将dart代码编译成中间代码scriptSnapshot最终生成DartKernel(可动态更新)需要在设备上用DartVM解释执行实现widget重建</li>
<li>可以模拟器和真机运行</li>
<li>打开assert断言/debug调试/observatory调试/hotReload热重载</li>
<li>没有优化应用启动速度/代码执行速度/二进制包大小/部署</li>
<li>flutter run –debug</li>
</ul>
</li>
<li>AOT<ul>
<li>AheadOfTime运行前编译</li>
<li>静态编译/生成设备可执行的二进制码</li>
<li>只能真机运行</li>
<li>关闭assert断言/debug调试/observatory调试/hotReload热重载</li>
<li>优化应用启动速度/代码执行速度/二进制包大小/部署</li>
<li>flutter run –release</li>
</ul>
</li>
</ul>
</li>
<li>运行时识别编译模式<ul>
<li>区别<ul>
<li>debug模式下打印详细日志，调用开发接口</li>
<li>release模式下记录精简日志，调用生产接口</li>
</ul>
</li>
<li>识别<ul>
<li>通过断言识别 assert((){ // DoSth4Debug; return true;}()) release下此代码被删除</li>
<li>通过DartVM提供的编译常数识别 if(kReleaseMode){}else{/ DoSth4Debug;} 代码总会被打包</li>
</ul>
</li>
</ul>
</li>
<li>分离配置环境<ul>
<li>抽象配置并用InheritedWidget封装</li>
<li>配置多入口(main_dev.dart/main.dart)</li>
<li>读取配置(运行时通过InheritedWidget将配置部分应用到子widget)</li>
<li>编译打包(通过不同选项构建不同的安装包flutter run -t|–target main[_dev].dart)</li>
</ul>
</li>
<li>原生配置差异<ul>
<li>android: build flavor</li>
<li>ios: 多个build target</li>
</ul>
</li>
</ul>
<h2 id="hotReload"><a href="#hotReload" class="headerlink" title="hotReload"></a>hotReload</h2><img src="/2019/10/01/flutter/hotReload.png" title="热重载流程">
<ul>
<li>热重载流程<ul>
<li>扫描工程改动</li>
<li>增量编译</li>
<li>推送更新</li>
<li>代码合并</li>
<li>Widget重建</li>
</ul>
</li>
<li>不支持热重载场景(此场景可以用hotRestart)<ul>
<li>代码编译错误</li>
<li>widget状态无法兼容</li>
<li>全局变量和静态属性的更改</li>
<li>main()里的更改</li>
<li>initState()里的更改</li>
<li>枚举和泛类型的更改</li>
</ul>
</li>
</ul>
<h2 id="工具链优化"><a href="#工具链优化" class="headerlink" title="工具链优化"></a>工具链优化</h2><ul>
<li>输出日志<ul>
<li>print() 涉及IO操作，耗费系统资源</li>
<li>debugPrint() 可以定制打印能力如debugPrint = (String msg,{int wrapWidth}{})</li>
</ul>
</li>
<li>断点调试<ul>
<li>标记断点</li>
<li>调试应用</li>
<li>查看信息</li>
</ul>
</li>
<li>布局调试<ul>
<li>DebugPainting<ul>
<li>布局边界展示辅助线</li>
<li>debugPaintSizeEnabled=true</li>
</ul>
</li>
<li>FlutterInspector 查看具体信息</li>
</ul>
</li>
</ul>
<h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><ul>
<li>性能问题<ul>
<li>GPU线程问题<ul>
<li>涉及widget裁剪/蒙层等多视图叠加渲染可main中使用checkerboardOffscreenLayers=true检查</li>
<li>缺少缓存导致静态图像反复绘制可main中使用checkerboardRasterCacheImages=true检查，有问题可使用RepaintBoundary缓存</li>
</ul>
</li>
<li>UI线程问题(cpu)<ul>
<li>OpenDevTools</li>
<li>Performance性能工具<ul>
<li>可记录cpu帧图(火焰图)展示cpu调用栈表示cpu繁忙程度</li>
<li>y轴表示调用栈，每一层都是一个函数，调用栈越深火焰越高，底部就是正在执行的函数，上方是父函数</li>
<li>x轴表示单位时间，在x轴越长表示执行时间越长，平顶表示函数可能存在性能问题</li>
</ul>
</li>
<li>有问题可以使用Isolate或compute()将耗时的操作移到主Isolate外完成</li>
</ul>
</li>
</ul>
</li>
<li>性能图层<ul>
<li>PerformanceOverlay</li>
<li>为采集真实的环境需要使用Profile分析模式</li>
<li>模拟器使用x86指令集/真机使用ARM指令集</li>
<li>flutter run –profile</li>
<li>性能图层展示了最近300帧的表现</li>
<li>为了保证60Hz的刷新频率，每一帧都要小于16ms(1/60)</li>
</ul>
</li>
<li>经验<ul>
<li>控制build方法耗时，将widget拆小越小越可复用</li>
<li>不要使用widget半透明效果，而使用图片代替</li>
<li>列表采用懒加载</li>
</ul>
</li>
</ul>
<h2 id="自动化测试"><a href="#自动化测试" class="headerlink" title="自动化测试"></a>自动化测试</h2><ul>
<li>单元测试<ul>
<li>对软件中最小可测试单元(语句/函数/方法/类)进行验证</li>
<li>pubspec.yaml中需要依赖test包 dev_dependencies: test:</li>
<li>测试用例<ul>
<li>定义 test()/group()测试用例封装类</li>
<li>执行</li>
<li>验证 expect()将执行结果与预期进行比较</li>
</ul>
</li>
<li>模拟mock<ul>
<li>pubspec.yaml中依赖mockito</li>
<li>Mock类可模拟任何外部依赖</li>
<li>when().thenAnswer()当符合条件时进行注入</li>
</ul>
</li>
</ul>
</li>
<li>UI测试<ul>
<li>pubspec.yaml中使用flutter_test包提供核心框架</li>
<li>testWidgets(‘name’,(tester) async{})测试用例封装类</li>
<li>await tester.pumpWidget(MyApp())触发MyApp渲染</li>
<li>find.text(str)查找字符串文本为str的widget</li>
<li>find.byIcon(Icons.add)查找到按钮控件</li>
<li>await tester.tap()点击</li>
<li>await tester.pump()强制渲染刷新</li>
</ul>
</li>
</ul>
<h1 id="综合应用"><a href="#综合应用" class="headerlink" title="综合应用"></a>综合应用</h1><h2 id="生产异常捕获和信息采集"><a href="#生产异常捕获和信息采集" class="headerlink" title="生产异常捕获和信息采集"></a>生产异常捕获和信息采集</h2><ul>
<li><p>flutter异常</p>
<ul>
<li>try/catch捕获异常</li>
<li>dart程序不强制要求必须处理异常(dart用事件循环机制来运行任务，各任务状态独立)</li>
</ul>
</li>
<li><p>dart异常</p>
<ul>
<li><p>App异常</p>
<ul>
<li>同步异常 通过try/catch捕获</li>
<li>异步异常 通过Future的catchError语句捕获</li>
<li>集中管理 通过Zone.runZoned Zone表示代码执行的范围相当于沙盒,onError回调捕获错误，统一处理异常可以把main()的runApp()放到Zone中<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">runZoned&lt;Future&lt;Null&gt;&gt;(() async &#123;</span><br><span class="line">  runApp(MyApp());</span><br><span class="line">&#125;, onError: (error, stackTrace) async &#123;</span><br><span class="line"> //Do sth for error</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>Framework异常</p>
<ul>
<li>触发了底层的try/catch，有异常就会渲染ErrorWidget</li>
<li>为了提高用户体验需要重写ErrorWidget.builder()自定义错误页面<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ErrorWidget.builder = (FlutterErrorDetails flutterErrorDetails)&#123;</span><br><span class="line">  return Scaffold(</span><br><span class="line">    body: Center(</span><br><span class="line">      child: Text(&quot;Custom Error Widget&quot;),</span><br><span class="line">    )</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>FlutterError</p>
<ul>
<li>为了集中处理框架异常</li>
<li>FlutterError.onError在接收到框架异常时执行相应的回调</li>
<li>可以把flutter框架的异常统一转发到当前Zone里统一处理，这样就可以捕获应用所有异常<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">FlutterError.onError = (FlutterErrorDetails details) async &#123;</span><br><span class="line">  //转发至Zone中</span><br><span class="line">  Zone.current.handleUncaughtError(details.exception, details.stack);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">runZoned&lt;Future&lt;Null&gt;&gt;(() async &#123;</span><br><span class="line">  runApp(MyApp());</span><br><span class="line">&#125;, onError: (error, stackTrace) async &#123;</span><br><span class="line"> //Do sth for error</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>异常上报</p>
<ul>
<li>三方服务厂商<ul>
<li>友盟</li>
<li>bugly(社区比较活跃)</li>
<li>sentry(开源)</li>
</ul>
</li>
<li>bugly接入<ul>
<li>dart接口封装(实现单例的FlutterCrashPlugin的setup/postException的方法通道)</li>
<li>ios<ul>
<li>flutter_crash_plugin.podspec引入BuglySDK</li>
<li>实现原生接口FlutterCrashPlugin</li>
</ul>
</li>
<li>android<ul>
<li>build.gradle引入BuglySDK(crashreport和nativecrashreport)</li>
<li>实现原生接口FlutterCrashPlugin</li>
<li>AndroidManifest.xml中配置网络/日志读取等的权限注册</li>
</ul>
</li>
<li>关联应用配置<ul>
<li>ios只需要调用dart的setup就可以</li>
<li>android需要build.gradle中增加NDK架构支持和AndroidP的network_security_config.xml允许http传输数据并在AndroidManifest.xml中新增同名的网络安全配置</li>
</ul>
</li>
<li>接入插件<ul>
<li>pubspec.yaml中添加dependencies</li>
<li>main()里拦截到应用所有的错误后调用上报接口</li>
</ul>
</li>
</ul>
</li>
<li>底层异常<ul>
<li>flutter只能拦截dart层的异常</li>
<li>engine层大部分代码都是C++写的，一旦有异常需要借助原生系统的Crash监听机制</li>
<li>bugly也可以自动收集原生代码的crash，开发者可以把flutterEngine层的符号表下载下来，使用安卓的ndk-stack或ios的symbolicatecrash或atos命令对对crash堆栈进行解析得出引擎层崩溃的代码</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="线上质量"><a href="#线上质量" class="headerlink" title="线上质量"></a>线上质量</h2><ul>
<li><p>页面异常率</p>
<ul>
<li>异常发生次数/页面pv数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 异常发生次数</span><br><span class="line">int exceptionCount = 0; </span><br><span class="line">Future&lt;Null&gt; _reportError(dynamic error, dynamic stackTrace) async &#123;</span><br><span class="line">  exceptionCount++; //累加异常次数</span><br><span class="line">  FlutterCrashPlugin.postException(error, stackTrace);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Future&lt;Null&gt; main() async &#123;</span><br><span class="line">  FlutterError.onError = (FlutterErrorDetails details) async &#123;</span><br><span class="line">    //将异常转发至Zone</span><br><span class="line">    Zone.current.handleUncaughtError(details.exception, details.stack);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  runZoned&lt;Future&lt;Null&gt;&gt;(() async &#123;</span><br><span class="line">    runApp(MyApp());</span><br><span class="line">  &#125;, onError: (error, stackTrace) async &#123;</span><br><span class="line">    //拦截异常</span><br><span class="line">    await _reportError(error, stackTrace);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 页面打开次数</span><br><span class="line">int totalPV = 0;</span><br><span class="line">//导航监听器</span><br><span class="line">class MyObserver extends NavigatorObserver&#123;</span><br><span class="line">  @override</span><br><span class="line">  void didPush(Route route, Route previousRoute) &#123;</span><br><span class="line">    super.didPush(route, previousRoute);</span><br><span class="line">    totalPV++;//累加PV</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyApp extends StatelessWidget &#123;</span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return  MaterialApp(</span><br><span class="line">    //设置路由监听</span><br><span class="line">       navigatorObservers: [</span><br><span class="line">         MyObserver(),</span><br><span class="line">       ],</span><br><span class="line">       home: HomePage(),</span><br><span class="line">    ); </span><br><span class="line">  &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 页面异常率计算</span><br><span class="line"></span><br><span class="line">double pageException() &#123;</span><br><span class="line">  if(totalPV == 0) return 0;</span><br><span class="line">  return exceptionCount/totalPV;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>页面帧率</p>
<ul>
<li>FPS(60Hz，因为VSync信号周期就是每秒60次)</li>
<li>window.onReportTimings()回调最近绘制帧所耗费的时间</li>
<li>FPS = 60 * 实际渲染的帧数 / 本来应该渲染的帧数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import &apos;dart:ui&apos;;</span><br><span class="line"></span><br><span class="line">var orginalCallback;</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line">  runApp(MyApp());</span><br><span class="line">  //设置帧回调函数并保存原始帧回调函数</span><br><span class="line">  orginalCallback = window.onReportTimings;</span><br><span class="line">  window.onReportTimings = onReportTimings;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//仅缓存最近25帧绘制耗时</span><br><span class="line">const maxframes = 25;</span><br><span class="line">final lastFrames = List&lt;FrameTiming&gt;();</span><br><span class="line">//基准VSync信号周期</span><br><span class="line">const frameInterval = const Duration(microseconds: Duration.microsecondsPerSecond ~/ 60);</span><br><span class="line"></span><br><span class="line">void onReportTimings(List&lt;FrameTiming&gt; timings) &#123;</span><br><span class="line">  lastFrames.addAll(timings);</span><br><span class="line">  //仅保留25帧</span><br><span class="line">  if(lastFrames.length &gt; maxframes) &#123;</span><br><span class="line">    lastFrames.removeRange(0, lastFrames.length - maxframes);</span><br><span class="line">  &#125;</span><br><span class="line">  //如果有原始帧回调函数，则执行</span><br><span class="line">  if (orginalCallback != null) &#123;</span><br><span class="line">    orginalCallback(timings);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double get fps &#123;</span><br><span class="line">  int sum = 0;</span><br><span class="line">  for (FrameTiming timing in lastFrames) &#123;</span><br><span class="line">    //计算渲染耗时</span><br><span class="line">    int duration = timing.timestampInMicroseconds(FramePhase.rasterFinish) - timing.timestampInMicroseconds(FramePhase.buildStart);</span><br><span class="line">    //判断耗时是否在Vsync信号周期内</span><br><span class="line">    if(duration &lt; frameInterval.inMicroseconds) &#123;</span><br><span class="line">      sum += 1;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      //有丢帧，向上取整</span><br><span class="line">      int count = (duration/frameInterval.inMicroseconds).ceil();</span><br><span class="line">      sum += count;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return lastFrames.length/sum * 60;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>页面加载时长</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class MyHomePage extends StatefulWidget &#123;</span><br><span class="line">  int startTime;</span><br><span class="line">  int endTime;</span><br><span class="line">  MyHomePage(&#123;Key key&#125;) : super(key: key) &#123;</span><br><span class="line">    //页面初始化时记录启动时间</span><br><span class="line">    startTime = DateTime.now().millisecondsSinceEpoch;</span><br><span class="line">  &#125;</span><br><span class="line">  @override</span><br><span class="line">  _MyHomePageState createState() =&gt; _MyHomePageState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class _MyHomePageState extends State&lt;MyHomePage&gt; &#123;</span><br><span class="line">  @override</span><br><span class="line">  void initState() &#123;</span><br><span class="line">    super.initState();</span><br><span class="line">    //通过帧绘制回调获取渲染完成时间</span><br><span class="line">    WidgetsBinding.instance.addPostFrameCallback((_) &#123;</span><br><span class="line">      widget.endTime = DateTime.now().millisecondsSinceEpoch;</span><br><span class="line">      int timeSpend = widget.endTime - widget.startTime;</span><br><span class="line">      print(&quot;Page render time:$&#123;timeSpend&#125; ms&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="工程架构"><a href="#工程架构" class="headerlink" title="工程架构"></a>工程架构</h2><ul>
<li>组件化<ul>
<li>独立的功能进行拆分</li>
<li>可以是一个包/页面/UI控件/常用函数</li>
<li>基本原则<ul>
<li>单一性原则，清晰自己的边界专注做自己单一的事</li>
<li>抽象化原则，抽象接口设计，变化因子尽量自己维护</li>
<li>稳定性原则，外部依赖尽量稳定，如果不稳定考虑下一条原则</li>
<li>自完备性原则，尽量自给自足减少外部依赖，除非上一条满足</li>
</ul>
</li>
<li>实施步骤<ul>
<li>剥离并实现基础功能<ul>
<li>网络请求</li>
<li>组件中间件</li>
<li>第三方库封装(尽量不直接依赖外部代码)</li>
<li>UI组件</li>
</ul>
</li>
<li>抽象并划分业务模块<ul>
<li>粒度可先粗后细</li>
<li>后续分步迭代</li>
</ul>
</li>
<li>最小化服务能力</li>
</ul>
</li>
</ul>
</li>
<li>平台化<ul>
<li>组件化的升级，在组件化的基础上增加了统一分层和依赖治理的概念</li>
<li>组件化关注组件的独立性，平台化关注组件之间的关系合理性(尽量符合单向依赖原则)</li>
<li>如果下层确实要依赖上层可以增加中间层(EventBus/Provider/Router)</li>
</ul>
</li>
</ul>
<h2 id="构建打包发布环境"><a href="#构建打包发布环境" class="headerlink" title="构建打包发布环境"></a>构建打包发布环境</h2><ul>
<li>travisCI</li>
<li>ios逆向之重签名<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 列出所有开发者证书文件</span><br><span class="line">security find-identity -p codesigning -v</span><br><span class="line"></span><br><span class="line"># 找一个开发环境配置文件生成entitlements.plist</span><br><span class="line">security cms -D -i XX.mobileprovision  &gt; profile.plist</span><br><span class="line">/usr/libexec/PlistBuddy -x -c &apos;Print :Entitlements&apos; profile.plist &gt; entitlements.plist</span><br><span class="line">cat entitlements.plist</span><br><span class="line"></span><br><span class="line"># 把准备好的开发环境配置文件复制到XX.app文件夹下</span><br><span class="line">cp XX.mobileprovision Payload/XX.app/embedded.mobileprovision</span><br><span class="line"></span><br><span class="line"># 修改包Info.plist中的Bundle Identifier与配置文件中的Bundle Identifier保持一致</span><br><span class="line">/usr/libexec/PlistBuddy -c &quot;Set :CFBundleIdentifier com.XX.XX&quot; Payload/XX.app/Info.plist</span><br><span class="line"></span><br><span class="line"># 移除之前的签名文件夹</span><br><span class="line">rm -rf Payload/XX.app/_CodeSignature</span><br><span class="line"></span><br><span class="line"># 重签名framework</span><br><span class="line">/usr/bin/codesign --force --sign 84A4B9F1F902462CC33D01E9FF72C1BA04A97653 --entitlements entitlements.plist /Payload/XX.app/Frameworks/JSONModel.framework</span><br><span class="line"></span><br><span class="line"># 重签名app执行文件</span><br><span class="line">/usr/bin/codesign --force --sign 84A4B9F1F902462CC33D01E9FF72C1BA04A97653 --entitlements entitlements.plist Payload/XX.app/XX</span><br><span class="line"></span><br><span class="line"># 查看app签名信息</span><br><span class="line">codesign -vv -d Payload/XX.app</span><br><span class="line"></span><br><span class="line"># 安装调试</span><br><span class="line">ios-deploy -d -b Payload/XX.app</span><br><span class="line"></span><br><span class="line"># 打包</span><br><span class="line">zip -qry ppdest.ipa Payload</span><br><span class="line">rm -rf Payload/</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="构建混合开发框架"><a href="#构建混合开发框架" class="headerlink" title="构建混合开发框架"></a>构建混合开发框架</h2><ul>
<li><p>混合开发</p>
<ul>
<li>原生负责提供容器和基础能力支撑</li>
<li>flutter负责业务和大部分渲染工作</li>
</ul>
</li>
<li><p>混合开发工程架构</p>
<ul>
<li>依赖分层管理<ul>
<li>原生对flutter的依赖抽象为依赖flutter模块封装的原生组件</li>
<li>flutter对原生的依赖抽象为依赖插件封装的原生行为</li>
</ul>
</li>
<li>flutter模块定义为原生工程的独立业务层，以原生基础业务层向flutter模块提供业务通用能力，原生基础能力层向flutter模块提供基础功能支撑 <img src="/2019/10/01/flutter/projectArch.png" title="混合开发工程架构"></li>
</ul>
</li>
<li><p>混合开发工作模式</p>
<img src="/2019/10/01/flutter/workflow.png" title="混合开发工作流">
<img src="/2019/10/01/flutter/cmd.png" title="flutter命令行">
</li>
<li><p>原生插件依赖管理</p>
<ul>
<li>ios的AFNetworking</li>
<li>android的OkHttp</li>
</ul>
</li>
<li><p>flutter模块工程依赖管理</p>
<ul>
<li>使用flutter插件(pubspec.yaml)</li>
<li>模块工程的ios构建产物封装以提供原生ios工程依赖管理</li>
<li>模块工程的android构建产物封装以提供原生android工程依赖管理</li>
<li>flutter模块工程把所有原生的依赖都交给了原生工程管理所以其构建产物并不会携带原生插件的封装实现，我们需要遍历模块工程所使用的原生依赖组件，并为他们逐一生成插件代码对应的原生组件封装</li>
</ul>
</li>
</ul>
<h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><ul>
<li>TabBar<ul>
<li>TabBar 默认会在 widget 树中向上寻找离它最近的一个 DefaultTabController节点作为自己的 TabController</li>
<li>如果手动创建 TabController，那么必须将它作为参数传给 TabBar</li>
</ul>
</li>
<li>FocusScope.of(context).requestFocus(myFocusNode)</li>
<li>flutter drive –target=test_driver/app.dart</li>
</ul>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>




<nav class="pagination">
  
  
  <a href="/page/2/" class="pagination-next">Next</a>
  
</nav>
    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2020 prief
    
  </p>
</footer>
    
  </div>
</div>
</body>
</html>